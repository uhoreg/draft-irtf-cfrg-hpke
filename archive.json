{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2020-09-23T14:48:02.010403+00:00",
  "repo": "cfrg/draft-irtf-cfrg-hpke",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "Pre-RGLC",
      "description": "",
      "color": "d4c5f9"
    },
    {
      "name": "editorial",
      "description": "Editorial",
      "color": "f48e75"
    }
  ],
  "issues": [
    {
      "number": 10,
      "id": "MDU6SXNzdWU1MTMzNzA1MDI=",
      "title": "Link of reference [SECG] broken",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/10",
      "state": "CLOSED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi, the link of reference \u201c[SECG] Elliptic Curve Cryptography, Standards for Efficient Cryptography Group, ver. 2\u201d seems broken. Instead of http://www.secg.org/download/aid-780/sec1-v2.pdf the following seems to work: https://secg.org/sec1-v2.pdf",
      "createdAt": "2019-10-28T15:16:05Z",
      "updatedAt": "2019-11-04T16:45:14Z",
      "closedAt": "2019-11-04T16:45:14Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU1MTYzNDM3MzY=",
      "title": "Issues in test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/12",
      "state": "CLOSED",
      "author": "kelrit",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Two issues I found in the test vectors:\r\n\r\n- kemID is incorrect. eg - for Curve25519, `kemID: 1` but it's specified as 2 in the draft.\r\n- Sequence numbers for generating nonces look off by one.\r\nFor DHKEM(Curve25519), HKDF-SHA256, AES-GCM-128, the initial nonce is `0d8e01f89fa5abab107f7fe9`, but the nonce used in the first encryption (sequence number 0) is `0d8e01f89fa5abab107f7fe8` - the initial one XOR 1.\r\nAs I understand the spec says it should be XOR 0.",
      "createdAt": "2019-11-01T20:58:13Z",
      "updatedAt": "2019-11-05T19:40:14Z",
      "closedAt": "2019-11-04T16:42:06Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @kelrit! I fixed this in #13.",
          "createdAt": "2019-11-04T16:17:38Z",
          "updatedAt": "2019-11-04T16:17:38Z"
        },
        {
          "author": "kelrit",
          "authorAssociation": "NONE",
          "body": "@chris-wood Off by one and kemID looks fixed but now it looks like the wrong algorithm is used - \r\nDHKEM(Curve25519) uses a 56 byte key (looks like Curve448?), DHKEM(P-256) appears to be a 25519 key, etc.",
          "createdAt": "2019-11-04T19:50:27Z",
          "updatedAt": "2019-11-04T19:50:27Z"
        },
        {
          "author": "kelrit",
          "authorAssociation": "NONE",
          "body": "Looks fixed with 4ae75616b42af5520cb88348e0ed5e456eee2815, thanks!",
          "createdAt": "2019-11-05T19:40:07Z",
          "updatedAt": "2019-11-05T19:40:14Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU1MTcyNzM5NTg=",
      "title": "Add an exporter",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/16",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It may be desirable to export a secret, as with the TLS exporter.  Adding such a feature would add a bit of complexity, and dilute the focus on PKE.",
      "createdAt": "2019-11-04T16:45:58Z",
      "updatedAt": "2020-01-20T16:26:12Z",
      "closedAt": "2020-01-20T16:26:12Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed by #27. @bifurcation, please re-open if that's not the case!",
          "createdAt": "2020-01-20T16:26:12Z",
          "updatedAt": "2020-01-20T16:26:12Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU1MTczMDg5OTQ=",
      "title": "KeySchedule notation issues",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/19",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the current draft (looking at branch master):\r\n\r\ndef KeySchedule(mode, pkRm, zz, enc, info, psk, pskID, pkIm):\r\n  VerifyMode(mode, psk, pskID, pkI)\r\n\r\n  pkRm = Marshal(pkR)\r\npkRm is given as parameter to KeySchedule but is calculated from pkR inside (suggestion: remove the line calculating it)\r\npkI is passed to VerifyMode, should be pkIm.\r\n\r\nFrom @dwd and @blipp ",
      "createdAt": "2019-11-04T17:52:16Z",
      "updatedAt": "2020-01-23T17:21:15Z",
      "closedAt": "2020-01-23T17:21:15Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> pkRm is given as parameter to KeySchedule but is calculated from pkR inside (suggestion: remove the line calculating it)\r\n\r\nThis has since been fixed!\r\n\r\nThe other error still exists.",
          "createdAt": "2020-01-23T03:01:58Z",
          "updatedAt": "2020-01-23T03:01:58Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU1MjEwMzQ0NDQ=",
      "title": "Add negative test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/20",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The draft only has success test vectors. Negative ones would be good, too.",
      "createdAt": "2019-11-11T15:39:27Z",
      "updatedAt": "2020-05-27T21:45:08Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU1MjEyNTQ0MzU=",
      "title": "Inconsistent naming of mode AuthPSK",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/21",
      "state": "CLOSED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Both the constant `mode_psk_auth` and function names like `SetupAuthPSKR` are used. That's inconsistent because the order of `psk` and `auth` is different. Suggestion: change the constant to be `mode_auth_psk`, because there are more function names that would need to be changed otherwise.",
      "createdAt": "2019-11-12T00:06:37Z",
      "updatedAt": "2020-01-23T17:20:23Z",
      "closedAt": "2020-01-23T17:20:23Z",
      "comments": []
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU1MjE2ODMzMzE=",
      "title": "Document security properties",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/22",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Pre-RGLC"
      ],
      "body": "For example, the base mode does not provide KCI resistance. ",
      "createdAt": "2019-11-12T17:11:33Z",
      "updatedAt": "2020-02-27T13:27:59Z",
      "closedAt": "2020-02-27T13:27:59Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "NONE",
          "body": "What would KCI mean in this setting? The sender is unauthenticated in the base case.\r\n",
          "createdAt": "2019-12-18T09:37:06Z",
          "updatedAt": "2019-12-18T09:37:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> What would KCI mean in this setting? The sender is unauthenticated in the base case.\r\n\r\nNot sure off-hand. We need to work on that! ",
          "createdAt": "2020-01-15T21:53:03Z",
          "updatedAt": "2020-01-15T21:53:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's park this until the analysis is done. We can fill out this section with better details at that point.",
          "createdAt": "2020-01-23T03:05:55Z",
          "updatedAt": "2020-01-23T03:05:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed in #44.",
          "createdAt": "2020-02-27T13:27:59Z",
          "updatedAt": "2020-02-27T13:27:59Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU1NTA0NTA4MzE=",
      "title": "Consider static DH oracles",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/28",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Do we need to be concerned about them? If receivers don't validate ephemeral keys (point on the curve, and in the right subgroup), what can go wrong?",
      "createdAt": "2020-01-15T21:53:46Z",
      "updatedAt": "2020-01-20T16:23:10Z",
      "closedAt": "2020-01-20T16:23:09Z",
      "comments": [
        {
          "author": "FredericJacobs",
          "authorAssociation": "NONE",
          "body": "I don\u2019t believe this is relevant for HPKE. My understanding is that such attacks require an oracle for the static scalar multiplier, which is not prevent in the ECDH that HPKE performs.",
          "createdAt": "2020-01-16T02:51:55Z",
          "updatedAt": "2020-01-16T02:51:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that\u2019s correct \u2014 @blipp?",
          "createdAt": "2020-01-16T02:59:30Z",
          "updatedAt": "2020-01-16T02:59:30Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, that's my understanding as well, it's not relevant for HPKE.\r\n\r\nIf an initiator sends an HPKE message to an adversary-chosen public key, that's where the oracle would be \u2013 but it is not exposing the bare curve operation, it is wrapped into Extract and Expand.",
          "createdAt": "2020-01-20T16:17:32Z",
          "updatedAt": "2020-01-20T16:17:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Great! I'll close this and move the point validation question over to a separate issue (#30).",
          "createdAt": "2020-01-20T16:23:09Z",
          "updatedAt": "2020-01-20T16:23:09Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU1NTIzNjU5Nzg=",
      "title": "Clarify directionality of HPKE with multiple encryptions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/29",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "There's currently a single sequence number space that's incremented by 1 for each message encrypted. This implies that only the initiator can encrypt messages to the receiver, else we risk key/nonce re-use. We should be clear about this in the draft!",
      "createdAt": "2020-01-20T15:23:09Z",
      "updatedAt": "2020-01-24T15:36:44Z",
      "closedAt": "2020-01-24T15:36:44Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "To be clear, you could allow both initiator and receiver to send, e.g., if they used disjoint portions of the nonce space.  For example, in a lock-step protocol where each side replies to the other, you could safely share context, since you would never have collisions.  (In theory!)  In any case, thogh, you would need operational coordination to avoid collisions.\r\n",
          "createdAt": "2020-01-20T16:50:36Z",
          "updatedAt": "2020-01-20T16:51:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> In any case, thogh, you would need operational coordination to avoid collisions.\r\n\r\nYeah, absent discussion of this coordination, risk of collision seems high. ",
          "createdAt": "2020-01-20T16:52:55Z",
          "updatedAt": "2020-01-20T16:52:55Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU1NTIzOTg0NTA=",
      "title": "Point validation?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/30",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "question"
      ],
      "body": "If receivers don't validate ephemeral keys (point on the curve, and in the right subgroup), what can go wrong? An active and malicious initiator could, for example, use that to learn the responder's private key: https://safecurves.cr.yp.to/twist.html",
      "createdAt": "2020-01-20T16:22:38Z",
      "updatedAt": "2020-01-31T20:10:22Z",
      "closedAt": "2020-01-31T20:10:22Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #35.",
          "createdAt": "2020-01-31T20:10:22Z",
          "updatedAt": "2020-01-31T20:10:22Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWU1Njg4MjcxMjk=",
      "title": "Length of PSKs in test vectors don't match with requirements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/41",
      "state": "CLOSED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The PSKs used in the test vectors currently are of length 6 bytes but should be 32 bytes for HKDF-SHA256 and 64 bytes for HKDF-SHA512.",
      "createdAt": "2020-02-21T09:10:33Z",
      "updatedAt": "2020-02-28T14:35:28Z",
      "closedAt": "2020-02-28T14:35:28Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Heh, yeah. The psk currently used is:\r\n\r\n```\r\n[]byte(\"mellon\")\r\n```\r\n\r\nNot the best!",
          "createdAt": "2020-02-21T16:21:45Z",
          "updatedAt": "2020-02-21T16:21:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #45.",
          "createdAt": "2020-02-28T14:35:28Z",
          "updatedAt": "2020-02-28T14:35:28Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU1Njg4Mjg2ODU=",
      "title": "Nenc and Npk for P512 are inconsistent within the draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/42",
      "state": "CLOSED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In Section \u201cDH-Based KEM\u201d:\r\n\r\n```\r\n* P-521: The X-coordinate of the point, encoded as a 66-octet\r\n  big-endian integer\r\n```\r\n\r\nIn \u201cAlgorithm Identifiers\u201d > \u201cKey Encapsulation Mechanisms\u201d:\r\n\r\n```\r\n| Value  | KEM               | Nenc | Npk | Reference      |\r\n|:-------|:------------------|:-----|:----|:---------------|\r\n| 0x0012 | DHKEM(P-521)      | 65   | 65  | {{NISTCurves}} |\r\n```",
      "createdAt": "2020-02-21T09:13:44Z",
      "updatedAt": "2020-02-27T13:28:47Z",
      "closedAt": "2020-02-27T13:28:46Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #44 ",
          "createdAt": "2020-02-27T13:28:46Z",
          "updatedAt": "2020-02-27T13:28:46Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU1Njk1MDI5Njc=",
      "title": "Add CCM ciphersuites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/43",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "... for use in ECHO.\r\n\r\nAES-GCM-128: https://tools.ietf.org/html/rfc5116\r\nAES-CCM-128 (8-byte IV): https://tools.ietf.org/html/rfc6655\r\n\r\nWe should reference where these AEADs are defined, too (5116 for GCM, 8439 for ChaCha20Poly1305).",
      "createdAt": "2020-02-23T14:24:22Z",
      "updatedAt": "2020-02-25T22:00:42Z",
      "closedAt": "2020-02-25T22:00:42Z",
      "comments": []
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU1NzI3OTA4MzI=",
      "title": "Add domain separation for expanded secrets",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/46",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We currently have none!",
      "createdAt": "2020-02-28T14:29:29Z",
      "updatedAt": "2020-03-20T14:36:31Z",
      "closedAt": "2020-03-20T14:36:31Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #47.",
          "createdAt": "2020-03-20T14:36:31Z",
          "updatedAt": "2020-03-20T14:36:31Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "MDU6SXNzdWU1NzgxNjY4NzU=",
      "title": "Mismatch on psk length for SHA256",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/52",
      "state": "CLOSED",
      "author": "R1kM",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "At the moment, the length of psk in the test vectors is the same for SHA256 and SHA512. As far as I can tell, psk should only contain 32 bytes for SHA256 instead of 64.\r\nAdditionally, psk, pskID and pkS are not needed in the Base setup (https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#base-setup-information for instance)",
      "createdAt": "2020-03-09T20:21:10Z",
      "updatedAt": "2020-05-07T12:20:49Z",
      "closedAt": "2020-05-07T12:20:48Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> At the moment, the length of psk in the test vectors is the same for SHA256 and SHA512. As far as I can tell, psk should only contain 32 bytes for SHA256 instead of 64.\r\n\r\nThe length of the PSK is not required to match the KDF. I hope we clarified that in the current version: https://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#name-authentication-using-a-pre-\r\n\r\n> Additionally, psk, pskID and pkS are not needed in the Base setup (https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#base-setup-information for instance)\r\n\r\nGood catch! I'll use this issue to track removing them from those modes. ",
          "createdAt": "2020-04-10T21:05:09Z",
          "updatedAt": "2020-04-10T21:05:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed now. Closing!",
          "createdAt": "2020-05-07T12:20:48Z",
          "updatedAt": "2020-05-07T12:20:48Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU1ODAxNjQyNzU=",
      "title": "Mismatch on zz length for P-256",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/53",
      "state": "CLOSED",
      "author": "R1kM",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "`zz`, as computed by `Decap`, is indicated to have length `Npk` https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#dh-based-kem.\r\nThis does not match the length of the test vector provided for P-256 https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#base-setup-information-2",
      "createdAt": "2020-03-12T19:15:52Z",
      "updatedAt": "2020-04-10T21:01:13Z",
      "closedAt": "2020-04-10T21:01:13Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "`zz` has length `Nzz`, which is the \"length in bytes of a shared secret produced by\" a KEM, and is equal to 32 for P-256: https://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#name-key-encapsulation-mechanism\r\n\r\nThe length in the test vector referenced is 32B (unless I'm misreading), so I'm closing this as resolved. Please re-open if I made a mistake!",
          "createdAt": "2020-04-10T21:01:13Z",
          "updatedAt": "2020-04-10T21:01:13Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWU2MTM2MTU3NDA=",
      "title": "Updated test vectors do not match the spec",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/66",
      "state": "CLOSED",
      "author": "kjacobs-moz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "While updating labels for draft-03, I noticed that the test vectors added in 5bc57ba5753f6e76d6350e532c1ca069ac8b228c seem to be incorrect, matching an implementation that:\r\n\r\n1) Uses the label \"info_hash\" to extract `info_hash`, when draft-03 specifies \"info\".\r\n2) Uses the label \"psk\" to extract `psk`, when \"psk_hash\" is specified.  \r\n\r\nWith the \"_hash\" suffix swapped as above, my implementation generates matching outputs. ",
      "createdAt": "2020-05-06T21:11:13Z",
      "updatedAt": "2020-05-08T19:28:37Z",
      "closedAt": "2020-05-08T19:28:37Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Will fix -- thanks!",
          "createdAt": "2020-05-06T23:47:16Z",
          "updatedAt": "2020-05-06T23:47:16Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWU2MTM2Mjk2MjI=",
      "title": "Ambiguous Nzz definition, possible wrong value for P-521",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/67",
      "state": "CLOSED",
      "author": "kjacobs-moz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Table 7.1 specifies an Nzz value of 64 for _DHKEM(P-521, HKDF-SHA512)_. The test vectors are using a value of 66, which seems right given:\r\n\r\n> Nzz: The length in bytes of a shared secret produced by the algorithm.\r\n\r\n(in context of KEM identifiers, not KDF).\r\n\r\nBut, 4.1 also states:\r\n\r\n> For the variants of DHKEM defined in this document, Ndh is equal to Npk, and the output length of the KDF's Extract function is Nzz bytes.\r\n\r\nWe should clarify whether Nzz is based on the ECDH or HKDF-Extract output length, and fix the test vectors if necessary.\r\n",
      "createdAt": "2020-05-06T21:38:37Z",
      "updatedAt": "2020-05-08T19:28:30Z",
      "closedAt": "2020-05-08T19:28:30Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch. It should be 66. I think we fat fingered the calculation :-)\r\n\r\n   (512 + 7) >> 3 = 64\r\n\r\nThanks!",
          "createdAt": "2020-05-06T23:59:36Z",
          "updatedAt": "2020-05-06T23:59:36Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The values for `Nzz` were chosen to be the same as the output length of the hash function underlying the KDF used in the variants of DHKEM. In `DHKEM(P-521, HKDF-SHA512)`, the KDF is `HKDF-SHA512` with the hash function `SHA512`, which has output length 64 bytes.\r\n\r\nThus, as one of the possibilities mentioned by @kjacobs-moz , `Nzz` is based on the HKDF-Extract output length. That is because HKDF-Extract is exactly _one_ call to HMAC and returns its result; HMAC's output length is the output length of the underlying hash function. HKDF-Expand has variable output length, that is why it would not make sense to define Nzz via HKDF-Expand's output length, but rather we need to define HKDF-Expand's output length by Nzz.\r\n\r\nWhile a P-521 DH shared secret might justify, from a security level point of view, a KEM shared secret a bit longer than 64 bytes, I believe it is beneficial to keep it at 64 bytes because then HKDF-Expand is exactly _one_ call to HMAC. With 66 bytes, or 65 bytes, we would need an entire second call to HMAC, only to gain one byte. Also, because the KeySchedule continues with SHA512 as well, we do not benefit from the slightly higher security level, I think.\r\n\r\nTo conclude, I believe we should keep the 64 as it is.\r\n\r\nHaving written this, I admit that it took me a bit to understand what we meant with the sentence \u201cand the output length of the KDF's Extract function is Nzz bytes\u201d. While it is clearly true for the specified variants of DHKEM, it is a confusing formulation. Maybe we can come up with something better. (Edited to add: I just made a proposal in the discussion of #68.)",
          "createdAt": "2020-05-07T06:56:06Z",
          "updatedAt": "2020-05-07T07:11:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Hah! We all misunderstood that sentence. It didn't occur to me that the intention was to make `Nzz` match the size of HKDF-Extract based on text. Your proposal in #68 clears that up. I'll fix the code, update that PR, and send over new test vectors for folks to try. ",
          "createdAt": "2020-05-07T12:02:31Z",
          "updatedAt": "2020-05-07T12:02:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #68!",
          "createdAt": "2020-05-07T12:19:55Z",
          "updatedAt": "2020-05-07T12:19:55Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWU2MTM2OTc3MjE=",
      "title": "Unnecessary return value in Decap(), AuthDecap()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/69",
      "state": "CLOSED",
      "author": "kjacobs-moz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The spec definition of `Decap()` includes taking `enc` as a parameter, and returning it unmodified: \r\n\r\n```\r\n   def Decap(enc, skR):\r\n     pkE = Unmarshal(enc)\r\n     dh = DH(skR, pkE)\r\n\r\n     pkRm = Marshal(pk(skR))\r\n     kemContext = concat(enc, pkRm)\r\n\r\n     zz = ExtractAndExpand(dh, kemContext)\r\n     return zz, enc\r\n```\r\n\r\nOnly `return zz` is needed. The same applies to AuthDecap. ",
      "createdAt": "2020-05-07T00:44:17Z",
      "updatedAt": "2020-05-08T19:28:23Z",
      "closedAt": "2020-05-08T19:28:23Z",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good catch, thanks! @chris-wood , do you want to incorporate this into #68 ?",
          "createdAt": "2020-05-07T07:01:01Z",
          "updatedAt": "2020-05-07T07:01:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, will do!",
          "createdAt": "2020-05-07T12:18:19Z",
          "updatedAt": "2020-05-07T12:18:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Added to #68.",
          "createdAt": "2020-05-07T12:19:40Z",
          "updatedAt": "2020-05-07T12:19:40Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "MDU6SXNzdWU2MTUyMzI3ODQ=",
      "title": "pkSm does nothing in KeySchedule",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/71",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I was looking through a code coverage map of my implementation and realized that `default_pkSm` is never actually used anywhere. `KeySchedule` takes in a `pkSm` and uses it to sanity-check the given `mode`, and then uses it nowhere in the key schedule itself. Should `pkSm` be removed as an argument?",
      "createdAt": "2020-05-09T18:17:57Z",
      "updatedAt": "2020-05-20T14:29:13Z",
      "closedAt": "2020-05-20T14:29:13Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's there primarily to help distinguish the mode, so I think we ought to keep it. That said, it might encourage implementations to pass it when not needed. \r\n\r\nIf you were to remove it, how would you specify the mode check?",
          "createdAt": "2020-05-12T12:56:43Z",
          "updatedAt": "2020-05-12T12:56:43Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, if you want to keep it in I don't have any strong suggestions to make it more elegant. FWIW I found it more ergonomic to implement `mode` as an enum that contains precisely the things it needs to\r\n\r\n```rust\r\nenum OpModeR<Dh: DiffieHellman, Kd: Kdf> {\r\n    Base,\r\n    Psk(PskBundle<Kd>),\r\n    Auth(Dh::PublicKey),\r\n    AuthPsk(Dh::PublicKey, PskBundle<Kd>),\r\n}\r\n```",
          "createdAt": "2020-05-12T16:14:25Z",
          "updatedAt": "2020-05-12T16:14:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, I would suspect most folks to implement it this way. \r\n\r\n@bifurcation, this seems editorial. Do you have a preference here?",
          "createdAt": "2020-05-15T14:54:22Z",
          "updatedAt": "2020-05-15T14:54:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think `pkSm` can be removed.  The only thing it signals is that you're in an authenticated mode, which the `mode` argument already indicates.  You could then also simplify `VerifyMode` to something like:\r\n\r\n```\r\ndef VerifyPSKInputs(mode, psk, pskID):\r\n  got_psk = (psk != default_psk)\r\n  if got_psk != (pskID != default_pskID):\r\n    raise Exception(\"Inconsistent PSK inputs\")\r\n\r\n  if got_psk and (mode in [mode_base, mode_auth]):\r\n    raise Exception(\"PSK input provided when not needed\")\r\n  if not got_psk and (mode in [mode_psk, mode_auth_psk]):\r\n    raise Exception(\"Missing required PSK input\")\r\n```\r\n\r\nI agree that most languages will have more elegant constructs (inlcuding python), but the spec needs to be language agnostic.",
          "createdAt": "2020-05-17T20:15:24Z",
          "updatedAt": "2020-05-17T20:15:24Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "MDU6SXNzdWU2MTYxMTI1NjI=",
      "title": "Contents of a context aren't well-defined",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/72",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This is just an editorial comment. The spec doesn't seem to define the contents of a \"context\" very clearly. Section 5 says:\r\n> A \"context\" encodes the AEAD algorithm and key in use, and manages the nonces used so that the same nonce is not used with multiple plaintexts.\r\n\r\nBut it also has an exporter secret. Then section 5.1 says:\r\n> return Context(key, nonce, exporter_secret)\r\n\r\nBut we haven't defined the `Context` function yet. I'm guessing the intent is that `Context` produces some sort of record type with those field names? But that wouldn't initialize `Context.seq` used later in 5.2. (Confusingly, this `Context` is distinct from the `context` variable which contains an `HPKEContext` structure. Maybe the latter could be renamed?)\r\n\r\nThen 5.2 lists out the contents of a \"context' more explicitly, including the first mention of a sequence number. But it omits the exporter secret again. (Should \"The sender's context MUST be used for encryption only. Similarly, the recipient's context MUST be used for decryption only.\" be rephrased? One could read that as saying export is also not okay.)\r\n\r\nThen 5.3 mentions a context having an \"exporter secret\", but this is actually the only instance of that phrase in the document.",
      "createdAt": "2020-05-11T19:05:28Z",
      "updatedAt": "2020-05-27T21:44:54Z",
      "closedAt": "2020-05-27T21:44:53Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with `Context` being somewhat confusing. I propose to rename it to `AEADContext` and clearly define the attributes (key, nonce, exporter, secret).",
          "createdAt": "2020-05-14T16:21:06Z",
          "updatedAt": "2020-05-14T16:21:06Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "NONE",
          "body": "The \"context\" does seem to be related to the entire HPKE exchange from how it's constructed. Since AEADs already mean something, AEADContext would probably result in APIs calling it `HPKE_AEAD_CONTEXT` with nothing actually exposed as `HPKE_CONTEXT`. Seems renaming the existing HPKEContext would work better.",
          "createdAt": "2020-05-14T17:14:49Z",
          "updatedAt": "2020-05-14T17:14:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:44:53Z",
          "updatedAt": "2020-05-27T21:44:53Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWU2MTg3ODMzODc=",
      "title": "Outdated reference",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/74",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "In \"DH-Based KEM\" the paragraph \r\n\r\n> The GenerateKeyPair, Marshal, and Unmarshal functions are the same as for the underlying DH group. The Marshal functions for the curves referenced in {#ciphersuites} are as follows:\r\n\r\nreferences the #ciphersuites section that no longer seems to exist.",
      "createdAt": "2020-05-15T08:12:10Z",
      "updatedAt": "2020-05-19T15:35:35Z",
      "closedAt": "2020-05-19T15:35:35Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I pushed a change directly to master to fix this. Thanks!",
          "createdAt": "2020-05-19T15:35:35Z",
          "updatedAt": "2020-05-19T15:35:35Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWU2MTkwMTU0MjM=",
      "title": "Shared secret size for P-256",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/75",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's currently 32 bytes, i.e., just the x-coordinate of the point. But Npk suggests it should be a fully-encoded public key. Which do we prefer?\r\n\r\ncc @blipp @bifurcation \r\n\r\n(Thanks to Michael Scott for raising this!)",
      "createdAt": "2020-05-15T14:37:46Z",
      "updatedAt": "2020-05-19T15:35:57Z",
      "closedAt": "2020-05-19T15:35:57Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "No opinion.  If 65 bytes is more consistent with other modes, that's fine.  ",
          "createdAt": "2020-05-17T20:04:47Z",
          "updatedAt": "2020-05-17T20:04:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's use the encoded public keys, then, and update the test vectors!",
          "createdAt": "2020-05-18T13:47:36Z",
          "updatedAt": "2020-05-18T13:47:36Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that `dh` should be understood as being a marshalled curve point that was returned by `DH` (if the marshal is done internally in `DH` or afterwards depends on the implementation I guess) \u2013 at least that's what I had in mind when working on my pull requests to the draft. Should we clarify it in the text?\r\n\r\nEdited to add: I should clarify that in the authenticated modes, `dh` is a concatenation of two marshalled curve points.",
          "createdAt": "2020-05-19T13:31:58Z",
          "updatedAt": "2020-05-19T13:33:38Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I added pull request #80 in an attempt to clarify some occurrences of Ndh and Nzz.",
          "createdAt": "2020-05-19T14:53:54Z",
          "updatedAt": "2020-05-19T14:53:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #78 and #80. Closing.",
          "createdAt": "2020-05-19T15:35:57Z",
          "updatedAt": "2020-05-19T15:35:57Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "MDU6SXNzdWU2MTkwMTgyMTQ=",
      "title": "ExtractAndExpand input parameters",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/76",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Michael Scott:\r\n\r\n> A minor observation. In ExtractAndExpand the salt parameter is zero(Nh).\r\n>\r\n> In fact this is the same as using zero(0), as HMAC internally pads this up to a blocksize of zeros.\r\n>\r\n> So for example if using SHA512 and Nh=64, the hash blocksize is 128, and zero(0) gets padded up to 128 zeros, as does zero(64) . In fact the parameter to zero(.) is irrelevant.\r\n\r\nWe might consider `zero(2*Nh)` or `zero(0)`. What do you think, @blipp?",
      "createdAt": "2020-05-15T14:40:16Z",
      "updatedAt": "2020-05-20T15:08:03Z",
      "closedAt": "2020-05-20T15:08:03Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The observation is only true for HKDF, not necessarily for other KDFs.  For similar reasons, we shouldn't do `zero(2*Nh)`.\r\n\r\nThat said, it doesn't really seem like the salt is adding anything, so I would be fine with `zero(0)` or `\"\"` or however we want to write it.",
          "createdAt": "2020-05-17T20:22:12Z",
          "updatedAt": "2020-05-17T20:22:12Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with using something like `zero(0)` or `\"\"` to make clear that we want to \u201cnot provide\u201d the salt value, like [RFC 5869 (HKDF)](https://hyp.is/PvmompnREeq4Ddvtm_Is0w/tools.ietf.org/html/rfc5869) formulates it:\r\n\r\n```\r\n2.2.  Step 1: Extract\r\n\r\n[\u2026]\r\n\r\n   Inputs:\r\n      salt     optional salt value (a non-secret random value);\r\n               if not provided, it is set to a string of HashLen zeros.\r\n      IKM      input keying material\r\n```\r\n\r\nI think `zero(0)` would be good, because we use this as the default pskID, too.",
          "createdAt": "2020-05-19T13:13:57Z",
          "updatedAt": "2020-05-19T13:13:57Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "MDU6SXNzdWU2MTkwOTU0MjY=",
      "title": "Caveat in test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/77",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The plaintext is always the same, but the nonces and AADs differ by just one bit, which is hard to spot and easily missed.",
      "createdAt": "2020-05-15T16:26:54Z",
      "updatedAt": "2020-05-23T23:44:57Z",
      "closedAt": "2020-05-23T23:44:57Z",
      "comments": []
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWU2MjE0ODc1NzI=",
      "title": "Ambiguity about Secret Export",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/83",
      "state": "CLOSED",
      "author": "ocheron",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": "Section 5.3 explains secrets are exported with the KDF Expand function but the included code in the same section now calls LabeledExpand with a \"sec\" label.\r\n\r\nThe JSON test vectors contain sample results for the export function, but they match an unlabeled implementation with Expand and not LabeledExpand.",
      "createdAt": "2020-05-20T06:09:46Z",
      "updatedAt": "2020-05-28T17:39:15Z",
      "closedAt": "2020-05-27T21:44:44Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch! We missed updating the `Export` code and test vectors. ",
          "createdAt": "2020-05-24T00:30:03Z",
          "updatedAt": "2020-05-24T00:30:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:44:44Z",
          "updatedAt": "2020-05-27T21:44:44Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "Thank you, now all vectors pass with expected definitions.\r\nText will be clear enough, I just wasn't sure the direction you wanted.",
          "createdAt": "2020-05-28T17:39:15Z",
          "updatedAt": "2020-05-28T17:39:15Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWU2MjE4NDMxMzQ=",
      "title": "Guidance for future KEMs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/84",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nAs guidance for future revisions, we would recommend adding a section about the issues that need to be considered when adding support for other KEMs. There will presumably be industry interest in including post-quantum KEMs (as anticipated in Sec. 8.1), and there may also be interest in including RSA-based KEMs, for legacy support.  The technical subtleties in adding such mechanisms include:\r\n\r\n- Assumptions about the relationship between the private key and the public key and the definition of the \"pk()\" function.  For instance, GenerateKeyPair, listed as part of a KEM in Section 4, doesn't really need to be part of one (it's not part of RSA-KEM).\r\n\r\n- Assumptions about the length of the public key.  It may not always be a fixed value, \"Npk\", for a KEM with a given set of parameters.  The other (and unrelated) \"hybrid\" draft, draft-ietf-tls-hybrid-design, Section 3.2 ,makes accommodation for public keys associated with a given set of parameters to vary in size.",
      "createdAt": "2020-05-20T15:11:11Z",
      "updatedAt": "2020-05-20T15:23:44Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 85,
      "id": "MDU6SXNzdWU2MjE4NDM0MDU=",
      "title": "Clarify DH-only KEMs in the abstract ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/85",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nThe draft only specifies a Diffie-Hellman-based KEM (Section 4.1). To set expectations for the implementer, we recommend stating this limitation in the abstract, e.g., by adding \"based on elliptic curve Diffie-Hellman key agreement\" at the end of the last sentence of the abstract.",
      "createdAt": "2020-05-20T15:11:31Z",
      "updatedAt": "2020-05-27T21:41:45Z",
      "closedAt": "2020-05-27T21:41:45Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:41:45Z",
          "updatedAt": "2020-05-27T21:41:45Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "MDU6SXNzdWU2MjE4NDM4ODk=",
      "title": "Clarify \"hybrid\" in the introduction",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/86",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nAsymmetric and symmetric algorithms have been combined since the 1980s, e.g., in Privacy-Enhanced Mail [RFC1113], so a hybrid approach (in the sense of combining the two) can by now be considered the \"tradition\" of public-key cryptography.  We would therefore suggest replacing the first sentence with the following:\r\n\r\nEncryption schemes that combine asymmetric and symmetric algorithms have been specified and practiced since the early days of public-key cryptography (e.g., [RFC1113]).  Combining the two brings the \"best of both worlds\":  the key management advantages of asymmetric cryptography and the performance benefits of symmetric cryptography.  However, the traditional combination has been \"encrypt the symmetric key with the public key.\"  \"Hybrid\" public-key encryption schemes (HPKE), specified here, take a different combination, \"generate the symmetric key and its encapsulation with the public key.\" .",
      "createdAt": "2020-05-20T15:12:09Z",
      "updatedAt": "2020-05-27T21:43:18Z",
      "closedAt": "2020-05-27T21:43:18Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:43:18Z",
          "updatedAt": "2020-05-27T21:43:18Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWU2MjE4NDQwODM=",
      "title": "Clarify \"formally verified\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/87",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nShould \"formally verified\" be \"proven secure under standard cryptographic assumptions\"?  Or is the intent indeed to enable tools that check correctness of an implementation?",
      "createdAt": "2020-05-20T15:12:25Z",
      "updatedAt": "2020-05-27T21:42:11Z",
      "closedAt": "2020-05-27T21:42:10Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:42:10Z",
          "updatedAt": "2020-05-27T21:42:10Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU2MjE4NDQ0NjU=",
      "title": "Clarify unsigned property of encode_big_endian",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/88",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nSection 3:  Definition of encode_big_endian:  Add \"unsigned\" before \"integer\" if this is the intent (so that the set of encodable n-byte integers clearly includes 0 through 2^{8n}-1).",
      "createdAt": "2020-05-20T15:12:55Z",
      "updatedAt": "2020-05-27T21:42:18Z",
      "closedAt": "2020-05-27T21:42:17Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:42:17Z",
          "updatedAt": "2020-05-27T21:42:17Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "MDU6SXNzdWU2MjE4NDUyNTc=",
      "title": "Clarify additional key material in authenticated modes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/89",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nSection 5:\r\n \"we include two authenticated variants .\":  We would also suggest mentioning that these variants also contribute additional keying material to the encryption operation.  See also discussion in Section 8.1.\r\n\r\nAfter the sentence, \"the constructions described here presume .\", mention that the recipient also needs a way to determine which of its public keys was used for the encapsulation operation (if the recipient has more than one public key).  Also add a reference to Section 9 which addresses the corresponding issues for message encoding.",
      "createdAt": "2020-05-20T15:13:56Z",
      "updatedAt": "2020-05-27T21:44:08Z",
      "closedAt": "2020-05-27T21:44:07Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:44:07Z",
          "updatedAt": "2020-05-27T21:44:07Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWU2MjE4NDU4NTA=",
      "title": "Include mode as KeySchedule input",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/90",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nSection 5.1:\r\n\r\n \"mode\" should also be listed as a key schedule input.",
      "createdAt": "2020-05-20T15:14:41Z",
      "updatedAt": "2020-05-27T21:43:10Z",
      "closedAt": "2020-05-27T21:43:10Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:43:10Z",
          "updatedAt": "2020-05-27T21:43:10Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWU2MjE4NDcyMTI=",
      "title": "Fix some nits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/91",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\n \"assumed that the sender\" --> \"assured that the sender\"\r\n\r\nSection 8.2:\r\n\r\n\"KEM public key pkR\" --> \"KEM public key \"pkR\"\"\r\n\r\n\"ciphertext enc\" --> \"encapsulated key enc\" (two occurrences).  \"Ciphertext\" is used elsewhere in the draft to refer to the AEAD output.\r\n\r\nSection 8.3:  There is a non-normative (lower-case) \"should\" in the first sentence.  (Contrasting against a normative/upper-case \"SHOULD\" in the first sentence of 8.4.)  Should this \"should\" be \"SHOULD\"?\r\n\r\nSection 8.7:  There are missing quotes around \"(enc2, ciphertext2, enc, ciphertext)\".",
      "createdAt": "2020-05-20T15:16:28Z",
      "updatedAt": "2020-05-27T21:42:03Z",
      "closedAt": "2020-05-27T21:42:03Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:42:03Z",
          "updatedAt": "2020-05-27T21:42:03Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "MDU6SXNzdWU2MjE4NDc0MjI=",
      "title": "Harmonize label values",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/92",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nThe \"label\" argument to LabeledExtract is being used in some cases to identify the output, in one case to identify the input, and in one case to identify the intent.  We suggest harmonizing on the former, and also consistently suffixing the output variable name with \"_hash\" when the purpose of the extraction is to produce a hash of the input.  This would result in the following statements being updated:\r\n\r\ninfo_hash = LabeledExtract(zero(Nh), \"info_hash\", info) // new label\r\n\r\npsk_hash = LabeledExtract(zero(Nh), \"psk_hash\", psk) // new output name\r\n\r\nsecret = LabeledExtract(psk_hash, \"secret\", zz) // new input name and label",
      "createdAt": "2020-05-20T15:16:46Z",
      "updatedAt": "2020-05-27T21:41:57Z",
      "closedAt": "2020-05-27T21:41:56Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:41:56Z",
          "updatedAt": "2020-05-27T21:41:56Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "MDU6SXNzdWU2MjE4NDgwNTQ=",
      "title": "Avoid confusing normative language",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/93",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nSection 5.1.3: The lower-case \"must\" in \"the sender must be the other\" might be confused with normative \"MUST\".  Suggest using a different word or changing to the normative form.",
      "createdAt": "2020-05-20T15:17:30Z",
      "updatedAt": "2020-05-27T21:41:22Z",
      "closedAt": "2020-05-27T21:41:22Z",
      "comments": []
    },
    {
      "number": 94,
      "id": "MDU6SXNzdWU2MjE4NDg4MTU=",
      "title": "Clarify pseudocode and define undefined operands",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/94",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nSection 5.2.:\r\n\r\nThe symbol \"<<\" isn't defined, but assuming it means \"shift left by a specified number of bits\", the number of bits to shift should be \"8*Nn\" rather than \"Nn\".\r\n\r\nDoes \"overflow\" in the third paragraph refer to the same condition as \"wrap\" in the fifth paragraph?  If so, the text should be combined and a single term used for consistency.  If not, the differences between the two requirements should be explained.  We would also suggest adding a note indicating that the reference code assumes the sequence number is the same length as the nonce.\r\n\r\nThe use of \"Nonce\" (capitalized) as a function and \"nonce\" (lower case) as a value may be confusing.  We suggest instead that the function be named \"ComputeNonce\" or similar.\r\n\r\nOn a similar object-oriented programming note, it should be stated that the underlying \"Seal\" and \"Open\" functions are the ones determined by the  \"aead_id\" property.",
      "createdAt": "2020-05-20T15:18:29Z",
      "updatedAt": "2020-05-27T21:41:15Z",
      "closedAt": "2020-05-27T21:41:15Z",
      "comments": []
    },
    {
      "number": 95,
      "id": "MDU6SXNzdWU2MjE4NDk0MDQ=",
      "title": "Fix some references",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/95",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\n[ANSI]:  Add \"X9.63\" to title.\r\n\r\n[BNT19] and other references as needed:  Add authors' names.\r\n\r\n[MAEA10]:  Use \"authoritative\" URI for long-term stability: https://ieeexplore.ieee.org/abstract/document/5604194/.",
      "createdAt": "2020-05-20T15:19:13Z",
      "updatedAt": "2020-05-27T21:41:51Z",
      "closedAt": "2020-05-27T21:41:50Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:41:50Z",
          "updatedAt": "2020-05-27T21:41:50Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWU2MjE4NTA2MjY=",
      "title": "Clarify test vector labels",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/96",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nAppendix:  \"pkR\", \"pkS\" values are given.  These are presumably the same as the marshalled versions \"pkRm\", \"pkSm\", this should be stated for completeness.  (In contrast, both \"pKE\" and the equivalent \"enc\" are shown.)",
      "createdAt": "2020-05-20T15:20:50Z",
      "updatedAt": "2020-05-27T21:42:48Z",
      "closedAt": "2020-05-27T21:42:47Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:42:47Z",
          "updatedAt": "2020-05-27T21:42:47Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWU2MjE4NTA5NjI=",
      "title": "Cite Shoup for identity misbinding prevention in 8.2",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/97",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\n \"avoid identity mis-binding issues\":  Perhaps also note that including the public key and the encapsulated key as inputs to key derivation can help with the security proof.  [Shoup] makes this observation in Section 15.6.1.\r\n\r\n[Shoup]  @article{shoup2001proposal,\r\n  title={A proposal for an ISO standard for public key encryption (version 2.1)},\r\n  author={Shoup, Victor},\r\n  journal={IACR e-Print Archive},\r\n  volume={112},\r\n  year={2001}\r\n}\r\n",
      "createdAt": "2020-05-20T15:21:19Z",
      "updatedAt": "2020-05-27T21:41:08Z",
      "closedAt": "2020-05-27T21:41:08Z",
      "comments": []
    },
    {
      "number": 98,
      "id": "MDU6SXNzdWU2MjE4NTEzNjU=",
      "title": "Add some color to post quantum proof discussion",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/98",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nSection 8.1:  \"A full proof of post-quantum security .\".  Although we understand that a full proof of post-quantum security may not be achievable within the timeline of this draft's publication, we would nevertheless recommend some additional discussion on what might be desirable to prove.  In the draft, the PSK is employed as an authentication factor, so presumably the proof being contemplated would be that authentication in the modes involving PSKs remains secure against a quantum computer.  A stronger property would be more attractive:  that encryption in the PSK modes remains secure against a quantum computer, whether the KEM itself is post-quantum or not.  If the authors consider this property plausible, then it should be mentioned here as a goal for security analysis.  If not, then the reasons for not targeting this property should also be given.\r\n\r\n",
      "createdAt": "2020-05-20T15:21:50Z",
      "updatedAt": "2020-06-26T21:41:23Z",
      "closedAt": "2020-06-26T21:41:22Z",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These are some excellent points!\r\n\r\n### PSK is also strengthening confidentiality\r\nIndeed we are only talking about authentication with respect to the PSK:\r\n* [Creating the Encryption Context](https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#creating-the-encryption-context)\r\n```\r\nIf the psk and pskID arguments are provided, then the recipient is\r\nassured that the sender held the PSK.\r\n```\r\n* [Authentication using a Pre-Shared Key](https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#authentication-using-a-pre-shared-key-mode-psk) and [Authentication using both a PSK and an Asymmetric Key](https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#authentication-using-both-a-psk-and-an-asymmetric-key-mode-auth-psk)\r\n```\r\nThis variant extends the base mechanism by allowing the recipient to\r\nauthenticate that the sender possessed a given pre-shared key (PSK).\r\n```\r\n\r\nThe analysis I did in CryptoVerif shows that confidentiality remains if the KEM keys are compromised (or if the KEM keys are not compromised but the PSK is compromised). So we should indeed add this as a desired security property, with pretty much the same reasoning as employed by WireGuard, see [Section 5.2 in the WireGuard whitepaper](https://hyp.is/eMrNnKHTEeqR-TeuWEsFDA/www.wireguard.com/papers/wireguard.pdf).\r\n\r\n### Authentication provided by PSK in quantum setting\r\nIn the same way, the analysis shows that authentication remains if KEM keys are compromised, or if the PSK is compromised but not the KEM keys.\r\n\r\nSo, in a way, this is just about discussing desired security properties in different compromise cases, where certain compromise cases are especially relevant because of quantum adversaries.\r\n\r\n### Minor nit\r\nBy the way, in [Security Properties](https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#security-properties-sec-properties), we should add that the PSK mode is also providing sender authentication.\r\n```\r\nSender authentication: Proof of sender origin for Auth and AuthPSK modes\r\n```\r\nLater, in [Metadata Protection](https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#metadata-protection), PSK mode is correctly listed as authenticated mode.\r\n```\r\nThe authenticated modes of HPKE (PSK, Auth, AuthPSK) require [\u2026]\r\n```\r\n\r\nI'll try to find time to draft a pull request.",
          "createdAt": "2020-05-29T17:50:19Z",
          "updatedAt": "2020-05-29T17:50:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #119.",
          "createdAt": "2020-06-26T21:41:22Z",
          "updatedAt": "2020-06-26T21:41:22Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWU2MjIwNzk1ODM=",
      "title": "Inconsistent use of X25519 vs Curve25519",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/100",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The HPKE draft refers to \"Curve25519\" and \"DHKEM(Curve25519, HKDF-SHA256)\" throughout the draft, but then section 8.8 mentions DHKEM-X25519.\r\n\r\nI believe X25519 is correct here. RFC7748 defines \"curve25519\" as a particular Montgomery curve. It then defines \"X25519\" as a Diffie-Hellman primitive on top of curve25519, with particular encodings and everything else. HPKE is using the Diffie-Hellman primitive, so it should use X25519. As a bonus, it's shorter and \"DHKEM(Curve25519, HKDF-SHA256)\" is already a mouthful. :-)",
      "createdAt": "2020-05-20T20:56:34Z",
      "updatedAt": "2020-06-03T15:35:56Z",
      "closedAt": "2020-05-27T21:40:35Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, we mean X25519 -- thanks for pointing this out!",
          "createdAt": "2020-05-23T14:13:01Z",
          "updatedAt": "2020-05-23T14:13:01Z"
        },
        {
          "author": "dvorak42",
          "authorAssociation": "NONE",
          "body": "Looks like the section labels for the test vectors didn't get updated? (They still read DHKEM(Curve25519...))",
          "createdAt": "2020-06-03T13:56:24Z",
          "updatedAt": "2020-06-03T13:56:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@dvorak42 doh! I missed that. Thanks for pointing it out. I'll update the labels in a future change.",
          "createdAt": "2020-06-03T15:35:56Z",
          "updatedAt": "2020-06-03T15:35:56Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "MDU6SXNzdWU2Mjc4ODcxNDc=",
      "title": "Limits on Inputs to LabeledExtract and LabeledExpand",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/102",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm trying to remove all allocation from my implementation, and there's really only 1 snag I'm hitting: LabeledExtract and LabeledExpand do a `concat` operation before passing to their respective HKDF functions, and there isn't always an upper bound on the size of the concatenated result. Specifically, there's\r\n```\r\nKeySchedule(info, psk, pskID):\r\n    LabeledExtract(..., info)\r\n    LabeledExtract(..., psk)\r\n    LabeledExtract(..., pskID)\r\nContext.Export(exporter_context):\r\n    LabeledExpand(..., exporter_context, ...)\r\n```\r\n\r\nIf there were a (reasonably small) upper bound on the sizes of `info`, `psk`, `pskID`, and `exporter_context`, then it would be trivial to implement HPKE without allocation.\r\n\r\nI've thought about \"streaming\" the input into the above functions, instead of sending a concatenated bytestring. This could theoretically work for HKDF-Extract with SHA256, since it's an MD hash, but this doesn't work generically. Also the definition of HKDF-Expand does not admit a way to stream in the `info` string.",
      "createdAt": "2020-05-31T04:08:40Z",
      "updatedAt": "2020-06-17T23:39:03Z",
      "closedAt": "2020-06-17T23:39:02Z",
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A side effect of this would be that the `Psk` and `PskBundle` (containing a PSK and PSK ID) types in the Rust implementation would not need to allocate and also not need cumbersome lifetime specifiers, since they could just maintain a fixed-size buffer of their contents.",
          "createdAt": "2020-05-31T04:39:12Z",
          "updatedAt": "2020-05-31T04:39:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "What would be \"reasonably small\" here? TLS allows 16-bit PSK identities and exported contexts, for example. ",
          "createdAt": "2020-05-31T13:26:21Z",
          "updatedAt": "2020-05-31T13:26:21Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If `pskID` were 2 bytes (or an integer that we explicitly encode) and everything else were at most size `Nh`, that would be sufficient",
          "createdAt": "2020-05-31T16:48:27Z",
          "updatedAt": "2020-05-31T16:48:27Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Adding the following just so that we remember that in case we introduce limits: If in the end the PSK's size is limited to smth strictly smaller than `Nb` (block size of underlying hash function), we could get rid of the hashing step for the PSK.",
          "createdAt": "2020-06-02T13:26:59Z",
          "updatedAt": "2020-06-02T13:26:59Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Update: this change may not be necessary. It shouldn't be hard to get HKDF-Expand and HKDF-Extract to work this way without allocating.\r\n\r\nWaiting on https://github.com/RustCrypto/KDFs/pull/34",
          "createdAt": "2020-06-07T21:14:30Z",
          "updatedAt": "2020-06-07T21:14:30Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "KDF PR got merged. This is no longer an issue.",
          "createdAt": "2020-06-17T23:39:02Z",
          "updatedAt": "2020-06-17T23:39:02Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWU2MzAxNTg0NzY=",
      "title": "Typo for Single-Shot and clarification on AEAD binding to Context.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/103",
      "state": "CLOSED",
      "author": "dvorak42",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In section 5.1, might be useful to have return KeySchedule/Context take in the AEAD, to make it clear that a Context is bound to a particular AEAD.\r\nIn section 6, Seal<MODE> calls Setup<MODE>I instead of Setup<MODE>S.\r\n\r\n",
      "createdAt": "2020-06-03T16:49:56Z",
      "updatedAt": "2020-06-18T21:32:50Z",
      "closedAt": "2020-06-18T21:32:50Z",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In section 5.1, might be useful to have return KeySchedule/Context take in the AEAD, to make it clear that a Context is bound to a particular AEAD.\r\n\r\nI think this is worth thinking about. I am not sure how to address it in the spec, yet.\r\n\r\nTo give an example of an implementation: In the work-in-progress F* implementation, all fields of the encryption_context are actually parametrized with the entire ciphersuite, see https://github.com/project-everest/hacl-star/blob/_blipp_hpke/specs/Spec.Agile.HPKE.fsti#L278. This way it is not possible to use the context with another ciphersuite.\r\n\r\nTo add to @dvorak42's comment, the context is also bound to a particular KDF (for the Export interface).\r\n\r\n**Edited to add**: Just noticed that https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#encryption-and-decryption-hpke-dem already contains \u201cthe AEAD algorithm in use\u201d\r\n\r\n> Each of the setup procedures above produces a context object that stores the required state:\r\n>\r\n> -   The AEAD algorithm in use\r\n> -   The key to be used with the AEAD algorithm\r\n> -   A base nonce value\r\n> -   A sequence number (initially 0)\r\n> -   An exporter secret (see {{hpke-export}})\r\n\r\n\u201cThe KDF algorithm in use\u201d could be added here (as second element).\r\n\r\nAnd then, as @dvorak42 suggests, it's just not explicitly mentioned in the code in the return statement of KeySchedule.",
          "createdAt": "2020-06-17T22:04:39Z",
          "updatedAt": "2020-06-17T22:19:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112. Please re-open if that's not the case!",
          "createdAt": "2020-06-18T21:32:50Z",
          "updatedAt": "2020-06-18T21:32:50Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWU2MzAyOTU5NzE=",
      "title": "Use I2OSP instead of encode_big_endian",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/104",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://tools.ietf.org/html/rfc8017.",
      "createdAt": "2020-06-03T20:15:55Z",
      "updatedAt": "2020-06-18T21:32:35Z",
      "closedAt": "2020-06-18T21:32:35Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:32:35Z",
          "updatedAt": "2020-06-18T21:32:35Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWU2MzAyOTc1ODY=",
      "title": "Clarify KEM shared secret for AuthEncap/Decap",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/105",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> - Section 4: the definitions of AuthEncap and AuthDecap contain words to the\r\n>   effect, 'the KEM shared secret key is known only to the holder of the\r\n>   private key \"skS\".' It would be more accurate to say , 'the KEM shared\r\n>   secret key was generated by the holder of the private key \"skS\"'.",
      "createdAt": "2020-06-03T20:18:05Z",
      "updatedAt": "2020-06-18T21:33:01Z",
      "closedAt": "2020-06-18T21:33:01Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:33:01Z",
          "updatedAt": "2020-06-18T21:33:01Z"
        }
      ]
    },
    {
      "number": 106,
      "id": "MDU6SXNzdWU2MzAyOTgzNjM=",
      "title": "Note that DHKEM's Unmarshal function can fail",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/106",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-03T20:19:08Z",
      "updatedAt": "2020-06-18T21:33:17Z",
      "closedAt": "2020-06-18T21:33:17Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:33:17Z",
          "updatedAt": "2020-06-18T21:33:17Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWU2MzAzMDU4NjM=",
      "title": "Nits from Riad",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/107",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> - Section 5.1.3: it would be nice to include a reference or citation for\r\n>   unknown key share attacks.\r\n>\r\n> - Section 5.2: is there a reason to put the word \"amortize\" in quotes? \r\n>\r\n> - Section 7.1.2: it might be worth mentioning here that [keyagreement] also\r\n>   includes checking that the public key is not the identity point.\r\n>\r\n> - Section 7.1.2: is there a reason to recommend either checking for a nonzero \r\n>   scalar or checking for a non-identity DH output? Checking the latter covers\r\n>   the former and also covers the check from my prior comment. Moreover, it is\r\n>   not clear to me that checking the scalar is useful for the recipient, since\r\n>   this is essentially just checking that their long-term secret is nonzero.\r\n>\r\n> - Section 8.1: the sentence \"In particular, the KDFs and DH groups...\" might\r\n>   want to clarify that this statement is true only when these primitives are\r\n>   used as specified. The concern is that HKDF is only indifferentiable under\r\n>   some restrictions on salt length (for reasons noted in Section 8.3).",
      "createdAt": "2020-06-03T20:31:19Z",
      "updatedAt": "2020-06-18T21:32:07Z",
      "closedAt": "2020-06-18T21:32:07Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:32:07Z",
          "updatedAt": "2020-06-18T21:32:07Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "MDU6SXNzdWU2MzAzMTIyODI=",
      "title": "Bind DHKEM labels to the group",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/108",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> - Section 4.1: this may be paranoia, but it would be slightly nicer to include\r\n>   the DH group name in the label arguments of LabeledExtract and LabeledExpand\r\n>   to ensure that invocations from different DHKEM instantiations are orthogonal.",
      "createdAt": "2020-06-03T20:42:17Z",
      "updatedAt": "2020-06-18T21:31:57Z",
      "closedAt": "2020-06-18T21:31:57Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:31:57Z",
          "updatedAt": "2020-06-18T21:31:57Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "MDU6SXNzdWU2MzAzNTM4MTA=",
      "title": "Add acknowledgements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/109",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Benjamin Lipp, David Benjamin, Benjamin Beurdouche, Riad Wahby, Kevin Jacobs, Michael Rosenberg, Michael Scott, Raphael Robert, and probably more!",
      "createdAt": "2020-06-03T21:45:15Z",
      "updatedAt": "2020-06-18T21:32:26Z",
      "closedAt": "2020-06-18T21:32:26Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:32:26Z",
          "updatedAt": "2020-06-18T21:32:26Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWU2MzY0MzI4NDY=",
      "title": "Clarify decryption failure cases",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/110",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The only way an endpoint notices that decryption fails is if AEAD decryption fails. This doesn't seem to be a problem, though we should probably note it for clarity's sake.",
      "createdAt": "2020-06-10T17:42:34Z",
      "updatedAt": "2020-06-18T21:33:09Z",
      "closedAt": "2020-06-18T21:33:09Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:33:09Z",
          "updatedAt": "2020-06-18T21:33:09Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "MDU6SXNzdWU2Mzk1ODk4Mzg=",
      "title": "Unclear if last sequence number can be used to encrypt/decrypt messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/111",
      "state": "CLOSED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft currently says the following about the sequence number:\r\n\r\n* `Implementations [\u2026] MUST return an error if the sequence number overflows`\r\n* `If a Seal or Open operation would cause the seq field to overflow, then the implementation MUST return an error.`\r\n\r\nHowever, it is not clear to me how exactly the implementation should behave when the last sequence number is reached:\r\n\r\n* `Context.Seal` will first create the ciphertext, which is ok. Next, `self.IncrementSeq` will return an Error. Should `Context.Seal` then fail, too? The second point above kind of suggests it. So, if it should fail, then this also means that the last sequence number effectively cannot be used. If it should not fail, then it is unclear how the next `Context.Seal` will know that it really cannot encrypt anymore.\r\n\r\n* The situation for `Context.Open` is similar.\r\n\r\nSo, maybe we should just clarify that if `Context.IncrementSeq` fails, then `Context.Seal` and `Context.Open` also fail, *without* returning `ct` or `pt`, and note that this effectively means that the last sequence number cannot be used?\r\n\r\n```\r\ndef Context.IncrementSeq():\r\n  if self.seq >= (1 << (8*Nn)) - 1:\r\n    return NonceOverflowError\r\n  self.seq += 1\r\n\r\ndef Context.Seal(aad, pt):\r\n  ct = Seal(self.key, self.ComputeNonce(self.seq), aad, pt)\r\n  self.IncrementSeq()\r\n  return ct\r\n\r\ndef Context.Open(aad, ct):\r\n  pt = Open(self.key, self.ComputeNonce(self.seq), aad, ct)\r\n  if pt == OpenError:\r\n    return OpenError\r\n  self.IncrementSeq()\r\n  return pt\r\n```",
      "createdAt": "2020-06-16T11:29:32Z",
      "updatedAt": "2020-06-18T21:31:43Z",
      "closedAt": "2020-06-18T21:31:43Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in #112. Please re-open if that's not the case!",
          "createdAt": "2020-06-18T21:31:43Z",
          "updatedAt": "2020-06-18T21:31:43Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWU2NDAwMTU2MTU=",
      "title": "Clarify KEM errors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/113",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [],
      "body": "We raise errors when AEAD functions fail due (OpenError and NonceOverflowError), but do nothing similar for KEM failures. What happens when `DH()` fails? Should we raise an explicit error? Or should we add text which says something like, \"implementations MUST raise errors when <these fallible> functions fail\"? I'd lean towards being explicit, but that may may the pseudocode messy.\r\n\r\ncc @blipp",
      "createdAt": "2020-06-16T22:35:49Z",
      "updatedAt": "2020-06-18T21:31:29Z",
      "closedAt": "2020-06-18T21:31:28Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #112.",
          "createdAt": "2020-06-18T21:31:28Z",
          "updatedAt": "2020-06-18T21:31:28Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "MDU6SXNzdWU2NDAwMTYyMjM=",
      "title": "Document use cases for different HPKE modes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/114",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From JP's review, it might be helpful if the different modes had some text describing scenarios or use cases where they make sense. @bifurcation, what do you think?\r\n\r\ncc @blipp ",
      "createdAt": "2020-06-16T22:37:28Z",
      "updatedAt": "2020-06-23T13:35:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 115,
      "id": "MDU6SXNzdWU2NDAwMTY2MjY=",
      "title": "Reference 2006/265",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/115",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "editorial"
      ],
      "body": "[The paper](https://eprint.iacr.org/2006/265.pdf) presents conditions for secure KEM/DEM constructions. We should absolutely cite it as related work.",
      "createdAt": "2020-06-16T22:38:31Z",
      "updatedAt": "2020-06-23T13:35:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 128,
      "id": "MDU6SXNzdWU2NDc1MzI4ODY=",
      "title": "DeriveKeyPair dependency in Encap is unnecessary",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/128",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "#79 added a `DeriveKeyPair` operation, which is a reasonable thing to want for protocols that need it. In doing so, it removed `GenerateKeyPair` and replaced the ephemeral DH keys in `Encap` with `DeriveKeyPair(random())`.\r\n\r\nThis seems unnecessary. It's true that having both `DeriveKeyPair` and `GenerateKeyPair` is a larger definition of KEM in HPKE, but, realistically, everyone has a `GenerateKeyPair` in their existing KEM-like APIs, while `DeriveKeyPair` is the more niche operation. After all, we've managed to use DH thus far *somehow*. :-) From the context of HPKE's use in ECH in TLS, I'm not sure `DeriveKeyPair` would be needed at all. `DeriveKeyPair(random())` is also going to result in many more hash calls than a typical `GenerateKeyPair` implementation.",
      "createdAt": "2020-06-29T17:06:08Z",
      "updatedAt": "2020-06-29T17:58:27Z",
      "closedAt": "2020-06-29T17:58:27Z",
      "comments": []
    },
    {
      "number": 136,
      "id": "MDU6SXNzdWU2NjMyNDc3NDE=",
      "title": "AES-GCM-128 => AES-128-GCM?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/136",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I think everything I've seen uses AES-128-GCM instead of AES-GCM-128. In particular, it's probably good to match RFC5116's terminology. Was there a particular reason HPKE went with AES-GCM-128?",
      "createdAt": "2020-07-21T19:16:13Z",
      "updatedAt": "2020-07-23T19:07:34Z",
      "closedAt": "2020-07-23T19:07:34Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Was there a particular reason HPKE went with AES-GCM-128?\r\n\r\nNope :-) Seems like it was just oversight. We can switch it over. ",
          "createdAt": "2020-07-21T19:18:33Z",
          "updatedAt": "2020-07-21T19:18:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed directly on master.",
          "createdAt": "2020-07-23T19:07:34Z",
          "updatedAt": "2020-07-23T19:07:34Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "MDU6SXNzdWU2NjMyNzc3MTg=",
      "title": "Replace RFCXXXX with draft version strings",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/137",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "... and then replace with the final RFC number when done!",
      "createdAt": "2020-07-21T20:10:55Z",
      "updatedAt": "2020-07-27T13:27:11Z",
      "closedAt": "2020-07-27T13:27:11Z",
      "comments": []
    },
    {
      "number": 139,
      "id": "MDU6SXNzdWU2NjgxNjM5MzY=",
      "title": "Consider renaming zz",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/139",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Every time I see \"zz\" I get confused. :-) How about \"kem_secret\", \"shared_secret\", or just \"secret\"?",
      "createdAt": "2020-07-29T21:15:57Z",
      "updatedAt": "2020-07-30T23:40:30Z",
      "closedAt": "2020-07-30T23:40:30Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems reasonable. ",
          "createdAt": "2020-07-30T12:51:28Z",
          "updatedAt": "2020-07-30T12:51:28Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "MDU6SXNzdWU2Nzk1NzcyNDM=",
      "title": "List the NIST curve orders inline",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/141",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The text (for DeriveKeyPair) is currently ambiguous. Let's just include the orders for each curve, which would be the following:\r\n\r\n- P256: 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\r\n- P384: 0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973\r\n- P521: 0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409",
      "createdAt": "2020-08-15T13:42:55Z",
      "updatedAt": "2020-08-15T13:42:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWU2Nzk1Nzc3NTk=",
      "title": "Consider removing \"Designated-Verifier Signature\" section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/142",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Stephen suggested removing this [on the list](https://mailarchive.ietf.org/arch/msg/cfrg/7zhOHPFkCyZC00xLZnsEBT3o6ZU/), because\r\n\r\n> it might muddy the definition of \"signature\" for some people and doesn't seem to add much as-is.\r\n\r\nThis is a reasonable criticism. It does seem somewhat out of place and, as written, I'm not even sure it's correct (considering KCI issues for the Auth variants). \r\n\r\n@bifurcation, what do you think? Can we axe this?",
      "createdAt": "2020-08-15T13:47:00Z",
      "updatedAt": "2020-08-24T14:00:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > it might muddy the definition of \"signature\" for some people and doesn't seem to add much as-is.\r\n> \r\n> This is a reasonable criticism. It does seem somewhat out of place and, as written, I'm not even sure it's correct (considering KCI issues for the Auth variants).\r\n\r\nIt is right that due to the KCI issue of DHKEM, this kind of \u201csignature\u201d does not guarantee that it was produced by the sender, if the recipient's static key is compromised. So maybe it is indeed a stretch to call it a signature.",
          "createdAt": "2020-08-24T13:46:02Z",
          "updatedAt": "2020-08-24T13:46:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp do you know if this proposal has been analyzed? If not, I'm going to toss up a PR removing it. ",
          "createdAt": "2020-08-24T13:49:27Z",
          "updatedAt": "2020-08-24T13:49:27Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood I did not analyze it, and I do not know of someone who did.",
          "createdAt": "2020-08-24T14:00:57Z",
          "updatedAt": "2020-08-24T14:00:57Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "MDU6SXNzdWU2Nzk1Nzc5MTE=",
      "title": "Remove superfluous space after \"HPKE-05\" in constant labels",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/143",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This was raised by Stephen [on the list](https://mailarchive.ietf.org/arch/msg/cfrg/7zhOHPFkCyZC00xLZnsEBT3o6ZU/).",
      "createdAt": "2020-08-15T13:48:07Z",
      "updatedAt": "2020-08-24T13:48:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it is a good idea to remove the space. It is inconsistent to have a space there but not between all the other labels we use. We need to take care to update Section \u201cInput Length Restrictions {#kdf-input-length}\u201d appropriately (increase limits by one).",
          "createdAt": "2020-08-24T13:48:28Z",
          "updatedAt": "2020-08-24T13:48:28Z"
        }
      ]
    },
    {
      "number": 144,
      "id": "MDU6SXNzdWU2Nzk1NzkwMDk=",
      "title": "Address Stephen's nits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/144",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From [his feedback on the list](https://mailarchive.ietf.org/arch/msg/cfrg/7zhOHPFkCyZC00xLZnsEBT3o6ZU/):\r\n\r\n1. p4: PGP and fiveG don't depend on HPKE, whereas msl and esni do. Maybe worth saying that.\r\n2. p5: I2OSP and OS2IP aren't expanded here - be no harm to do so\r\n3. p6: Open as the opposite of Seal, doesn't seem like the best choice - there are too many functions called open() in too many contexts. Unseal would be better IMO.\r\n4. p5: DeriveKeyPair was added after discussion in github (and maybe on the MLS list) but I don't recall any disussion of that on the CFRG list at all. Was there any? Adding this seems fine to me if MLS wants it and the definition is also almost fine (see above) so this is just a process nit.\r\n5. p5 & elsewhere: \"fixed-length\" is used in various places where it's not quite true - the various lengths are fixed only after you pick a ciphersuite - so people's code has to support different sizes (if they support >1 suite)\r\n\r\nMy take on each of these is:\r\n\r\n1. We can clarify this.\r\n2. These seem fairly common in folded form and are quite a mouthful when expanded, so I'm inclined to keep these as is.\r\n3. Open and seal seem fairly common, at least in APIs I'm familiar with (BoringSSL/OpenSSL, libsodium, NaCL, etc), so I'm inclined to keep this as is.\r\n4. I disagree about this being a process nit. The document is still an active RG document, so everything is subject to change. I'm not sure why discussion would be needed before or after it lands in the document?\r\n5. Similar to other stacks I'm familiar with, I assume memory would statically allocated for each of these fixed-length values (on the stack) based on the maximum size supported. The specific ciphersuite/length would then use however much of that memory is needed. So this seems fine to keep, though perhaps clarifying might help? I'm not sure what that would look like right now, but I'll give it some thought.",
      "createdAt": "2020-08-15T13:55:50Z",
      "updatedAt": "2020-08-24T13:56:40Z",
      "closedAt": null,
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1. I agree.\r\n2. Maybe a middle ground would be to specify the parameters of the two functions? `I2OSP(int, len)` and `OS2IP(str)`. At least for I2OSP this is usefull to recall the order of the parameters.\r\n3. I haven't seen Open and Seal before, but my experience with crypto libraries is limited anyway, so I abstain.\r\n4. I am not sure how the process is supposed to be. I haven't seen many detailed discussions about decisions like this one on the full CFRG list since I am subscribed, so it seems not unusual to have these discussions off-list?\r\n5. I do not have enough experience to comment.",
          "createdAt": "2020-08-24T13:56:40Z",
          "updatedAt": "2020-08-24T13:56:40Z"
        }
      ]
    },
    {
      "number": 145,
      "id": "MDU6SXNzdWU2Nzk1Nzk1MDc=",
      "title": "Add recommended column to the IANA registry table",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/145",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[Stephen writes](https://mailarchive.ietf.org/arch/msg/cfrg/7zhOHPFkCyZC00xLZnsEBT3o6ZU/):\r\n\r\n> The thing to ponder relates to the IANA considerations.\r\n> Why not add a \"recommended\" column a la TLS.  The RG can\r\n> hand over responsibility to some DEs appointed by the IESG\r\n> and call for the same setup as TLS.  (I.e. other than\r\n> the initial values recommended == yes requires IETF\r\n> standards track, otherwise spec required.) If we don't\r\n> do that then applications using HPKE will always each\r\n> need to say which suites are MUSTs, leading to IMO mostly\r\n> pointless variation and possibly worsening interop if\r\n> libraries implement disjoint sets of suites.\r\n\r\nThis seems reasonable, though I don't have a sense for how problematic the lack of a \"recommended\" column will be in the long term. @bifurcation, what do you think?",
      "createdAt": "2020-08-15T13:59:23Z",
      "updatedAt": "2020-08-15T13:59:23Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 146,
      "id": "MDU6SXNzdWU2ODAyNjE2MTA=",
      "title": "suite_id length is wrong",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/146",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "In 7.2.1, this should be 10, not 9, to match the length of the following byte array is 10:\r\n\r\n~~~\r\nsuite_id = concat(\r\n  \"HPKE\",\r\n  I2OSP(kem_id, 2),\r\n  I2OSP(kdf_id, 2),\r\n  I2OSP(aead_id, 2)\r\n)\r\n~~~",
      "createdAt": "2020-08-17T14:03:58Z",
      "updatedAt": "2020-09-23T14:47:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You are right, good catch. I guess the 9 is still from when it was `\"DEM\"` and not `\"HPKE\"`.",
          "createdAt": "2020-08-24T13:59:12Z",
          "updatedAt": "2020-08-24T13:59:12Z"
        }
      ]
    },
    {
      "number": 147,
      "id": "MDU6SXNzdWU2ODAyNjI3MDQ=",
      "title": "Clarify seedE and seedR in test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/147",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "These values are not well-defined, and they probably should be.",
      "createdAt": "2020-08-17T14:05:35Z",
      "updatedAt": "2020-09-23T14:47:15Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 152,
      "id": "MDU6SXNzdWU2OTY3ODAxODM=",
      "title": "Address cjpatton's feedback",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/152",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Abstract                                           \r\n                                                   \r\n\"for any combination of\" -> \"for several combinations of\"\r\n                                                   \r\nSection 4                                          \r\n                                                   \r\n\"random(Nsk)\" is used but \"random()\" isn't defined yet.  \r\n                                                   \r\n\"not passed as parameter\" -> \"not passed as a parameter\" \r\n                                                   \r\nSection 5                                          \r\n                                                   \r\n\"the holder of the private key corresponding to `pkR`\" -> \"the holder of `skR`\" \r\n                                                   \r\nIn various places, e.g., 'KeySchedule()' in Section 5.1, value \"\" is used as the\r\nsalt for KDF extraction. I'm wondering if implementations might misinterpret    \r\nthis. I read \"\" as 'the empty string', but the correct interpretation might be  \r\n'nil', i.e., 'None' in Python or 'NULL' in C. The HKDF spec defines the salt as \r\nfollows: 'optional salt value (a non-secret random value); if not provided, it  \r\nis set to a string of HashLen zeros.' I think the intention is to interpret \"\"  \r\nas 'nil', i.e., no salt, but the empty string is certainly a valid salt for\r\nHKDF, since the extraction function is well-defined on this input. A 0-length\r\nsalt might not be safe choice in terms of security, however.\r\n                                                   \r\nSection 5.2                                        \r\n                                                   \r\nI think the HPKE uses the term \"nonce\" incorrectly, since it's not a \"Number\r\nthat's used ONCE\". In fact, it's used every time the \"Seal()\" or \"Open()\"\r\noperation is run. What's called a \"nonce\" here is usually called the\r\n\"initialization vector\" elsewhere: in TLS 1.3 for example, the \"nonce\" is the\r\ninitialization vector XORed with a sequence number.    \r\n\r\n(Edit: from the list, consider renaming this to \"iv\")",
      "createdAt": "2020-09-09T12:40:54Z",
      "updatedAt": "2020-09-23T14:47:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding the point about `\"\"` appearing with `LabeledExtract` as a salt: this is correct, and equivalent to providing a nil salt or no salt when such an API is available.\r\n\r\n[`HKDF-Extract(salt, IKM)`](https://tools.ietf.org/html/rfc5869#section-2.2) is defined to be `HMAC-Hash(salt, IKM)`. In turn, [`HMAC-Hash(K, text)`](https://tools.ietf.org/html/rfc2104#section-2) is defined to be `H(K XOR opad, H(K' XOR ipad, text))`, where `H` is the underlying hash function and `K'` is the value of `K` **padded with zeros until it is the length of a digest**. HashLen many zeros is also (not-coincidentally) the default value of `salt` in `HKDF-Extract` if none is specified.\r\n\r\nThus, `salt = \"\"` is equivalent to `salt = nil` is equivalent to `salt = [0x0, 0x0, ..., 0x0]` HashLen many times. So at least _technically_ this is not an issue. However, I think it's still fair to ask though whether it's clearer to the reader to use `nil` instead of `\"\"`.",
          "createdAt": "2020-09-11T22:37:00Z",
          "updatedAt": "2020-09-11T22:37:00Z"
        }
      ]
    },
    {
      "number": 153,
      "id": "MDU6SXNzdWU2OTk4MzAwMDQ=",
      "title": "No official byte representation of private keys",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/153",
      "state": "OPEN",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, there is no `Serialize/Deserialize` function defined for KEM private keys. The primary reason someone might want this is if they were migrating from one HPKE library to another, and wanted to keep their long-term private keys the same. Currently, a user would have to dig into both implementations to find their internal representation and figure out how to convert between the two manually. The fact that go-hpke and rust-hpke have (I think) the same byte representation of secret keys is good, but it would be better if this were guaranteed by the spec.\r\n\r\nI propose `SerializeSk/DeserializeSk` functions (not married to those names) that do what you'd expect, with the small addition that `DeserializeSk` should reject secret keys that are equivalent to 0.\r\n\r\n**Addendum**\r\n\r\nI also think that `SerializeSk` should canonicalize secret keys. For P-curves, this would mean reducing modulo the curve order, and for X25519/X448 this would mean clamping the keys.\r\n\r\nThe reason I think we should do this is because users might want to save their secret keys using some storage mechanism of their choosing. They might have some expectations of secret key identity (e.g., as a key in a table or an item in a set), and it would be a lot more effort to scream \"equivalent keys are not identical!\" all across our docs than to just make sure that equivalent keys actually are identical.",
      "createdAt": "2020-09-11T22:50:31Z",
      "updatedAt": "2020-09-11T22:50:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 154,
      "id": "MDU6SXNzdWU3MDY2ODEyNjU=",
      "title": "Include DeriveKeyPair output in test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/154",
      "state": "OPEN",
      "author": "kjacobs-moz",
      "authorAssociation": "NONE",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Currently, there are two ways to generate a keypair for HPKE: `DeriveKeyPair` and `GenerateKeyPair`. The former is unnecessary when HPKE is used only for ECH. For libraries that choose to not implement or export `DeriveKeyPair`, it would be useful to have its output captured in the test vectors. ",
      "createdAt": "2020-09-22T20:45:44Z",
      "updatedAt": "2020-09-23T14:47:15Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 155,
      "id": "MDU6SXNzdWU3MDc0MzEwNDg=",
      "title": "Restrict low-entropy PSKs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/155",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "See https://mailarchive.ietf.org/arch/msg/cfrg/mxBzZq85ijSMNMUwyI3gA3B0U4U/.",
      "createdAt": "2020-09-23T14:45:10Z",
      "updatedAt": "2020-09-23T14:47:15Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5MDcyNTg2",
      "title": "Comments from @dwd (and one thing I found)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/1",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-18T01:17:07Z",
      "updatedAt": "2019-07-02T16:48:34Z",
      "closedAt": "2019-07-02T16:48:34Z",
      "mergedAt": "2019-07-02T16:48:34Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2OTk3NDIw",
          "commit": {
            "abbreviatedOid": "1f394fe"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-02T16:05:51Z",
          "updatedAt": "2019-07-02T16:08:26Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n- `pk(skX)`: The public key corresponding to private key `skX`\r\n```",
              "createdAt": "2019-07-02T16:05:51Z",
              "updatedAt": "2019-07-02T16:46:46Z"
            },
            {
              "originalPosition": 17,
              "body": "Why is this needed?",
              "createdAt": "2019-07-02T16:06:28Z",
              "updatedAt": "2019-07-02T16:46:46Z"
            },
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n  context = concat(ciphersuite, mode,\r\n```",
              "createdAt": "2019-07-02T16:07:53Z",
              "updatedAt": "2019-07-02T16:46:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MDE5MDI2",
          "commit": {
            "abbreviatedOid": "1f394fe"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-02T16:46:01Z",
          "updatedAt": "2019-07-02T16:46:02Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "You mean the \"empty value\" part?  I thought it was needed for #2, but on further reflection, it need not be. ",
              "createdAt": "2019-07-02T16:46:01Z",
              "updatedAt": "2019-07-02T16:46:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MDE5OTE1",
          "commit": {
            "abbreviatedOid": "7a9cf49"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-02T16:47:49Z",
          "updatedAt": "2019-07-02T16:47:49Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\ud83d\udc4d I'd remove it if not used.",
              "createdAt": "2019-07-02T16:47:49Z",
              "updatedAt": "2019-07-02T16:47:49Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "39d01357849740a03daddfc980b8b65977c18b95",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "cridland",
      "headRefOid": "7a9cf49502d6d5e69067192a17b39c6915ebaef5",
      "mergeCommit": {
        "oid": "4f950e2a3b02da24e6296962f637f9767eac8d72"
      }
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzNDUzNDgx",
      "title": "Consolidate the key schedule",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/2",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Prior versions had a lot of repetitive logic in the `SetupX` functions.  This PR consolidates that logic into a single `KeySchedule` method with some optional inputs to reflect variation among the modes.  As a side effect, it's now trivial to add a mode where the initiator is authenticated to hold *both* a PSK and a private key.\r\n\r\nNB: Based on top of #1, so this will read better once that is landed.",
      "createdAt": "2019-07-01T18:39:33Z",
      "updatedAt": "2019-07-04T01:04:45Z",
      "closedAt": "2019-07-04T01:04:45Z",
      "mergedAt": "2019-07-04T01:04:44Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzgzMzA5",
          "commit": {
            "abbreviatedOid": "42bfa9f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-07-04T00:15:48Z",
          "updatedAt": "2019-07-04T00:27:54Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nmechanism for translating the protocol inputs into an\r\n```",
              "createdAt": "2019-07-04T00:15:48Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nencryption context.  The key schedule inputs are as follows:\r\n```",
              "createdAt": "2019-07-04T00:16:06Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 43,
              "body": "Can one supply a `pskID` but not a `psk`?",
              "createdAt": "2019-07-04T00:19:09Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nIf any of the optional values is absent (e.g., set to `None`\r\n```",
              "createdAt": "2019-07-04T00:19:09Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 51,
              "body": "This seems to suggest that the key and nonce are outputs, but they're just put in the context. Perhaps we replace \"produced\" with \"computed\"?",
              "createdAt": "2019-07-04T00:19:09Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\nin a Python implementation), then it is treated as\r\n```",
              "createdAt": "2019-07-04T00:19:09Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 65,
              "body": "nit: can we rename `salt` to `psk`? I had to go down to see its invocation to learn that salt is really the psk here.",
              "createdAt": "2019-07-04T00:19:48Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 61,
              "body": "nit: instead of `default`, perhaps `empty`? And perhaps replace `salt` with `psk`?",
              "createdAt": "2019-07-04T00:21:07Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 84,
              "body": "We don't include `len(pkIm)`?",
              "createdAt": "2019-07-04T00:21:54Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 84,
              "body": "Question: if `Nenc` is fixed for the cipher suite, do we need to encode the length here? (This doesn't seem like it'd match the TLS struct below, since `opaque enc[Nenc];` is a fixed-length array. ",
              "createdAt": "2019-07-04T00:25:16Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 80,
              "body": "nit: either this should be `salt`, or the `salt` parameter to `KeySchedule` should be `psk`, right?",
              "createdAt": "2019-07-04T00:25:54Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 65,
              "body": "(I recognize we use `salt` since it's more natural for `Extract`, though `psk` I think being clear about the nature of the value is probably better here.",
              "createdAt": "2019-07-04T00:26:43Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 31,
              "body": "I might rename this to Encryption Context, and then the function `KeySchedule` to `EncryptionContext`, respectively. That seems to better match what's happening here. ",
              "createdAt": "2019-07-04T00:27:51Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzg4MTQw",
          "commit": {
            "abbreviatedOid": "42bfa9f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T00:48:04Z",
          "updatedAt": "2019-07-04T00:48:04Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Actually, this whole section needs rewriting after the update.",
              "createdAt": "2019-07-04T00:48:04Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzg4Nzgy",
          "commit": {
            "abbreviatedOid": "42bfa9f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T00:52:15Z",
          "updatedAt": "2019-07-04T00:52:15Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "`pkIm` has fixed length `Npk`.",
              "createdAt": "2019-07-04T00:52:15Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzg4ODQx",
          "commit": {
            "abbreviatedOid": "42bfa9f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T00:52:40Z",
          "updatedAt": "2019-07-04T00:52:40Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Don't like that; \"empty\" implies there's nothing there, whereas here clearly there is.",
              "createdAt": "2019-07-04T00:52:40Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzg4OTMz",
          "commit": {
            "abbreviatedOid": "42bfa9f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T00:53:17Z",
          "updatedAt": "2019-07-04T00:53:17Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Good point.  Removed this length, and the length for `pkRm`, which is unnecessary for similar reasons.",
              "createdAt": "2019-07-04T00:53:17Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4f950e2a3b02da24e6296962f637f9767eac8d72",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "omni",
      "headRefOid": "4e53ac17d073a7f31f05760b912a05217c3f9401",
      "mergeCommit": {
        "oid": "8a33ffe1dd68b57e8e56503714698d1faa625098"
      }
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzNDYyMDYz",
      "title": "Use individual algorithm identifiers as opposed to a suite ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/3",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This has been the trend, e.g., with TLS 1.3, and there's no inherent need to conjoin these choices here, except for \"level matching\".\r\n\r\nNB: Based on top of #1 and #2, so this will read better once they're landed",
      "createdAt": "2019-07-01T19:08:10Z",
      "updatedAt": "2019-07-04T01:31:27Z",
      "closedAt": "2019-07-04T01:31:27Z",
      "mergedAt": "2019-07-04T01:31:27Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzg1Njkx",
          "commit": {
            "abbreviatedOid": "0ee0c5b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-04T00:31:49Z",
          "updatedAt": "2019-07-04T00:31:49Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8a33ffe1dd68b57e8e56503714698d1faa625098",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "no-suite",
      "headRefOid": "ab3d8e35e9ca772381fc69a09cac0cf730a0701d",
      "mergeCommit": {
        "oid": "01dcb8c9aa17059d73c84b1a3ffbbb38a8b163c7"
      }
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEzMzc5ODE1",
      "title": "Apply updates from the list",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/4",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@bifurcation please have a look!\r\n\r\ncc @FredericJacobs, too.",
      "createdAt": "2019-09-02T23:23:49Z",
      "updatedAt": "2019-09-15T17:04:12Z",
      "closedAt": "2019-09-06T20:07:56Z",
      "mergedAt": "2019-09-06T20:07:56Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgzNTMyMTkx",
          "commit": {
            "abbreviatedOid": "905e4c7"
          },
          "author": "FredericJacobs",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-04T10:53:11Z",
          "updatedAt": "2019-09-04T10:53:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0NDExMjU5",
          "commit": {
            "abbreviatedOid": "905e4c7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Minor comments, no need to re-review.",
          "createdAt": "2019-09-05T17:09:32Z",
          "updatedAt": "2019-09-05T17:18:59Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "It seems like this could be made fixed-length, of length Nh:\r\n\r\n```\r\nopaque info_hash[Nh];\r\n```\r\n\r\nAnd likewise, drop the `len(info_hash)` above.",
              "createdAt": "2019-09-05T17:09:32Z",
              "updatedAt": "2019-09-06T20:04:31Z"
            },
            {
              "originalPosition": 79,
              "body": "Nit: s/which/that/",
              "createdAt": "2019-09-05T17:09:59Z",
              "updatedAt": "2019-09-06T20:04:31Z"
            },
            {
              "originalPosition": 79,
              "body": "It might be good to specify what they need to encode, namely:\r\n\r\n* The encapsulated value `enc`\r\n* Ciphertext value(s), in order if multiple\r\n* Any info values that are not implicit",
              "createdAt": "2019-09-05T17:11:10Z",
              "updatedAt": "2019-09-06T20:04:31Z"
            },
            {
              "originalPosition": 50,
              "body": "Also, we now have only one variable-length field in the context, `pskID`.  Maybe we should hash that as well?  Maybe that's a follow-on.",
              "createdAt": "2019-09-05T17:18:40Z",
              "updatedAt": "2019-09-06T20:04:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0NDQyNTkw",
          "commit": {
            "abbreviatedOid": "905e4c7"
          },
          "author": "FredericJacobs",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-05T18:03:38Z",
          "updatedAt": "2019-09-05T18:03:38Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "That's probably a good idea to get rid of variable-size fields.",
              "createdAt": "2019-09-05T18:03:38Z",
              "updatedAt": "2019-09-06T20:04:31Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "01dcb8c9aa17059d73c84b1a3ffbbb38a8b163c7",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/edits",
      "headRefOid": "b000857533b34b2befa3c6f7afa4e2033e6e89b4",
      "mergeCommit": {
        "oid": "15f9a03034d0ff33c87b66bedcc09a1d68d4b582"
      }
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE1NzA5NDg0",
      "title": "Add single-shot APIs.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/5",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Many applications may not need to use an encryption context for more than one message.\r\nThe current separation therefore adds complexity to clients which do not wrap\r\nthe Setup+Seal pattern in a single function. This change adds such a helper wrapper.",
      "createdAt": "2019-09-09T20:47:38Z",
      "updatedAt": "2019-09-14T13:57:27Z",
      "closedAt": "2019-09-14T13:57:27Z",
      "mergedAt": "2019-09-14T13:57:27Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1ODAxOTcx",
          "commit": {
            "abbreviatedOid": "87b3d39"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-09-09T21:43:45Z",
          "updatedAt": "2019-09-09T22:34:34Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "You're going to need to fence these with `~~~` and make the lines shorter, or else they're not going to render well.",
              "createdAt": "2019-09-09T21:43:45Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 53,
              "body": "The `HPKE` at the front of these seems unnecessary, given that's what the whole document is about.",
              "createdAt": "2019-09-09T21:44:40Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 53,
              "body": "The order of parameters seems unaesthetic to me.  My preference would be to go in the order you're going to use them: pkR, info, aad, pt.\r\n\r\nSo for example `SealBase(pkR, info, aad, pt) = ContextSeal(SetupBaseI(pkR, info), aad, pt)",
              "createdAt": "2019-09-09T21:47:15Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 48,
              "body": "I would still like this better if we just left it in a form that someone could fill in in the obvious way:\r\n\r\n```\r\ndef SealMODE(pkR, info, aad, pt, ...):\r\n  enc, ctx = SetupIMODE(pkR, info, ...)\r\n  ct = ctx.sesal(aad, pt)\r\n  return enc, ct\r\n```\r\n\r\nYou can actually [implement things exactly this way](https://gist.github.com/bifurcation/4bb8a0444d5abe41fbe8a816a282b0fb) in C++: \r\n\r\n```\r\ntemplate<Mode M, typename... Args>\r\ntuple<EncapsulatedKey, EncryptionContext>\r\nsetupI(const PublicKey& pkR, const Bytes& info, const Args&... args);\r\n\r\n// ... instantiations ...\r\n\r\ntemplate<Mode M, typename... Args>\r\ntuple<EncapsulatedKey, Bytes>\r\nseal(const PublicKey& pkR,\r\n     const Bytes& info,\r\n     const Bytes& aad,\r\n     const Bytes& pt,\r\n     const Args&... args)\r\n{\r\n  auto [enc, ctx] = setupI<M>(pkR, info, args...);\r\n  auto ct = ctx.seal(aad, pt);\r\n  return { enc, ct };\r\n}\r\n```",
              "createdAt": "2019-09-09T22:34:02Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1ODM1MjQ3",
          "commit": {
            "abbreviatedOid": "87b3d39"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-09T23:23:38Z",
          "updatedAt": "2019-09-09T23:23:38Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": ":+1: agreed! With the template change, this should be fixed.",
              "createdAt": "2019-09-09T23:23:38Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1ODM1NDEw",
          "commit": {
            "abbreviatedOid": "87b3d39"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-09T23:24:13Z",
          "updatedAt": "2019-09-09T23:24:13Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Good idea! I refactored it a bit based on this suggestion. Please have a look.",
              "createdAt": "2019-09-09T23:24:13Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg3MTUwNjkx",
          "commit": {
            "abbreviatedOid": "31b2ef9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-12T01:17:35Z",
          "updatedAt": "2019-09-12T01:20:01Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Nice, I like the angle brackets",
              "createdAt": "2019-09-12T01:17:35Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 40,
              "body": "WLOG seems unnecessary.  I would just eliminate this sentence and end the prior sentence with a colon.",
              "createdAt": "2019-09-12T01:18:10Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 54,
              "body": "Maybe `The optional parameters indicated by \"...\"`",
              "createdAt": "2019-09-12T01:18:56Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 58,
              "body": "Don't you mean `SealAuthPSK`?",
              "createdAt": "2019-09-12T01:19:16Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 58,
              "body": "s/Using such a template/Thus/\r\ns/might be/would be/",
              "createdAt": "2019-09-12T01:19:56Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg3MTU5MTEz",
          "commit": {
            "abbreviatedOid": "31b2ef9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-12T01:58:48Z",
          "updatedAt": "2019-09-12T01:58:49Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Works for me!",
              "createdAt": "2019-09-12T01:58:49Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg3MTU5MjIy",
          "commit": {
            "abbreviatedOid": "31b2ef9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-12T01:59:19Z",
          "updatedAt": "2019-09-12T01:59:19Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "> Don't you mean SealAuthPSK?\r\n \r\nOops, yeah. Will fix.",
              "createdAt": "2019-09-12T01:59:19Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg4MTgzODQw",
          "commit": {
            "abbreviatedOid": "567f63b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-13T18:33:32Z",
          "updatedAt": "2019-09-13T18:33:32Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "We should make sure that the templates actually expand here.  Based on the AuthPSK example above, it looks like there are at least two issues:\r\n\r\n* `SetupR<MODE>` vs. `Setup<MODE>R`\r\n* Parameter order (standard parameters first)",
              "createdAt": "2019-09-13T18:33:32Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg4MjYzMTk4",
          "commit": {
            "abbreviatedOid": "6cd4833"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-13T21:37:43Z",
          "updatedAt": "2019-09-13T21:37:43Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Great catch! Should be fixed now. ",
              "createdAt": "2019-09-13T21:37:43Z",
              "updatedAt": "2019-09-13T21:37:43Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "15f9a03034d0ff33c87b66bedcc09a1d68d4b582",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/single-shot",
      "headRefOid": "6cd4833fafb0b88760673c3c2d2c8540f5bf4113",
      "mergeCommit": {
        "oid": "71f398052e3c67811096b626350d676a7c5a7d15"
      }
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE3NjU1MjMy",
      "title": "Editorial fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/6",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also, apply a couple editorial fixes.\r\n\r\ncc @bifurcation ",
      "createdAt": "2019-09-15T17:15:43Z",
      "updatedAt": "2019-09-18T22:20:20Z",
      "closedAt": "2019-09-18T22:20:19Z",
      "mergedAt": "2019-09-18T22:20:19Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "71f398052e3c67811096b626350d676a7c5a7d15",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/edits",
      "headRefOid": "716a96603cdfb04da950c3cb1073b4e6a96a860f",
      "mergeCommit": {
        "oid": "4df6d6a5b1b3068add9b6f650fb47dd963d33189"
      }
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzMzQ0MDUy",
      "title": "Clarify pkI/pkIm usage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/7",
      "state": "CLOSED",
      "author": "dwd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-01T15:43:57Z",
      "updatedAt": "2019-11-04T17:50:37Z",
      "closedAt": "2019-11-04T17:02:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is incorporated by the current draft, so we can close it. @dwd please re-open if you disagree!",
          "createdAt": "2019-11-04T17:02:40Z",
          "updatedAt": "2019-11-04T17:02:53Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe the issue is not yet resolved; so either this pull-request should be re-opened or a new one created:\r\n\r\nIn the current draft (looking at branch master):\r\n```\r\ndef KeySchedule(mode, pkRm, zz, enc, info, psk, pskID, pkIm):\r\n  VerifyMode(mode, psk, pskID, pkI)\r\n\r\n  pkRm = Marshal(pkR)\r\n```\r\n- `pkRm` is given as parameter to `KeySchedule` but is calculated from `pkR` inside (suggestion: remove the line calculating it)\r\n- `pkI` is passed to `VerifyMode`, should be `pkIm`.\r\n\r\nThe explanations of `pkIm` and `pkRm` suggested by @dwd could also be interesting, because at the moment they are only defined implicitly.",
          "createdAt": "2019-11-04T17:50:37Z",
          "updatedAt": "2019-11-04T17:50:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1MzEzNTU5",
          "commit": {
            "abbreviatedOid": "d8e0c50"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-22T15:44:32Z",
          "updatedAt": "2019-10-22T15:45:12Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Should we pass in `pkRm` instead?",
              "createdAt": "2019-10-22T15:44:33Z",
              "updatedAt": "2019-10-22T15:45:12Z"
            },
            {
              "originalPosition": 4,
              "body": "This is not currently an input, and if it were, then we should not send `pkR`.",
              "createdAt": "2019-10-22T15:44:59Z",
              "updatedAt": "2019-10-22T15:45:12Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4df6d6a5b1b3068add9b6f650fb47dd963d33189",
      "headRepository": "dwd/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "d8e0c5076432bf34d50d8ee90b774c30bf2a00c4",
      "mergeCommit": null
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxMDcwNjQx",
      "title": "Add missing mode parameters",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/8",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In Sections 6.3, 6.4, and 6.5 is seems like KeySchedule's mode parameter is missing.",
      "createdAt": "2019-10-22T15:53:26Z",
      "updatedAt": "2019-10-30T22:46:07Z",
      "closedAt": "2019-10-30T22:46:07Z",
      "mergedAt": "2019-10-30T22:46:07Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTU5Nzkx",
          "commit": {
            "abbreviatedOid": "48560c7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T22:29:35Z",
          "updatedAt": "2019-10-30T22:29:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTY1NDkw",
          "commit": {
            "abbreviatedOid": "48560c7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T22:45:41Z",
          "updatedAt": "2019-10-30T22:45:41Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4df6d6a5b1b3068add9b6f650fb47dd963d33189",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_modes",
      "headRefOid": "48560c7eca9002ad7d394e4889939857e6d5eafe",
      "mergeCommit": {
        "oid": "6c1357e79f70c4965cdd0538bdaf5b6b105b3864"
      }
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxMzQ2NDY3",
      "title": "Add test vectors and remove lingering TODOs.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/9",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The script I used for formatting the JSON vectors is here: https://gist.github.com/chris-wood/e4309b89491ea9483062eb95c4ca5dd7",
      "createdAt": "2019-10-23T05:27:53Z",
      "updatedAt": "2019-10-23T23:13:58Z",
      "closedAt": "2019-10-23T23:13:57Z",
      "mergedAt": "2019-10-23T23:13:57Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1ODkzOTkw",
          "commit": {
            "abbreviatedOid": "c326749"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T13:34:58Z",
          "updatedAt": "2019-10-23T14:17:43Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "That URL doesn't actually exist :)\r\n\r\nIf you're going to add such a link, please add the file in the same PR.  And even then, the URL should be something like `https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/vectors.json`.\r\n\r\nNit: I would prefer `test-vectors.json`",
              "createdAt": "2019-10-23T13:34:58Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            },
            {
              "originalPosition": 23,
              "body": "Might be clearer if we had some hierarchy here: \r\n\r\n```\r\n## DHKEM(P-256), HKDF-SHA256, AES-GCM-128\r\n### Base\r\n### PSK\r\n### Auth\r\n### AuthPSK\r\n## DHKEM(Curve25519), HKDF-SHA256, ChaCha20Poly1305\r\n### [[ As above ]]\r\n## DHKEM(P-521), HKDF-SHA256, AES-GCM-256\r\n### [[ As above ]]\r\n```\r\n\r\nNote also: Suggest doing GCM with P-256 and ChaCHa with X25519, so that we get a fully non-NIST suite (except SHA).\r\n",
              "createdAt": "2019-10-23T13:36:49Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            },
            {
              "originalPosition": 33,
              "body": "I have a slight preference for just putting JSON in here.  Is there a particular reason to prefer this format?  Maybe the wrapping is easier?  For wrapping JSON, I would propose just pretending it as JS, e.g.,\r\n\r\n```\r\n{\r\n  \"zz: \"4a75c8fdba6bc5ae73a014071085931b814266dab50cf54cfacef1275294b9007ad5\" +\r\n       \"c9fdec1128c62bdbfa41eb604ff9488cda8fc3ef9c99015a7b61e730347e\"\r\n}\r\n```\r\n\r\nIf you end up writing a tool to do JSON wrapping, we should make sure to put that somewhere it can be reused.",
              "createdAt": "2019-10-23T13:40:38Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            },
            {
              "originalPosition": 61,
              "body": "What we're really testing here is the nonce updating logic.  So:\r\n* Doing a different pattern might better exercise the relevant code, e.g., seq=0,1,2,4,...\r\n* You should output the nonce here",
              "createdAt": "2019-10-23T13:47:00Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjE1MDky",
          "commit": {
            "abbreviatedOid": "c326749"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T21:54:45Z",
          "updatedAt": "2019-10-23T21:54:45Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "That works for me. I'll add the file to this PR.",
              "createdAt": "2019-10-23T21:54:45Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjE1MjU0",
          "commit": {
            "abbreviatedOid": "c326749"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T21:55:05Z",
          "updatedAt": "2019-10-23T21:55:06Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I'll shuffle things around to do that, yeah.",
              "createdAt": "2019-10-23T21:55:05Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjE3MjQ2",
          "commit": {
            "abbreviatedOid": "c326749"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T21:59:45Z",
          "updatedAt": "2019-10-23T21:59:45Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Mainly, the formatting seemed cleaner and the additional pointer to the JSON format could help those which want to ingest them with minimal effort. (In contrast, if we did the quirky JSON wrapping in the document, without a JSON link, then folks would have to reconstruct it themselves.)",
              "createdAt": "2019-10-23T21:59:45Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjMxMDE0",
          "commit": {
            "abbreviatedOid": "c326749"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T22:36:06Z",
          "updatedAt": "2019-10-23T22:36:06Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Done!",
              "createdAt": "2019-10-23T22:36:06Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjQzNTAy",
          "commit": {
            "abbreviatedOid": "99453d6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-23T23:13:50Z",
          "updatedAt": "2019-10-23T23:13:50Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4df6d6a5b1b3068add9b6f650fb47dd963d33189",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/test-vectors",
      "headRefOid": "99453d674292253633ddffdb2749bcade0a177ee",
      "mergeCommit": {
        "oid": "62cb35ee763163a0aca16590bc6c002d6e3b4b03"
      }
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0MTQzMDQw",
      "title": "Fix parameters in Single-Shot APIs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/11",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`OpenAuthPSK` was missing parameters, and the call to `SetupAuthPSKR` used `skI` instead of `pkI`.",
      "createdAt": "2019-10-30T10:15:22Z",
      "updatedAt": "2019-10-30T22:44:25Z",
      "closedAt": "2019-10-30T22:44:25Z",
      "mergedAt": "2019-10-30T22:44:25Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTU5NjMw",
          "commit": {
            "abbreviatedOid": "c113b97"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T22:29:06Z",
          "updatedAt": "2019-10-30T22:29:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTY0OTQ4",
          "commit": {
            "abbreviatedOid": "c113b97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T22:44:19Z",
          "updatedAt": "2019-10-30T22:44:19Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "62cb35ee763163a0aca16590bc6c002d6e3b4b03",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_singleshot",
      "headRefOid": "c113b97c44de4225de5c6074a7f493f195cfb730",
      "mergeCommit": {
        "oid": "e866ebafed825b23170a82a449b7e552fe258536"
      }
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MzU2NjY4",
      "title": "Fix test vectors. Remove some options to cut down on text.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/13",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-04T16:06:39Z",
      "updatedAt": "2019-11-04T16:41:33Z",
      "closedAt": "2019-11-04T16:41:33Z",
      "mergedAt": "2019-11-04T16:41:33Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjAyNzUz",
          "commit": {
            "abbreviatedOid": "2220a95"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T16:41:28Z",
          "updatedAt": "2019-11-04T16:41:28Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "6c1357e79f70c4965cdd0538bdaf5b6b105b3864",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/vectors-take-2",
      "headRefOid": "2220a95748d47ed084c9543d323c427aef01f98a",
      "mergeCommit": {
        "oid": "c5d76bf2fae5656eaf89833b4e6149e04c31d790"
      }
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MzcxODg3",
      "title": "Security Considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/14",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-04T16:38:12Z",
      "updatedAt": "2019-11-04T17:22:19Z",
      "closedAt": "2019-11-04T17:22:19Z",
      "mergedAt": "2019-11-04T17:22:19Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjA2NTI5",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T16:46:43Z",
          "updatedAt": "2019-11-04T16:46:44Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "I wonder if this should be replaced with a more general \"use cases\" section in the document?",
              "createdAt": "2019-11-04T16:46:44Z",
              "updatedAt": "2019-11-04T17:20:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjA2Nzg4",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T16:47:05Z",
          "updatedAt": "2019-11-04T16:47:05Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "```suggestion\r\nThis scheme is re-uses the authentication scheme of the underlying\r\n```",
              "createdAt": "2019-11-04T16:47:05Z",
              "updatedAt": "2019-11-04T17:20:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjA2OTA0",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T16:47:14Z",
          "updatedAt": "2019-11-04T16:47:15Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "```suggestion\r\nAEAD algorithm, while using the KEM to establish a one-time authentication\r\n```",
              "createdAt": "2019-11-04T16:47:15Z",
              "updatedAt": "2019-11-04T17:20:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjA3MjM5",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T16:47:42Z",
          "updatedAt": "2019-11-04T16:47:43Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "I'd drop the last sentence.",
              "createdAt": "2019-11-04T16:47:42Z",
              "updatedAt": "2019-11-04T17:20:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjA3NDA1",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T16:47:55Z",
          "updatedAt": "2019-11-04T16:47:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjI4Mjcw",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T17:19:22Z",
          "updatedAt": "2019-11-04T17:19:22Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "No, I think this is correct as-is -- e.g., with AES-GCM, we're not really using AES, we're using GMAC.",
              "createdAt": "2019-11-04T17:19:22Z",
              "updatedAt": "2019-11-04T17:20:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjI4NDIw",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T17:19:35Z",
          "updatedAt": "2019-11-04T17:19:35Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "Maybe, but I'm inclined to just do this for now.",
              "createdAt": "2019-11-04T17:19:35Z",
              "updatedAt": "2019-11-04T17:20:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjI5NDA1",
          "commit": {
            "abbreviatedOid": "0fa0658"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T17:21:15Z",
          "updatedAt": "2019-11-04T17:21:16Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "I get that, but the suggestion doesn't change that fact? It's purely editorial.",
              "createdAt": "2019-11-04T17:21:16Z",
              "updatedAt": "2019-11-04T17:21:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjI5NTM4",
          "commit": {
            "abbreviatedOid": "0fa0658"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T17:21:25Z",
          "updatedAt": "2019-11-04T17:21:26Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "Yep, just food for thought in the future.",
              "createdAt": "2019-11-04T17:21:25Z",
              "updatedAt": "2019-11-04T17:21:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjMwMDIy",
          "commit": {
            "abbreviatedOid": "0fa0658"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T17:22:13Z",
          "updatedAt": "2019-11-04T17:22:13Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "6c1357e79f70c4965cdd0538bdaf5b6b105b3864",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "security-considerations",
      "headRefOid": "0fa0658f0b81e718d207472c44c20dae0d06cc06",
      "mergeCommit": {
        "oid": "6d0a4b16b085d967d7c3ecb2d6bb8b0a4aef8057"
      }
    },
    {
      "number": 15,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2Mzc0OTQ0",
      "title": "Fix broken SECG link found by @blipp",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/15",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #10 ",
      "createdAt": "2019-11-04T16:44:45Z",
      "updatedAt": "2019-11-04T16:45:14Z",
      "closedAt": "2019-11-04T16:45:14Z",
      "mergedAt": "2019-11-04T16:45:14Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "c5d76bf2fae5656eaf89833b4e6149e04c31d790",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "ref-fix",
      "headRefOid": "26336b03cc61a6f898c502be39033866f20fb364",
      "mergeCommit": {
        "oid": "e65f76e92a7f5de2a081ade0f0a5f462b34c9a97"
      }
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2Mzc5ODU4",
      "title": "IANA Considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/17",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-04T16:55:27Z",
      "updatedAt": "2019-11-04T16:59:57Z",
      "closedAt": "2019-11-04T16:59:57Z",
      "mergedAt": "2019-11-04T16:59:57Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjE1OTMx",
          "commit": {
            "abbreviatedOid": "7e60a62"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T16:59:52Z",
          "updatedAt": "2019-11-04T16:59:52Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "e65f76e92a7f5de2a081ade0f0a5f462b34c9a97",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "iana",
      "headRefOid": "7e60a629b852c4de298e8b590275250cb2e5fae8",
      "mergeCommit": {
        "oid": "813fa48de8e15d472e3e418d3b50040d9848ec2f"
      }
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MzgzMDE2",
      "title": "Remove references to the encryption context.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/18",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-04T17:02:18Z",
      "updatedAt": "2019-11-04T17:30:04Z",
      "closedAt": "2019-11-04T17:30:04Z",
      "mergedAt": "2019-11-04T17:30:04Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjM0OTAx",
          "commit": {
            "abbreviatedOid": "edda2fa"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T17:29:58Z",
          "updatedAt": "2019-11-04T17:29:58Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "813fa48de8e15d472e3e418d3b50040d9848ec2f",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/no-more-encryption-context",
      "headRefOid": "edda2fabdec311da45c4746e1d81d41543021163",
      "mergeCommit": {
        "oid": "f7173b56308a8f9244acdf54d9bd5e1cea9cda62"
      }
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ2NDAxMDky",
      "title": "Mattson comments",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/23",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-27T19:46:50Z",
      "updatedAt": "2020-01-23T17:16:35Z",
      "closedAt": "2020-01-23T17:16:35Z",
      "mergedAt": "2020-01-23T17:16:35Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0OTY4NTM2",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Typos.\r\n\r\nI tend to agree with others about reducing the number of primitives.",
          "createdAt": "2019-12-01T22:35:55Z",
          "updatedAt": "2019-12-01T22:37:06Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "```suggestion\r\n  Context.Open function in the same order they were generated by Context.Seal\r\n```",
              "createdAt": "2019-12-01T22:35:55Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            },
            {
              "originalPosition": 123,
              "body": "What is an \"ompon\"?",
              "createdAt": "2019-12-01T22:36:09Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            },
            {
              "originalPosition": 121,
              "body": "```suggestion\r\n## External Requirements / Non-Goals\r\n```",
              "createdAt": "2019-12-01T22:36:21Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0OTc4NTYy",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "knarz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-02T00:51:13Z",
          "updatedAt": "2019-12-02T00:51:13Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "s/usign/using/",
              "createdAt": "2019-12-02T00:51:13Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI2NDQ5MDkw",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-03T21:08:12Z",
          "updatedAt": "2019-12-03T21:10:15Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nencrypted using that key.  This type of public key encryption has many\r\n```",
              "createdAt": "2019-12-03T21:08:13Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            },
            {
              "originalPosition": 138,
              "body": "The ciphertext also leaks if the public key is compromised before the ciphertext is created, so perhaps:\r\n\r\n```\r\n* Forward secrecy - HPKE ciphertexts are not forward-secure.  A given ciphertext\r\n   can be decrypted if the recipient's public encryption key is compromised.\r\n```",
              "createdAt": "2019-12-03T21:10:11Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MzkzOTE0",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T15:44:13Z",
          "updatedAt": "2020-01-20T15:44:14Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "In `mode_auth_psk`, the recipient's public key _and_ the psk need to be compromised. Suggestion:\r\n\r\n```\r\n* Forward secrecy - HPKE ciphertexts are not forward-secure. In mode_base\r\n  and mode_auth, a given ciphertext can be decrypted if the recipient's public\r\n  encryption key is compromised. In mode_psk and mode_auth_psk, a given\r\n  ciphertext can be decrypted if the recipient's public encryption key and the\r\n  psk are compromised.\r\n```",
              "createdAt": "2020-01-20T15:44:14Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NDE5MTM0",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T16:24:00Z",
          "updatedAt": "2020-01-20T16:24:00Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Good suggestion!",
              "createdAt": "2020-01-20T16:24:00Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NTU4NjU4",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T22:36:55Z",
          "updatedAt": "2020-01-20T22:36:56Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Note that this confuses post-compromise security and forward secrecy.  See the recent discussion on the lake list on this point.  In short, a PSK mode could have FS, but cannot have PCS.",
              "createdAt": "2020-01-20T22:36:56Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NTYxNzgw",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T22:49:09Z",
          "updatedAt": "2020-01-20T22:49:09Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Hmm, I don't think this is true. (I agree with the claim about achieving FS by hash-racheting the PSK.). @blipp's text simply says that if the private key material is compromised, bad things happen. It doesn't rule out FS should that keying material be updated. I think the text is fine as is.",
              "createdAt": "2020-01-20T22:49:09Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1OTQ2NDc1",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T15:04:35Z",
          "updatedAt": "2020-01-21T15:04:36Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "I am not on the lake list, so I don't know what was discussed there (just mentioning such that you can read the following with a grain of salt).\r\n\r\nIn `mode_psk` and `mode_auth_psk`, it's right that if _only one_ of (psk, skR) gets compromised after encrypting the plaintext, the plaintext stays secret. That's some weird kind of forward secrecy assuming that skR and psk are stored sufficiently separated (weird because new ciphertexts are still created with the same key material, there is no key update, no transition to a new epoch, etc). I have a proof for this property within my analysis. I think it's a good idea to mention this in the security considerations section, but maybe it's already implicit with my previous text suggestion.\r\n\r\nA protocol building upon HPKE could try to add better properties, but I am not sure if this would be out of scope of this draft?",
              "createdAt": "2020-01-21T15:04:36Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MDM1MTE3",
          "commit": {
            "abbreviatedOid": "201c2af"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-23T02:56:47Z",
          "updatedAt": "2020-01-23T02:56:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDY2NjQ2",
          "commit": {
            "abbreviatedOid": "201c2af"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-23T17:10:38Z",
          "updatedAt": "2020-01-23T17:11:13Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "Nit: \"PSK\" (caps)",
              "createdAt": "2020-01-23T17:10:38Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDcwMjI4",
          "commit": {
            "abbreviatedOid": "201c2af"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-23T17:16:04Z",
          "updatedAt": "2020-01-23T17:16:05Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "```suggestion\r\n  PSK are compromised.\r\n```",
              "createdAt": "2020-01-23T17:16:04Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0788c5536297926ccc17009cfd24eb9adb9a3bd0",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "mattson",
      "headRefOid": "08deb84f57fe2673f4213d4a5822dc46cf5ecc5c",
      "mergeCommit": {
        "oid": "d41dbb654900f47bf09b022d3774c21262c46a17"
      }
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ3NjQxNjk0",
      "title": "update KeySchedule to remove pkRm redundancy",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/24",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-12-02T14:05:46Z",
      "updatedAt": "2019-12-05T14:14:24Z",
      "closedAt": "2019-12-05T14:09:36Z",
      "mergedAt": "2019-12-05T14:09:36Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Current callers of `KeySchedule` pass in `pkR`, not `pkRm`, so I think the correct thing here is to rename the KeySchedule parameter `pkRm` to `pkR`.",
          "createdAt": "2019-12-03T21:11:58Z",
          "updatedAt": "2019-12-03T21:11:58Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere I merged this before I saw Chris's comment.  I agree with his point, so I reverted.  Could you please update and submit a new PR?",
          "createdAt": "2019-12-05T14:14:24Z",
          "updatedAt": "2019-12-05T14:14:24Z"
        }
      ],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0788c5536297926ccc17009cfd24eb9adb9a3bd0",
      "headRepository": "suhasHere/draft-irtf-cfrg-hpke",
      "headRefName": "master",
      "headRefOid": "1720daf6d69cd9a63c25f422a01198b91bb4746b",
      "mergeCommit": {
        "oid": "43fc1cda50d4def683e4b59f517416a9f6126a65"
      }
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ5NDYxNTU5",
      "title": "Revert \"update KeySchedule to remove pkRm redundancy\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/25",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reverts cfrg/draft-irtf-cfrg-hpke#24",
      "createdAt": "2019-12-05T14:12:04Z",
      "updatedAt": "2019-12-05T14:13:45Z",
      "closedAt": "2019-12-05T14:13:45Z",
      "mergedAt": "2019-12-05T14:13:45Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "43fc1cda50d4def683e4b59f517416a9f6126a65",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "revert-24-master",
      "headRefOid": "054f58d897b65f8741f18a4a488cdd6eeed487ec",
      "mergeCommit": {
        "oid": "3d79c0f24fbf43474e47da8ca069bea521eed071"
      }
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUwMjc0OTc5",
      "title": "fix pkrm computation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/26",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-12-07T04:27:30Z",
      "updatedAt": "2019-12-12T18:15:35Z",
      "closedAt": "2019-12-12T18:15:35Z",
      "mergedAt": "2019-12-12T18:15:35Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNDI3MTk5",
          "commit": {
            "abbreviatedOid": "5c43e3d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-12T18:15:29Z",
          "updatedAt": "2019-12-12T18:15:29Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "3d79c0f24fbf43474e47da8ca069bea521eed071",
      "headRepository": "suhasHere/draft-irtf-cfrg-hpke",
      "headRefName": "master",
      "headRefOid": "5c43e3da49fbb53f7de84b95f9acabf3ed8b19e1",
      "mergeCommit": {
        "oid": "9783537f604b3b2726ed0a8c64e6afd50e8e9d1e"
      }
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUyNTQ5MjU0",
      "title": "Add Export interface",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/27",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some applications of HPKE, such as ESNI, require a way to produce a unique value from a HPKE \"invocation\". (For ESNI, this would replace a client-generated nonce that is separate from HPKE entirely.) This change derives an additional exporter secret alongside the HPKE key and nonce, and then adds an Export API that can be used to derive additional secrets from this key using the KDF's `Expand` function.",
      "createdAt": "2019-12-12T18:22:08Z",
      "updatedAt": "2019-12-15T02:34:27Z",
      "closedAt": "2019-12-15T02:34:26Z",
      "mergedAt": "2019-12-15T02:34:26Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNDUyNjE0",
          "commit": {
            "abbreviatedOid": "dfe7fd0"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-12T18:58:36Z",
          "updatedAt": "2019-12-12T18:58:36Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Note that this is different from the TLS exporter, which has both a label and a context.  Might not need all of that here, though.\r\n\r\n```\r\n   TLS-Exporter(label, context_value, key_length) =\r\n       HKDF-Expand-Label(Derive-Secret(Secret, label, \"\"),\r\n                         \"exporter\", Hash(context_value), key_length)\r\n```",
              "createdAt": "2019-12-12T18:58:36Z",
              "updatedAt": "2019-12-12T18:58:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNDUyNjcx",
          "commit": {
            "abbreviatedOid": "dfe7fd0"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-12T18:58:42Z",
          "updatedAt": "2019-12-12T18:58:42Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "9783537f604b3b2726ed0a8c64e6afd50e8e9d1e",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/edits-and-exporter",
      "headRefOid": "dfe7fd03691b1900f85415b9281750c29c4a9a58",
      "mergeCommit": {
        "oid": "61e80255c5c69f23f3febe007a572a111a3352ba"
      }
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2MTU4NjI4",
      "title": "s/mode_psk_auth/mode_auth_psk.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/31",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #21.",
      "createdAt": "2020-01-23T02:59:44Z",
      "updatedAt": "2020-01-23T17:20:23Z",
      "closedAt": "2020-01-23T17:20:23Z",
      "mergedAt": "2020-01-23T17:20:23Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation #23 should resolve the CI issue above. ",
          "createdAt": "2020-01-23T03:04:54Z",
          "updatedAt": "2020-01-23T03:04:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDcyOTI1",
          "commit": {
            "abbreviatedOid": "7f568f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-23T17:20:17Z",
          "updatedAt": "2020-01-23T17:20:17Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d41dbb654900f47bf09b022d3774c21262c46a17",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/auth-psk-naming",
      "headRefOid": "7f568f55d1e1c3f5b19fe141a3850e8d2b7a2e05",
      "mergeCommit": {
        "oid": "456eadc80ee02c6064e3ce3591de59f83be45049"
      }
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2MTU5MTEw",
      "title": "Fix VerifyMode parameter name.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/32",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #19.",
      "createdAt": "2020-01-23T03:02:30Z",
      "updatedAt": "2020-01-23T17:21:16Z",
      "closedAt": "2020-01-23T17:21:15Z",
      "mergedAt": "2020-01-23T17:21:15Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation #23 should resolve the CI issue above. ",
          "createdAt": "2020-01-23T03:05:03Z",
          "updatedAt": "2020-01-23T03:05:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDczNDcz",
          "commit": {
            "abbreviatedOid": "ed3644b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-23T17:21:09Z",
          "updatedAt": "2020-01-23T17:21:09Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d41dbb654900f47bf09b022d3774c21262c46a17",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/key-schedule-notation",
      "headRefOid": "ed3644b5dbcf12ddb849fb284ef1e619cd2c677f",
      "mergeCommit": {
        "oid": "a3ae7b301f6c95922b0897097dae8d03103f83bb"
      }
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2MTYxNzE3",
      "title": "Clarify unidirectional nature of encryption contexts.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/33",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #29.",
      "createdAt": "2020-01-23T03:17:10Z",
      "updatedAt": "2020-01-24T15:36:44Z",
      "closedAt": "2020-01-24T15:36:44Z",
      "mergedAt": "2020-01-24T15:36:44Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDgyMTY5",
          "commit": {
            "abbreviatedOid": "a677637"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-23T17:35:15Z",
          "updatedAt": "2020-01-23T17:35:21Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "The additions here seem overly restrictive for a low-level document like this.  The underlying hard requirement is that each nonce value MUST be used only once, so in the event of bidirectional comms, the initiator and responder need to coordinate on which nonces belong to which sender.  For example, they might agree that the initiator sends with even-numbered nonces, and the responder with odd-numbered.  Of course, the details of such a scheme are up to the application.  The simplest such scheme is to use a given HPKE interaction for unidirectional communication, so that the initiator's context would only be used for encrypting and the responder's only for decrypting.",
              "createdAt": "2020-01-23T17:35:15Z",
              "updatedAt": "2020-01-24T15:28:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDg3ODMy",
          "commit": {
            "abbreviatedOid": "a677637"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-23T17:44:48Z",
          "updatedAt": "2020-01-23T17:44:48Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "> they might agree that the initiator sends with even-numbered nonces, and the responder with odd-numbered.\r\n\r\nI agree that this is possible, but the document (as specified) doesn't do this. Each sequence number starts at 0 and is always incremented by 1. \r\n\r\n> The simplest such scheme is to use a given HPKE interaction for unidirectional communication\r\n\r\nMaybe we can simplify the text to say this? That is, each context must only be used for unidirectional communication.",
              "createdAt": "2020-01-23T17:44:48Z",
              "updatedAt": "2020-01-24T15:28:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDEzMTEz",
          "commit": {
            "abbreviatedOid": "a677637"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-24T15:03:43Z",
          "updatedAt": "2020-01-24T15:03:44Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Ok, I'm coming around on this.  If we're going to lock it down, though, let's lock it down.  Namely, the multi-stage encryption here is just an extension of the single-stage version to allow the sender to stream data:\r\n\r\n* Initiator's context MUST be used for encryption only\r\n* Responder's context MUST be used for decryption only\r\n* Any other case, use the exporter\r\n\r\nMaybe we should be more explicit that this is streaming PKE (thus unidirectional I->R).  Should we reflect this in the pseudocode?",
              "createdAt": "2020-01-24T15:03:44Z",
              "updatedAt": "2020-01-24T15:28:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDI0NzIx",
          "commit": {
            "abbreviatedOid": "a677637"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-24T15:20:37Z",
          "updatedAt": "2020-01-24T15:20:37Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "The proposed text works for me! \r\n\r\n> Maybe we should be more explicit that this is streaming PKE (thus unidirectional I->R). Should we reflect this in the pseudocode?\r\n\r\nI don't think that's needed. But maybe others will suggest differently?",
              "createdAt": "2020-01-24T15:20:37Z",
              "updatedAt": "2020-01-24T15:28:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDM1OTky",
          "commit": {
            "abbreviatedOid": "7c20b2a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-24T15:36:39Z",
          "updatedAt": "2020-01-24T15:36:39Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d41dbb654900f47bf09b022d3774c21262c46a17",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/hpke-nonces",
      "headRefOid": "7c20b2adc8e004ca8bbb7a5e599ca4eca61699a8",
      "mergeCommit": {
        "oid": "8829872725945a470bef092f2ff54e7f9b7bfc14"
      }
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY4MTc0NTE0",
      "title": "Unify terminology around Initiator and Responder.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/34",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We used terms such as sender, initiator, receiver, recipient, and responder interchangeably. Let's simplify the vocabulary.",
      "createdAt": "2020-01-28T18:57:33Z",
      "updatedAt": "2020-02-06T21:20:29Z",
      "closedAt": "2020-02-06T21:20:29Z",
      "mergedAt": "2020-02-06T21:20:28Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ping @bifurcation ",
          "createdAt": "2020-01-29T23:04:47Z",
          "updatedAt": "2020-01-29T23:04:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine with converging to two words, but let's not use gratuitous capitals.",
          "createdAt": "2020-01-30T20:46:07Z",
          "updatedAt": "2020-01-30T20:46:07Z"
        },
        {
          "author": "karthikbhargavan",
          "authorAssociation": "NONE",
          "body": "I agree with unifying terminology, but I find \"responder\" to be a bit weird, since the responder never sends any response in HPKE. I prefer sender/recipient. What do you think?",
          "createdAt": "2020-01-30T21:05:26Z",
          "updatedAt": "2020-01-30T21:05:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agree with unifying terminology, but I find \"responder\" to be a bit weird, since the responder never sends any response in HPKE. I prefer sender/recipient. What do you think?\r\n\r\nThat's better! My thinking was that responder made sense for higher-level protocols into which HPKE would go, but in hindsight it's not the best term for plain old PKE. I moved to sender/receipient!",
          "createdAt": "2020-01-30T21:19:53Z",
          "updatedAt": "2020-01-30T21:19:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation good to go?",
          "createdAt": "2020-02-05T18:42:40Z",
          "updatedAt": "2020-02-05T18:42:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTU1NTI2",
          "commit": {
            "abbreviatedOid": "56a2e60"
          },
          "author": "karthikbhargavan",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-30T21:30:57Z",
          "updatedAt": "2020-01-30T21:30:57Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Do we want to change Initiator (I) to Sender (S)?\r\nIf so, do we want to change I everywhere (e.g. pkI) to S (i.e. pkS)?\r\nIts a biggish change, so we'd better all agree.",
              "createdAt": "2020-01-30T21:30:57Z",
              "updatedAt": "2020-01-30T21:39:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTYwMzk0",
          "commit": {
            "abbreviatedOid": "7cb0b92"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-30T21:39:39Z",
          "updatedAt": "2020-01-30T21:39:39Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Yep, I think so. I applied that suggestion. Please have a look!",
              "createdAt": "2020-01-30T21:39:39Z",
              "updatedAt": "2020-01-30T21:39:39Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8829872725945a470bef092f2ff54e7f9b7bfc14",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/initiator-responder",
      "headRefOid": "7cb0b926b348b44e742f134c16adcb29ac60ee69",
      "mergeCommit": {
        "oid": "06056da43f1826ca4549acca9358452f52ec2334"
      }
    },
    {
      "number": 35,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY5MjgzNjY1",
      "title": "Recommend public key verification.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/35",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses (?) #30.",
      "createdAt": "2020-01-30T20:58:07Z",
      "updatedAt": "2020-01-31T19:47:01Z",
      "closedAt": "2020-01-31T19:47:01Z",
      "mergedAt": "2020-01-31T19:47:01Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, wow, I just realized we have text that addresses this in the \"Key Encapsulation Mechanisms (KEMs)\" section: \r\n\r\n```\r\nFor the NIST curves P-256 and P-521, the Marshal function of the DH\r\nscheme produces the normal (non-compressed) representation of the\r\npublic key, according to {{SECG}}.  When these curves are used, the\r\nrecipient of an HPKE ciphertext MUST validate that the ephemeral public\r\nkey `pkE` is on the curve.  The relevant validation procedures are\r\ndefined in {{keyagreement}}.\r\n```\r\n\r\nSo I'll point to this text in the proposal.",
          "createdAt": "2020-01-30T21:14:05Z",
          "updatedAt": "2020-01-30T21:16:54Z"
        },
        {
          "author": "karthikbhargavan",
          "authorAssociation": "NONE",
          "body": "I agree. We should require all keys to be validated. I wish there were an\nup to date rfc for validation we could cite.\n\nOn Thu, Jan 30, 2020, 22:12 Benjamin Lipp <notifications@github.com> wrote:\n\n> *@blipp* commented on this pull request.\n> ------------------------------\n>\n> In draft-irtf-cfrg-hpke.md\n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/35#discussion_r373195756>\n> :\n>\n> > @@ -359,6 +359,11 @@ context. The key schedule inputs are as follows:\n>\n>  * `pkI` - The initiator's public key (optional; default\n>\n>    value `zero(Npk)`)\n>\n>\n>\n> +Responders SHOULD validate the initiator-provided encapsulated key for\n>\n> +correctness. For example, when using a DH-based KEM, the responder should\n>\n> +check that the resulting key share share is valid, i.e., a point on the\n>\n>\n> The sender should then also check if pkR is valid. For secrecy, that's\n> maybe even more important, because it's \u201cbefore the fact\u201d.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/35?email_source=notifications&email_token=ABFUVS46QQ3QVA3Z6DN6OYLRAM7CDA5CNFSM4KN4Y4EKYY3PNVWWK3TUL52HS4DFWFIHK3DMKJSXC5LFON2FEZLWNFSXPKTDN5WW2ZLOORPWSZGOCTXAVMY#discussion_r373195756>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABFUVSY2KUOG2ASBIALOVBLRAM7CDANCNFSM4KN4Y4EA>\n> .\n>\n",
          "createdAt": "2020-01-31T07:32:50Z",
          "updatedAt": "2020-01-31T07:32:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTQyNjk1",
          "commit": {
            "abbreviatedOid": "50b0c20"
          },
          "author": "karthikbhargavan",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-30T21:08:36Z",
          "updatedAt": "2020-01-30T21:08:37Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "\"key share share\"\r\n\r\nI am not sure what the \"resulting key share\" is.\r\nI would instead ask that the recipient/responder should check that pkI and pkE are valid.",
              "createdAt": "2020-01-30T21:08:37Z",
              "updatedAt": "2020-01-31T15:36:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTQ0NDI1",
          "commit": {
            "abbreviatedOid": "50b0c20"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-30T21:11:41Z",
          "updatedAt": "2020-01-30T21:11:41Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Good suggestion -- thanks!",
              "createdAt": "2020-01-30T21:11:41Z",
              "updatedAt": "2020-01-31T15:36:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTQ0NjI3",
          "commit": {
            "abbreviatedOid": "50b0c20"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-30T21:11:59Z",
          "updatedAt": "2020-01-30T21:12:00Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The sender should then also check if pkR is valid. For secrecy, that's maybe even more important, because it's \u201cbefore the fact\u201d.",
              "createdAt": "2020-01-30T21:12:00Z",
              "updatedAt": "2020-01-31T15:36:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNzM2Njkx",
          "commit": {
            "abbreviatedOid": "66f33c1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-31T19:46:55Z",
          "updatedAt": "2020-01-31T19:46:55Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8829872725945a470bef092f2ff54e7f9b7bfc14",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/point-validation",
      "headRefOid": "66f33c1654fd73afa7d031ef6709e54e64df8a1d",
      "mergeCommit": {
        "oid": "4d65f12b240cbb36eb2d5f56eeba0a11fce66241"
      }
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcyOTE0NzMz",
      "title": "Size of exporter_secret must be at least Nh, Nk is too small",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/36",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, `exporter_secret` is created with Expand at a size of `Nk` octets. It is then used within Context.Export as first argument to another call to Expand. However, for HKDF-Expand, the RFC https://tools.ietf.org/html/rfc5869 defines the first input as follows (emphasis mine):\r\n\r\n```\r\n   Inputs:\r\n      PRK      a pseudorandom key of *at least HashLen* octets\r\n```\r\n\r\n`HashLen` corresponds to `Nh` in the HPKE draft.\r\n\r\nLooking at the definitions of `Nh`, `Nk`, and `Nn` in https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#key-derivation-functions-kdfs-kdf-ids, it becomes clear that `Nh >= Nk` and `Nh >= Nn` for all combinations. Thus, to meet the security requirements of HKDF-Expand, `exporter_secret` should be generated with `Nh` bytes and not only with `Nk` bytes.\r\n\r\n(Said differently, `exporter_secret` is not yet the key, but the input to `Expand`)",
      "createdAt": "2020-02-10T02:47:12Z",
      "updatedAt": "2020-02-11T00:40:43Z",
      "closedAt": "2020-02-10T04:05:07Z",
      "mergedAt": "2020-02-10T04:05:07Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NjgyMzky",
          "commit": {
            "abbreviatedOid": "01e32be"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-10T04:05:02Z",
          "updatedAt": "2020-02-10T04:05:02Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "06056da43f1826ca4549acca9358452f52ec2334",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_sizes",
      "headRefOid": "01e32beeec86e14ce982cf7895aa0608ae65fd8c",
      "mergeCommit": {
        "oid": "c41aca085a5dd6dbe6cdd9f432220b2349d2411e"
      }
    },
    {
      "number": 37,
      "id": "MDExOlB1bGxSZXF1ZXN0MzczMjY5NzMw",
      "title": "Update test vectors (with new sender/responder notation).",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/37",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-10T17:51:18Z",
      "updatedAt": "2020-02-24T14:14:17Z",
      "closedAt": "2020-02-24T14:14:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, since we should also use PSKs of the appropriate length as per #41.",
          "createdAt": "2020-02-24T14:14:16Z",
          "updatedAt": "2020-02-24T14:14:16Z"
        }
      ],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "c41aca085a5dd6dbe6cdd9f432220b2349d2411e",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/new-vectors",
      "headRefOid": "137301a0683ebf9f4e5bbf94fce24a781b147361",
      "mergeCommit": null
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4MTY5NjEx",
      "title": "Fix typo at two occurrences of pskID",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/38",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-21T08:44:19Z",
      "updatedAt": "2020-02-21T16:04:41Z",
      "closedAt": "2020-02-21T16:04:41Z",
      "mergedAt": "2020-02-21T16:04:41Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzM3MTY1",
          "commit": {
            "abbreviatedOid": "4d12b47"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-21T16:04:28Z",
          "updatedAt": "2020-02-21T16:04:28Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "c41aca085a5dd6dbe6cdd9f432220b2349d2411e",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_fix_I_S",
      "headRefOid": "4d12b47a9b2732e4a11e608fd3b13b16a8a5450d",
      "mergeCommit": {
        "oid": "6d564037bd3f3ec139a7bc1279dac97a26f41dea"
      }
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4MTcwODk0",
      "title": "Refactor to use byte consistently instead of octet",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/39",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-21T08:48:04Z",
      "updatedAt": "2020-02-21T16:04:18Z",
      "closedAt": "2020-02-21T16:04:18Z",
      "mergedAt": "2020-02-21T16:04:18Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzM2MDkw",
          "commit": {
            "abbreviatedOid": "26c2bb0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-21T16:02:53Z",
          "updatedAt": "2020-02-21T16:02:53Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "fef9eaca3be3ab271ffab29b47dbc4a8ab752060",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_octets_bytes",
      "headRefOid": "78e8b1db2f1385f441f9fde91d2fb95a5f5e386b",
      "mergeCommit": {
        "oid": "176678135edd42d90dee45a3796c95b408b7e1a9"
      }
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4MTc4MDY5",
      "title": "Clarify definition of Npk and output of DH",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/40",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Confirming with the F* specs of P256 and Curve25516, DH returns an encoded curve point. This means the output of DH is of length Npk.",
      "createdAt": "2020-02-21T09:08:07Z",
      "updatedAt": "2020-02-21T16:02:18Z",
      "closedAt": "2020-02-21T16:02:17Z",
      "mergedAt": "2020-02-21T16:02:17Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzM1NTcx",
          "commit": {
            "abbreviatedOid": "032a2ee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-21T16:02:12Z",
          "updatedAt": "2020-02-21T16:02:12Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "c41aca085a5dd6dbe6cdd9f432220b2349d2411e",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_Npk",
      "headRefOid": "032a2ee20c169ea033340301422fa757a9ef63bb",
      "mergeCommit": {
        "oid": "fef9eaca3be3ab271ffab29b47dbc4a8ab752060"
      }
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc5ODU5MDM0",
      "title": "Summarize security properties.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/44",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Huzzah!\r\n\r\ncc @blipp ",
      "createdAt": "2020-02-25T23:01:46Z",
      "updatedAt": "2020-02-26T20:52:59Z",
      "closedAt": "2020-02-26T20:52:59Z",
      "mergedAt": "2020-02-26T20:52:59Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation should be good to go now!",
          "createdAt": "2020-02-26T15:49:40Z",
          "updatedAt": "2020-02-26T15:49:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTE4Njc2",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-25T23:12:32Z",
          "updatedAt": "2020-02-25T23:15:39Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Pseudo-Random Function",
              "createdAt": "2020-02-25T23:12:32Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 73,
              "body": "the gap Diffie-Hellman (GDH) problem is hard in the appropriate (sub)group.\r\n\r\nI think it is better to cite\r\n\r\n```\r\n@InProceedings{Okamoto01,\r\n  author = \t {Tatsuaki Okamoto and David Pointcheval},\r\n  title = \t {The Gap-Problems: a New Class of Problems for the Security of Cryptographic Schemes},\r\n  booktitle = {PKC 2001},\r\n  year = \t 2001,\r\n  editor = \t {K. Kim},\r\n  volume = \t 1992,\r\n  series = \t lncs,\r\n  pages = \t {104--118},\r\n  month = \t feb,\r\n  conflocation = \t {Cheju Islands, South Korea},\r\n  publisher = \"Springer\",\r\n}\r\n```\r\n\r\nbecause S01 uses a wrong/uncommon name for the assumption (gap computational), and basically also just cites this one.",
              "createdAt": "2020-02-25T23:15:00Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIwNzcx",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-25T23:17:37Z",
          "updatedAt": "2020-02-25T23:17:37Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-02-25T23:17:37Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIwOTUx",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-25T23:18:02Z",
          "updatedAt": "2020-02-25T23:18:03Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "I might actually change this to \"pseudorandom function\", as that's what was done in RFC8446!",
              "createdAt": "2020-02-25T23:18:02Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIxMDIw",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-25T23:18:12Z",
          "updatedAt": "2020-02-25T23:20:51Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "export secrets\r\n\r\n(could be multiple)",
              "createdAt": "2020-02-25T23:18:13Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 81,
              "body": "Or better:\r\n\r\nIndistinguishability of each export secret from a uniformly random bitstring of equal length.",
              "createdAt": "2020-02-25T23:19:30Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 91,
              "body": "s too much at the end of the line",
              "createdAt": "2020-02-25T23:20:18Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIyMjcz",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-25T23:21:23Z",
          "updatedAt": "2020-02-25T23:21:23Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Pesky macbook keyboards.",
              "createdAt": "2020-02-25T23:21:23Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIyMzA5",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-25T23:21:28Z",
          "updatedAt": "2020-02-25T23:21:28Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-02-25T23:21:28Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIyNTMy",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-25T23:21:59Z",
          "updatedAt": "2020-02-25T23:22:00Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "ack! I was just suggesting this because you had Random Oracle capitalized. If you do \u201cpseudorandom function\u201d, then maybe also \u201crandom oracle\u201d",
              "createdAt": "2020-02-25T23:21:59Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIwMjEy",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-25T23:16:16Z",
          "updatedAt": "2020-02-26T15:30:09Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Nit: Please align the `|` characters",
              "createdAt": "2020-02-25T23:16:16Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 31,
              "body": "I might like to still have a summary up here, with a pointer down to the security considerations.  How about something like this (which also folds in the text from above):\r\n\r\n> As a hybrid authenticated encryption algorithm, we desire security\r\n> against (adaptive) chosen ciphertext attacks (IND-CCA2 secure). The\r\n> HPKE variants described in this document achieve this property under\r\n> standard assumptions about the underlying primitives {{HPKEAnalysis}}. \r\n> A summary of this analysis is in {{sec-considerations}}.\r\n\r\nI would be OK deleting the section header in any case.",
              "createdAt": "2020-02-26T15:14:26Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 73,
              "body": "It would also be good to say what property we expect of any non-DH KEMs.  That is, if someone is going to implement this with a new KEM, what do they need to verify about that KEM in order to be confident that HPKE with it is good?",
              "createdAt": "2020-02-26T15:16:41Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 73,
              "body": "Would it be worth a brief note that the DH groups, KDF, and KEMs defined in this document have these properties?",
              "createdAt": "2020-02-26T15:17:27Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 81,
              "body": "Nit: \"each exported secret\"",
              "createdAt": "2020-02-26T15:18:21Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 91,
              "body": "Nit: s/as/because/",
              "createdAt": "2020-02-26T15:20:30Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 109,
              "body": "Is this sentence still relevant?  Doesn't seem like it.  If we are still discussing an advanced case, put a subsection break before it.",
              "createdAt": "2020-02-26T15:22:22Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 97,
              "body": "Further nits:\r\n* You're going to overflow the RFC line length with this table.  Need shorter headings\r\n* The `X` /  `N/A` values should be centered\r\n* I think it looks nicer if you group the single-shot ones\r\n\r\nSo:\r\n```\r\n| Variant              | Message Sec. | Export Sec. | Sender Auth. |\r\n|:---------------------|:------------:|:-----------:|:------------:|\r\n| Base, single-shot    | X            | N/A         | N/A          |\r\n| PSK, single-shot     | X            | N/A         | X            |\r\n| Auth, single-shot    | X            | N/A         | X            |\r\n| AuthPSK, single-shot | X            | N/A         | X            |\r\n| Base, export         | X            | X           | N/A          |\r\n| PSK, export          | X            | X           | X            |\r\n| Auth, export         | X            | X           | X            |\r\n| AuthPSK, export      | X            | X           | X            |\r\n```",
              "createdAt": "2020-02-26T15:29:49Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDA3MzIw",
          "commit": {
            "abbreviatedOid": "9ca6448"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T15:42:03Z",
          "updatedAt": "2020-02-26T15:42:04Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "I deleted it and wrapped this section in its own header (\"Security Properties\").",
              "createdAt": "2020-02-26T15:42:03Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDE0MTMz",
          "commit": {
            "abbreviatedOid": "dc26b14"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T15:49:24Z",
          "updatedAt": "2020-02-26T15:49:25Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Nice --fixed!",
              "createdAt": "2020-02-26T15:49:24Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDI1MzEy",
          "commit": {
            "abbreviatedOid": "dc26b14"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T16:01:16Z",
          "updatedAt": "2020-02-26T16:02:33Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Don't you need an assumption on the AEAD too?  Presumably just IND-CCA2",
              "createdAt": "2020-02-26T16:01:16Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 100,
              "body": "Nit: \"Moreover\" is unnecessary.  \r\n\r\nYou're also still missing what the general KEM property is.  I would arrange as \r\n\r\n* General KEM property\r\n* Probably a paragraph break\r\n* DH-KEM satisfies the general KEM property if gap DH\r\n* KDFs and AEAD functions in this doc meet the requirements\r\n",
              "createdAt": "2020-02-26T16:02:00Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDU0NDA5",
          "commit": {
            "abbreviatedOid": "dc26b14"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T16:33:54Z",
          "updatedAt": "2020-02-26T16:33:55Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "We can't say anything about general KEMs yet. The analysis does not cover that!",
              "createdAt": "2020-02-26T16:33:55Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDU0NTYy",
          "commit": {
            "abbreviatedOid": "dc26b14"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T16:34:06Z",
          "updatedAt": "2020-02-26T16:34:06Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "I'll add something, sure.",
              "createdAt": "2020-02-26T16:34:06Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTI1NDQ2",
          "commit": {
            "abbreviatedOid": "5cb7705"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T18:10:21Z",
          "updatedAt": "2020-02-26T18:10:22Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "One last thing:\r\n\r\n> In addition, both {{CS01}} and {{HPKEAnalysis}} are premised on the classical random oracle model, and do not consider attackers capable of quantum computation.  A full proof of post-quantum security would need to take this difference into account, in addition to simply using a post-quantum KEM.",
              "createdAt": "2020-02-26T18:10:21Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTUxODMy",
          "commit": {
            "abbreviatedOid": "5cb7705"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-26T18:49:11Z",
          "updatedAt": "2020-02-26T18:49:58Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "`The gap Diffie-Hellman (GDH) problem is hard {{GAP}}.`",
              "createdAt": "2020-02-26T18:49:12Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTU2ODk3",
          "commit": {
            "abbreviatedOid": "5cb7705"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-26T18:56:20Z",
          "updatedAt": "2020-02-26T18:57:33Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Will we make cryptographers nervous when we say \u201cstandard assumptions\u201d but use the ROM? Assuming ROM for HPKE or Hash is pretty standard, but it is not the \u201cstandard _model_\u201d. We don't say the word _model_ here, so it might be ok\u2026 Is \u201cstandard\u201d here meant in the sense of \u201ccommon\u201d, or in the sense of \u201cclassical\u201d (not post-quantum)? Maybe we could use one of these two instead of standard.",
              "createdAt": "2020-02-26T18:56:20Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTU5Mjc4",
          "commit": {
            "abbreviatedOid": "61ed7d9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T18:59:36Z",
          "updatedAt": "2020-02-26T18:59:36Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Hmm... I hadn't considered that. I replaced this with classical, as that seems to best describe what we've done. ",
              "createdAt": "2020-02-26T18:59:36Z",
              "updatedAt": "2020-02-26T18:59:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjMzMTYw",
          "commit": {
            "abbreviatedOid": "61ed7d9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-26T20:52:52Z",
          "updatedAt": "2020-02-26T20:52:52Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "6d564037bd3f3ec139a7bc1279dac97a26f41dea",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/analysis",
      "headRefOid": "61ed7d99037b5d7698a5d82e26cfddd65fb9e979",
      "mergeCommit": {
        "oid": "be909d595078606f97e76a67d72c28072c41bcfc"
      }
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc5OTczMDQw",
      "title": "Update test vectors.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/45",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "With new PSK lengths and more fields. Addresses #41.",
      "createdAt": "2020-02-26T02:29:04Z",
      "updatedAt": "2020-02-28T14:34:05Z",
      "closedAt": "2020-02-28T14:34:05Z",
      "mergedAt": "2020-02-28T14:34:05Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NDM4NTg4",
          "commit": {
            "abbreviatedOid": "4515e6c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-28T14:32:59Z",
          "updatedAt": "2020-02-28T14:32:59Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "6d564037bd3f3ec139a7bc1279dac97a26f41dea",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/new-vectors-2",
      "headRefOid": "4515e6c5a788c64fa835e5ce88025c238dfc1945",
      "mergeCommit": {
        "oid": "70c44a2080abf83397b9f7d364ee01de153629eb"
      }
    },
    {
      "number": 47,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxNDE5ODcx",
      "title": "Domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/47",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Tries to address #46. \r\n\r\ncc @blipp ",
      "createdAt": "2020-02-28T14:30:09Z",
      "updatedAt": "2020-02-28T14:30:57Z",
      "closedAt": "2020-02-28T14:30:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "be909d595078606f97e76a67d72c28072c41bcfc",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/domain-separation",
      "headRefOid": "e4ef3ed0fa54b8752175554888c24756bde2eee1",
      "mergeCommit": null
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxNDIyMTM3",
      "title": "Add domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/48",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add RFC number domain separation tag. Clone KeySchedule Hash calls with one-byte prefix.\r\n\r\nThis attempts to address #47.\r\n\r\n",
      "createdAt": "2020-02-28T14:34:38Z",
      "updatedAt": "2020-03-08T02:19:35Z",
      "closedAt": "2020-03-08T02:19:35Z",
      "mergedAt": "2020-03-08T02:19:35Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp @beurdouche @bifurcation what do we want to do with this?",
          "createdAt": "2020-03-04T22:42:32Z",
          "updatedAt": "2020-03-04T22:42:32Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this change is necessary.  As I understand it, the proofs we have do not rely on independent ROs, so there's no need to assure independence in this way.  @blipp, please correct me if this impression is wrong.\r\n\r\nThe 0x00/0x01 prepending has nothing to do with RO separation.  At best it ensures that a specific type of programming error causes a failure (reversal of pskID and info fields).  It seems fairly certain that in any practical case, such an error would be caught quickly anyway, since it is only hidden when `pskID == info`.",
          "createdAt": "2020-03-06T19:26:49Z",
          "updatedAt": "2020-03-06T19:26:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think this change is necessary. As I understand it, the proofs we have do not rely on independent ROs, so there's no need to assure independence in this way. @blipp, please correct me if this impression is wrong.\r\n\r\nAs discussed offline, I think this is the wrong mental model for domain separation. The rationale in the security considerations section attempts to make the idea clear: adding a prefix to the extract calls ensures that secrets derived from the *same* shares in HPKE do not conflict with secrets derived in other protocols. Can you state with certainty this type of cross-protocol collision is safe? \r\n\r\n> The 0x00/0x01 prepending has nothing to do with RO separation. At best it ensures that a specific type of programming error causes a failure (reversal of pskID and info fields). It seems fairly certain that in any practical case, such an error would be caught quickly anyway, since it is only hidden when pskID == info.\r\n\r\nYes, this change aims to prevent programmer error. I think the API should fail on misuse. As it stands now, that is *not the case*.",
          "createdAt": "2020-03-06T19:29:21Z",
          "updatedAt": "2020-03-06T19:29:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation I removed the Hash prefix changes, limiting this change to `identifier`-based separation. (We can address the Hash proposal in a separate issue/PR if desired!)",
          "createdAt": "2020-03-06T19:38:24Z",
          "updatedAt": "2020-03-06T19:38:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can you state with certainty this type of cross-protocol collision is safe?\r\n\r\nAbsent some globally-enforced standard for hash inputs and a managed namespace for prefixes, you will never achieve certainty.\r\n\r\nI'll grant that \"RFCXXXX\" is probably a bit better than just \"hpke\", and centralizing the prefix is better than how it was before.  So I can live with this.\r\n",
          "createdAt": "2020-03-06T20:08:24Z",
          "updatedAt": "2020-03-06T20:08:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NDQ1MTI2",
          "commit": {
            "abbreviatedOid": "797ded8"
          },
          "author": "beurdouche",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T14:42:06Z",
          "updatedAt": "2020-02-28T14:42:06Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I think you can remove \"(or oracle query)\".\r\nI wouldn't use that reference either... There is nothing new here, that said I don't have a good one in mind : )",
              "createdAt": "2020-02-28T14:42:06Z",
              "updatedAt": "2020-03-06T19:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTAyMTI1",
          "commit": {
            "abbreviatedOid": "3fa8824"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T15:57:03Z",
          "updatedAt": "2020-02-28T15:57:03Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I dropped the parenthetical. As I don't have a better reference for domain separation, I'm inclined to keep the citation. (Better to point somewhere than rely on folklore?)",
              "createdAt": "2020-02-28T15:57:03Z",
              "updatedAt": "2020-03-06T19:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTczOTE4",
          "commit": {
            "abbreviatedOid": "3fa8824"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T17:46:55Z",
          "updatedAt": "2020-02-28T17:46:55Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "`This domain separation does not protect the KeySchedule 'secret' from use in other\r\nprotocols.`: maybe this sentence is not needed, because `secret` is not exposed by the protocol, and thus not used in any other construction.",
              "createdAt": "2020-02-28T17:46:55Z",
              "updatedAt": "2020-03-06T19:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTc1ODk5",
          "commit": {
            "abbreviatedOid": "3fa8824"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T17:50:27Z",
          "updatedAt": "2020-02-28T17:50:27Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Or maybe we add that clarification? \r\n\r\nDerivation of the KeySchedule 'secret' does not include domain separation as it is an intermediate value not exposed by the protocol.",
              "createdAt": "2020-02-28T17:50:27Z",
              "updatedAt": "2020-03-06T19:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTc2Nzk3",
          "commit": {
            "abbreviatedOid": "3fa8824"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T17:52:02Z",
          "updatedAt": "2020-02-28T17:52:03Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Yes, sounds good.",
              "createdAt": "2020-02-28T17:52:03Z",
              "updatedAt": "2020-03-06T19:51:36Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "70c44a2080abf83397b9f7d364ee01de153629eb",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/separation",
      "headRefOid": "8bbbb3fbe8818dc39a52501e82be232827e84008",
      "mergeCommit": {
        "oid": "a025ae8aa80bcdc5065f5a25cf93bb971582bcfc"
      }
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyNTQxNTcx",
      "title": "Correct KEM sizes for NIST curves.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/49",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-02T18:34:43Z",
      "updatedAt": "2020-03-04T18:46:11Z",
      "closedAt": "2020-03-04T18:46:11Z",
      "mergedAt": "2020-03-04T18:46:11Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation ",
          "createdAt": "2020-03-02T18:35:03Z",
          "updatedAt": "2020-03-02T18:35:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This probably needs to update the DHKEM section, too, right?\r\n\r\n```\r\nThe GenerateKeyPair, Marshal, and Unmarshal functions are the same as for the underlying DH group. The Marshal functions for the curves referenced in {#ciphersuites} are as follows:\r\n\r\nP-256: The X-coordinate of the point, encoded as a 32-byte big-endian integer\r\nP-521: The X-coordinate of the point, encoded as a 66-byte big-endian integer\r\n```",
          "createdAt": "2020-03-02T20:07:26Z",
          "updatedAt": "2020-03-02T20:07:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTI3NzI3",
          "commit": {
            "abbreviatedOid": "39bf43a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Good catch!",
          "createdAt": "2020-03-02T21:07:44Z",
          "updatedAt": "2020-03-02T21:08:02Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n  Y-coordinate of the point, encoded as 32-byte big-endian integers\r\n```",
              "createdAt": "2020-03-02T21:07:44Z",
              "updatedAt": "2020-03-02T21:14:16Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\n  Y-coordinate of the point, encoded as 66-byte big-endian integers\r\n```",
              "createdAt": "2020-03-02T21:07:54Z",
              "updatedAt": "2020-03-02T21:14:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDI5NzI0",
          "commit": {
            "abbreviatedOid": "6d24cc7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T18:45:48Z",
          "updatedAt": "2020-03-04T18:45:48Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "70c44a2080abf83397b9f7d364ee01de153629eb",
      "headRepository": "Bren2010/draft-irtf-cfrg-hpke",
      "headRefName": "brendan/kem-sizes",
      "headRefOid": "6d24cc78d0ddda6064f45b8094be9fe337624eed",
      "mergeCommit": {
        "oid": "e4be5411828691b396fb2de7f9a40a319765a7d0"
      }
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0OTIyOTkx",
      "title": "Modifications for IND-CCA-secure DHKEM and independent random oracles",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The isolated DHKEM cannot be proven IND-CCA-secure as it is: In the current Encap, nothing is done with the result of the DH operation, `zz`. This means there is nowhere where the GDH assumption can be applied, as for this we need a comparison of a value with `g^ab` in the game, like `g^c = g^ab`, which we can then change in a game hop to `false`.\r\n\r\nThis is not a problem when looking at HPKE as a whole, because `zz` is fed into Extract which we model as a random oracle. For DHKEM isolated, this problem can be fixed by feeding the Diffie-Hellman shared secret through another random oracle before returning the result as `zz`.\r\n\r\nThe hash functions suggested in this pull request are chosen to correspond to the security level of the elliptic curve DH, respectively. If users of HPKE want to use only one hash function, then they need to choose the KDF depending on the used DHKEM. Specifying each DHKEM for multiple (i.e. different output size) hash functions seems overkill and like sending wrong signals about the security level of DHKEM.\r\n\r\nRegarding random oracle cloning: By introducing another call to a random oracle, which might be implemented by the same hash function, this becomes now more relevant than before. I think we need to make sure that Hash' and the calls to Hash inside HMAC are independent, to be able to use the indifferentiability theorem on SHAxxx. I looked at the input domains of these two calls for SHA256, SHA384, and SHA512 and they are indeed _already disjoint_ by their lengths. An open question is if we need to do something about the Hash calls `Hash(pskID)` and `Hash(info)` that we model as collision resistant. I like to discuss this with Bruno and/or Karthik before proceeding.\r\n\r\nThis pull request is to keep you in the loop, please feel free to provide preliminary feedback.",
      "createdAt": "2020-03-06T16:54:50Z",
      "updatedAt": "2020-04-10T20:31:27Z",
      "closedAt": "2020-04-10T20:31:27Z",
      "mergedAt": "2020-04-10T20:31:27Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I came to the conclusion that we need to separate `HashDH` and `Hash`: If we model `HashDH` as random oracle, and `Hash` as collision resistant, then this model is not sound if they are instantiated by the same function. (because then the `HashDH` random oracle should have taken into account collisions with `Hash` and vice versa, but they didn't in the model because they are modeled as independent)\r\n\r\nI introduced prefixes for `HashDH` and `Hash`.\r\n\r\nI somewhat incorporated the proposals from #48:\r\n- The prefix is \u201cRFCXXXX\u201d plus \u201cDHKEM\u201d or \u201cHPKE\u201d\r\n- However, if the prefix is already inside pskID_hash and info_hash, I think it's not additionally needed as `identifier` at the beginning of context.\r\n- \u201chpke\u201d is removed from the Expand contexts, as it's already in the prefix.\r\n- comment on the independence of derived secrets form other protocols using the same KEM.\r\n\r\nI am open to suggestions to replace the hash function name `HashDH` and the variable name `dh` by something else; same for `label_dhkem` and `label_hash`.",
          "createdAt": "2020-03-08T02:17:36Z",
          "updatedAt": "2020-03-08T02:27:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, if the prefix is already inside pskID_hash and info_hash, I think it's not additionally needed as identifier at the beginning of context.\r\n\r\nI would prefer we keep `identifier` as a prefix in `context` since that's fed directly into Expand. ",
          "createdAt": "2020-03-08T02:28:12Z",
          "updatedAt": "2020-03-08T02:28:12Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I would prefer we keep `identifier` as a prefix in `context` since that's fed directly into Expand.\r\n\r\nThat's fair; because it's different issues being addressed (random oracle cloning and binding the keys to the primitive name).",
          "createdAt": "2020-03-08T02:35:14Z",
          "updatedAt": "2020-03-08T02:35:14Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One way to resolve the merge conflict would be\r\n```\r\ndef KeySchedule(mode, pkR, zz, enc, info, psk, pskID, pkSm):\r\n  VerifyMode(mode, psk, pskID, pkSm)\r\n\r\n  pkRm = Marshal(pkR)\r\n  identifier = \"RFCXXXX\"\r\n  label_hash = \"RFCXXXX HPKE\"\r\n  ciphersuite = concat(kem_id, kdf_id, aead_id)\r\n  pskID_hash = Hash(concat(label_hash, pskID))\r\n  info_hash = Hash(concat(label_hash, info))\r\n  context = concat(identifier, ciphersuite, mode, enc, pkRm,\r\n                   pkSm, pskID_hash, info_hash)\r\n\r\n  secret = Extract(psk, zz)\r\n  key = Expand(secret, concat(\"key\", context), Nk)\r\n  nonce = Expand(secret, concat(\"nonce\", context), Nn)\r\n  exporter_secret = Expand(secret, concat(\"exp\", context), Nh)\r\n\r\n  return Context(key, nonce, exporter_secret)\r\n~~~~~\r\n\\[\\[RFC editor: please change \"RFCXXXX\" to the correct number before publication.]]\r\n\r\n```",
          "createdAt": "2020-03-08T02:47:55Z",
          "updatedAt": "2020-03-08T02:47:55Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "```\r\nThe KeySchedule procedure includes the domain separation string \"RFCXXXX\" in\r\neach Expand invocation. This ensures any secrets derived in HPKE are independent\r\nfrom those used in other protocols, even when derived from the same IKM (secret).\r\n```\r\n\r\nI am not happy at the moment with the language of the description of the `identifier`. As 2020/241 says, and I agree, domain separation is a method, not a goal. What's the goal with `identifier`? I think the goal is to bind the key to the protocol/primitive name. I don't see at the moment how \u201dindependent\u201d is defined here? (maybe we can have a formulation without that, like `This ensures any secrets derived in HPKE are bound to the scheme's name, even when possibly derived from the same KEM shared secret as in another scheme.`)\r\n\r\n```\r\nDerivation of the KeySchedule 'secret' does not include domain separation as it\r\nis an intermediate value not exposed by the protocol.\r\n```\r\n\r\nI would drop this sentence: If we agree that the goal is binding of keys to the primitive name, then we don't need to bind an intermediary value to the primitive name.",
          "createdAt": "2020-03-08T03:01:27Z",
          "updatedAt": "2020-03-08T03:01:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> This ensures any secrets derived in HPKE are bound to the scheme's name, even when possibly derived from the same KEM shared secret as in another scheme.\r\n\r\nI like it! Want to make that change?\r\n\r\n> I would drop this sentence: If we agree that the goal is binding of keys to the primitive name, then we don't need to bind an intermediary value to the primitive name.\r\n\r\nHmm... this sentence is clarifying why we don't prefix extraction for `secret`. I don't think this conflicts with the stated goal.",
          "createdAt": "2020-03-08T03:08:41Z",
          "updatedAt": "2020-03-08T03:08:41Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I like it! Want to make that change?\r\n\r\nAck, I'll make the change (when we know what to do with the rest).\r\n\r\n> Hmm... this sentence is clarifying why we don't prefix extraction for `secret`. I don't think this conflicts with the stated goal.\r\n\r\nWe could also add the prefix to `secret`, it would have the same effect of binding HPKE's output secrets to the primitive name. In my view we chose to add the prefix to `context` because that's a place where we already add all the other context. Now that I am looking closer, the outputs of the three Expand calls are also not exposed by the protocol and thus can be considered intermediary values as well (`key` and `nonce` are used to produce ciphertexts, only those are exposed; `exporter_secret` is used to derive the actual exported secrets). That's why I would not comment on another intermediary value (secret), and drop this sentence.\r\n\r\nI think I can now express my weird feeling towards \u201cindependent\u201d better: the goal of binding the secrets to the primitive name is not assured by a security proof. I think we cannot prove that other protocols do not derive the same keys, because we do not have control over these other protocols. They could still derive the same keys on purpose. What we achieve by the `identifier` string is that the probability gets small that someone does it by accident. But we cannot get a guarantee like with `HashDH` and `Hash`, where we control both protocols. That's why I felt uncomfortable with \u201cindependent\u201d, because it suggests a more formal guarantee as it actually gives.",
          "createdAt": "2020-03-08T04:00:26Z",
          "updatedAt": "2020-03-08T04:00:26Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "By this reasoning, `label_hash` would be enough to bind HPKE's outputs to its name/identifier. It just happens one computation step earlier.",
          "createdAt": "2020-03-08T04:16:49Z",
          "updatedAt": "2020-03-08T04:16:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "What happens if either pskID or label are unspecified? Their hashes would be a singe, fixed value. Aren\u2019t other (attacker-controlled?) parameters added to context? Don\u2019t we need to separate inline with those values? (Sorry for possibly hand wavy nonsense!)",
          "createdAt": "2020-03-08T04:29:58Z",
          "updatedAt": "2020-03-08T04:29:58Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> What happens if either pskID or label are unspecified? Their hashes would be a singe, fixed value. Aren\u2019t other (attacker-controlled?) parameters added to context? Don\u2019t we need to separate inline with those values? (Sorry for possibly hand wavy nonsense!)\r\n\r\nOur goal is to make the derived values dependent on the primitives name. This is still the case even if application info or pskID are empty, because the prefix stays.\r\n\r\nNoise protocols like WireGuard add the protocol name in a similar way. In WireGuard, the protocol starts with [1]:\r\n\r\n```\r\nC_i := Hash(Construction)\r\nH_i := Hash(C_i || Identifier)\r\n\u2026\r\n```\r\n\r\nwith the constants being\r\n\r\n```\r\nConstruction = The UTF-8 string literal \u201cNoise_IKpsk2_25519_ChaChaPoly_BLAKE2s\u201d, 37 bytes of\r\noutput.\r\nIdentifier = The UTF-8 string literal \u201cWireGuard v1 zx2c4 Jason@zx2c4.com\u201d, 34 bytes of output.\r\n```\r\n\r\n[1] https://www.wireguard.com/papers/wireguard.pdf page 10",
          "createdAt": "2020-03-09T11:31:07Z",
          "updatedAt": "2020-03-09T11:31:07Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On the PSK length:\r\n\r\nHMAC(K, M) feeds K through a call to Hash if K is longer than Hash's blocksize. If we allow arbitrary-size PSKs for user convenience, this would introduce another place where Hash is called on arbitrary-sized input, just like with info and pskID. (As a reminder: Arbitrary-sized input to Hash can lead to collisions with input to Hash calls inside HMAC. This would render the proof inapplicable that proves indifferentiability of HMAC from a random oracle. To avoid collisions, we use Extract calls and separate the input domains by using a prefix).\r\n\r\nTo avoid this extra Hash call inside HMAC, we can just anticipate it directly in KeySchedule, and thus control the prefix. While this introduces branching inside KeySchedule, this branching would either way be done inside HMAC. Doing the Extract call even if the PSK is shorter then Nb would hurt performance in non-PSK modes, too.",
          "createdAt": "2020-03-25T00:09:52Z",
          "updatedAt": "2020-03-25T00:09:52Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On the context added to DHKEM:\r\n\r\nAs a reminder, this is an ongoing effort to propose changes to the HPKE draft, with the goal to make DHKEM a KEM being provable IND-CCA-secure independently from HPKE as a whole.\r\n\r\nHaving DHKEM IND-CCA-secure on its own is nice because then it is enough to do _one_ proof of HPKE assuming an IND-CCA-secure KEM. If DHKEM would not be IND-CCA-secure, then we would need both an explicit proof of the entire HPKE[DHKEM] _and_ a proof of HPKE assuming an IND-CCA-secure KEM if we want other KEMs to be pluggable into HPKE.\r\n\r\n- As discussed earlier and off-channel, Curve25519 has equivalent keys. This results in a weaker security property for DHKEM in comparison to full HPKE, because DHKEM does not have any context so far in the derivation of zz.\r\n\r\n  The common recommendation is to include enc, pkRm, and pkSm into the context of the derivation of zz. Adding context to the Extract step of HKDF is not advisable as noted in the HKDF RFC [1]. This is why this update of the pull request adds an Expand step to DHKEM.\r\n\r\n  Curve25519 is specified not to have/need public-key validation, which is why equivalent keys \u201ccannot\u201d be detected beforehand. (Also, adding context is a lot cheaper than doing a scalar mult/point addition to detect equivalent keys).\r\n\r\n- Why not have more context within DHKEM: would it desirable to have kem_id, kdf_id, and a protocol-specific identifier in the context?\r\n\r\n  The goal of such context would be that, even if someone uses DHKEM with the same static keys in parallel with two different protocols (HPKE and some other protocol), the two DHKEM key distributions (of zz) are independent.\r\n\r\n  We came to the conclusion that to achieve this goal, DHKEM's key derivation needs to be protocol-dependent, for example by receiving as input an info variable that contains the protocol name, and use this in the context. (kem_id and kdf_id are not protocol-dependent but specific to DHKEM and thus are not useful to make the keys independent if the same DHKEM is used.)\r\n\r\n  Requiring an info parameter for DHKEM seemed to be rather complex in comparison to the benefit; also this benefit is rather uncontrollable because it involves assumptions on the well-behavior of other protocols. Also, the post-quantum KEMs don't seem to do that. We came to the conclusion to only make sure that enc, pkSm, pkRm are in DHKEM's context, because they are necessary to make it IND-CCA-secure on its own.\r\n\r\nLeft to discuss:\r\n- enc, pkSm, pkRm are now part of the context of both DHKEM and KeySchedule. It would be ok to _not_ include them in KeySchedule's context if HPKE would require from a KEM that public keys and the KEM ciphertext are included explicitly in the derivation of the KEM shared secret.\r\n\r\n[1] https://hyp.is/BEfR7m1AEeqBfpNgYg1Ivg/tools.ietf.org/html/rfc5869",
          "createdAt": "2020-03-25T00:59:23Z",
          "updatedAt": "2020-03-25T00:59:23Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Notes on PSK in KeySchedule vs PSK in DHKEM:\r\n\r\nThe PSK provides additional secrecy and authentication guarantees and as such could also be part of the DHKEM definition. However, no post-quantum KEM seems to have a PSK mode. Leaving the PSK outside DHKEM but in KeySchedule makes sense if we want to keep the possibility of a PSK if HPKE is used with a general KEM other than DHKEM.",
          "createdAt": "2020-03-25T11:38:43Z",
          "updatedAt": "2020-03-25T11:38:43Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This one is more of an implementation consideration:\r\n\r\nThe DHKEM functions and KeySchedule compute the marshaled public keys each time. Would it be acceptable if an implementation chooses to receive these values as additional parameters? Do you think this needs to be explicitly allowed in the spec?",
          "createdAt": "2020-03-25T11:44:16Z",
          "updatedAt": "2020-03-25T11:44:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The DHKEM functions and KeySchedule compute the marshaled public keys each time. Would it be acceptable if an implementation chooses to receive these values as additional parameters? Do you think this needs to be explicitly allowed in the spec?\r\n\r\nI'm sure implementations might want to do that. We can probably note it as an implementation detail. I don't think the spec needs to spell that out in the pseudocode, though.",
          "createdAt": "2020-03-25T17:43:23Z",
          "updatedAt": "2020-03-25T17:43:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> enc, pkSm, pkRm are now part of the context of both DHKEM and KeySchedule. It would be ok to not include them in KeySchedule's context if HPKE would require from a KEM that public keys and the KEM ciphertext are included explicitly in the derivation of the KEM shared secret.\r\n\r\nInteresting point. I think this is nice simplification of the key schedule and a perfectly fine requirement to levy on future KEMs. @bifurcation, penny for your thoughts?",
          "createdAt": "2020-03-25T17:46:09Z",
          "updatedAt": "2020-03-25T17:46:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation please review!",
          "createdAt": "2020-03-30T22:56:31Z",
          "updatedAt": "2020-03-30T22:56:31Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > enc, pkSm, pkRm are now part of the context of both DHKEM and KeySchedule. It would be ok to not include them in KeySchedule's context if HPKE would require from a KEM that public keys and the KEM ciphertext are included explicitly in the derivation of the KEM shared secret.\r\n> \r\n> Interesting point. I think this is nice simplification of the key schedule and a perfectly fine requirement to levy on future KEMs. @bifurcation, penny for your thoughts?\r\n\r\nAddressed in commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/38f915fe919c8514a8bb2f3127438ec899330711.",
          "createdAt": "2020-04-08T19:31:04Z",
          "updatedAt": "2020-04-08T19:31:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDc5NTYy",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-06T16:58:37Z",
          "updatedAt": "2020-03-06T16:59:01Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Can we introduce this notation (`DHKEM(curve, hash)`) in the DHKEM section?",
              "createdAt": "2020-03-06T16:58:38Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDc5Njcy",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T16:58:47Z",
          "updatedAt": "2020-03-06T17:02:17Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I would just add this to the above list of required functions.  \"Suppose we are given a Diffie-Hellman group and a hash function ...\"",
              "createdAt": "2020-03-06T16:58:47Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 15,
              "body": "For compatibility with programming languages, might call this \"Hash2\" or something that could actually be a function name in.",
              "createdAt": "2020-03-06T16:59:45Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 16,
              "body": "`Nzz` needs to be defined somewhere; TBH seems like this would be good to know for other KEMs as well.  I think this loses the idea that the DH output is fixed-size, though.  Do we need that?",
              "createdAt": "2020-03-06T17:01:01Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDg0NTgz",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T17:06:09Z",
          "updatedAt": "2020-03-06T17:06:10Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Putting it alongside the `Nh` et al. definitions would suffice. \r\n\r\n> I think this loses the idea that the DH output is fixed-size, though. Do we need that?\r\n\r\n@bifurcation I'm not sure I follow. Nzz *is* fixed, so isn't the output fixed size?",
              "createdAt": "2020-03-06T17:06:10Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDg2ODI2",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T17:09:47Z",
          "updatedAt": "2020-03-06T17:09:47Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Good point, I'll add `Nzz` to the \u201cCryptographic Dependencies\u201d part; I am not sure what you mean regarding the fixed-size DH output? (sorry for the double question, I was writing at the same time with Chris ;) )",
              "createdAt": "2020-03-06T17:09:47Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDkwMTE0",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T17:14:47Z",
          "updatedAt": "2020-03-06T17:14:48Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Might be relevant: Encap and AuthEncap now have the same output size for `zz`. Before, AuthEncap's `zz` had double the size of Encap's `zz`.",
              "createdAt": "2020-03-06T17:14:47Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDkxMTE5",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T17:16:19Z",
          "updatedAt": "2020-03-06T17:16:19Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Interesting -- does that affect analysis?",
              "createdAt": "2020-03-06T17:16:19Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDk0NzMw",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T17:22:02Z",
          "updatedAt": "2020-03-06T17:22:02Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Not so much I'd say \u2013 it makes analysis of Extract a bit easier because it's input length has one case distinction less.",
              "createdAt": "2020-03-06T17:22:02Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NzM0NTA2",
          "commit": {
            "abbreviatedOid": "d8eda21"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T19:04:20Z",
          "updatedAt": "2020-03-23T19:09:23Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "It seems like it might be worth defining a different length, say `Ndh` for this, since there are definitely schemes where the shared secret is not of length `Npk`.",
              "createdAt": "2020-03-23T19:04:20Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 32,
              "body": "I wonder if it would be simplest to do something like the following\r\n\r\n```\r\ndef LabeledExtract(salt, label, secret):\r\n    labeledSecret = concat(\"RFC XXXX\", label, secret)  \r\n    return Extract(salt, labeledSecret)\r\n```\r\n\r\nThis is what TLS 1.3 does to make sure the general label gets added everywhere.",
              "createdAt": "2020-03-23T19:08:26Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 32,
              "body": "Is there a reason to attach the label to the secret vs. the salt?",
              "createdAt": "2020-03-23T19:08:54Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNDg3NzY3",
          "commit": {
            "abbreviatedOid": "d8eda21"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-24T16:31:26Z",
          "updatedAt": "2020-03-24T16:31:27Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "> Is there a reason to attach the label to the secret vs. the salt?\r\n\r\nThe goal of the label in the end is to separate the input domains of all HMAC calls. This concerns Extract and Expand. The three Expand calls for key, nonce, exporter_secret already have the label as prefix of the second argument, and that's why it's in the second argument for Extract, too (and thus attached to the secret/IKM).",
              "createdAt": "2020-03-24T16:31:26Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzc2OTAw",
          "commit": {
            "abbreviatedOid": "710c89c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-24T23:57:09Z",
          "updatedAt": "2020-03-24T23:57:09Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "> I wonder if it would be simplest to do something like the following [\u2026]\r\n> This is what TLS 1.3 does to make sure the general label gets added everywhere.\r\n\r\nUps, I forgot that in my recent update. I'll first write some comments to what I did there, and later try to incorporate this suggestions.",
              "createdAt": "2020-03-24T23:57:09Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMDg1OTgx",
          "commit": {
            "abbreviatedOid": "710c89c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T12:06:35Z",
          "updatedAt": "2020-03-25T12:06:36Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Is this correct for the 12-letter UTF-8 string literal \u201cRFCXXXX HPKE\u201d?",
              "createdAt": "2020-03-25T12:06:36Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMzcyNjU3",
          "commit": {
            "abbreviatedOid": "710c89c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the update! This is heading in the right direction. I don't love the notation `Hash_kem` etc, though I don't have a better suggestion off hand. I'd also like to see motivating text for PSK length recommendations moved to the security considerations as per #59. Would that be OK?",
          "createdAt": "2020-03-25T17:24:48Z",
          "updatedAt": "2020-03-25T17:42:20Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Let's treat it as an ASCII string, in which case, yes!",
              "createdAt": "2020-03-25T17:24:49Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 167,
              "body": "```suggestion\r\n    uint8 identifier[12] = \"RFCXXXX HPKE\";\r\n```",
              "createdAt": "2020-03-25T17:25:03Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 46,
              "body": "Re-defining this is somewhat confusing -- is it needed? ",
              "createdAt": "2020-03-25T17:26:30Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 40,
              "body": "Can we define `Ndh` on its own line? (I missed it the first time around.) Is it even needed?",
              "createdAt": "2020-03-25T17:28:08Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 67,
              "body": "```suggestion\r\n  prk = Extract_kem(0, concat(label_dh, dh))\r\n```",
              "createdAt": "2020-03-25T17:29:01Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\n  prk = Extract_kem(0, concat(label_dh, dh))\r\n```",
              "createdAt": "2020-03-25T17:29:10Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 95,
              "body": "```suggestion\r\n  prk = Extract_kem(0, concat(label_dh, dh))\r\n```",
              "createdAt": "2020-03-25T17:29:20Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 109,
              "body": "```suggestion\r\n  prk = Extract_kem(0, concat(label_dh, dh))\r\n```",
              "createdAt": "2020-03-25T17:29:30Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 187,
              "body": "Can we pull the text from #59 and place it here? (And move the next paragraph to the security considerations as is done in #59?)",
              "createdAt": "2020-03-25T17:30:29Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 243,
              "body": "```suggestion\r\n## Domain Separation\r\n```\r\n\r\n... since Random Oracle Cloning isn't a widely used term yet.",
              "createdAt": "2020-03-25T17:32:39Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 256,
              "body": "```suggestion\r\nFuture KEM instantiations MUST ensure that all internal hash function invocations are prefixed with a unique label similar to `\"RFCXXXX DHKEM\"`. This ensures they can be modeled as a function independent from `Hash`.\r\n```",
              "createdAt": "2020-03-25T17:34:57Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nThen we can construct a KEM called `DHKEM(Group, Hash_kem)` in the\r\nfollowing way, where `Group` denotes the Diffie-Hellman group and\r\n`Hash_kem` the hash function underlying KDF_kem:\r\n```",
              "createdAt": "2020-03-25T17:37:32Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 67,
              "body": "These lines (prk = ..., zz = ...) are the same across all variants. Can we pull them out into a common function that takes `dh`, `context_kem` as input?\r\n\r\n```\r\ndef ExtractAndExpand(dh, prk):\r\n   prk = Extract_kem(0, concat(\"RFCXXXX DHKEM\", dh))\r\n   zz  = Expand_kem(prk, concat(\"prk\", context_kem), Nzz)\r\n```\r\n\r\nThen call like so:\r\n\r\n```\r\ndef Encap(pkR):\r\n   ...\r\n   zz = ExtractAndExpand(dh, context_kem)\r\n   return zz, enc\r\n```",
              "createdAt": "2020-03-25T17:41:49Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMTA1NDU4",
          "commit": {
            "abbreviatedOid": "710c89c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T15:09:04Z",
          "updatedAt": "2020-03-26T15:09:05Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "We also redefine GenerateKeyPair, DH, Marshal, Unmarshal to make their definitions adapted to DHKEM. With the line about Nzz I want to make clear that Nzz is the length of Hash_kem's output. This is only implicitly clear by seeing that the result of Expand is returned.\r\n\r\nIt's true that this (Nzz is the length of Hash_kem's output) is true for our variants of DHKEM with SHA2. But now that I included Nzz as third argument to Expand, other settings are also possible.\r\n\r\nSo maybe we could move this line away from the definitions list and put it as a comment below the pseudo-code, saying that for our specified versions of DHKEM, Nzz is Hash_kem's output length. What do you think about that?",
              "createdAt": "2020-03-26T15:09:04Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMTA4MzM5",
          "commit": {
            "abbreviatedOid": "710c89c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T15:11:48Z",
          "updatedAt": "2020-03-26T15:11:48Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "This was a suggestion by @bifurcation, with the background that there might be a DH scheme where the result of the DH operation is not an encoded public key.\r\n\r\nWe can move it to it's own line I think.",
              "createdAt": "2020-03-26T15:11:48Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjY2MTE5",
          "commit": {
            "abbreviatedOid": "e074762"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T17:55:41Z",
          "updatedAt": "2020-03-26T17:59:51Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> So maybe we could move this line away from the definitions list and put it as a comment below the pseudo-code, saying that for our specified versions of DHKEM, Nzz is Hash_kem's output length. What do you think about that?\r\n\r\nThat'd be great!",
              "createdAt": "2020-03-26T17:55:41Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjc2NDA3",
          "commit": {
            "abbreviatedOid": "8790927"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-03-26T18:05:50Z",
          "updatedAt": "2020-03-26T18:13:50Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nThe adversary can use different oracles to decide if a PSK guess was correct,\r\n```",
              "createdAt": "2020-03-26T18:05:50Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 88,
              "body": "```suggestion\r\nthe adversary can use decryption of the ciphertext as oracle. HPKE ciphertexts are\r\n```",
              "createdAt": "2020-03-26T18:06:35Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 87,
              "body": "In this scenario, the adversary didn't guess the PSK value, so I don't think it's a relevant example.",
              "createdAt": "2020-03-26T18:09:15Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 97,
              "body": "```suggestion\r\nScenarios in which the adversary knows the KEM shared secret zz\r\n```",
              "createdAt": "2020-03-26T18:09:32Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 103,
              "body": "```suggestion\r\nknows all private keys of one participant. \r\n```\r\n\r\nI recommend deleting these examples as knowledge of all private keys of one participant is adequate. ",
              "createdAt": "2020-03-26T18:13:30Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjk1MDky",
          "commit": {
            "abbreviatedOid": "5a59b51"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:27:07Z",
          "updatedAt": "2020-03-26T18:27:07Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "The adversary can try decryption for each PSK value it wants to guess. This is an example of a passive adversary. Would replacing \u201con observation of an HPKE ciphertext\u201d by \u201cwith a captured HPKE ciphertext\u201d make this clearer?",
              "createdAt": "2020-03-26T18:27:07Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjk3MzAz",
          "commit": {
            "abbreviatedOid": "5a59b51"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:29:46Z",
          "updatedAt": "2020-03-26T18:29:47Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "If the adversary doesn't have access to the ephemeral or private shares, this isn't possible, right? ",
              "createdAt": "2020-03-26T18:29:46Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNzgwOTk5",
          "commit": {
            "abbreviatedOid": "f9c99c9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T11:36:08Z",
          "updatedAt": "2020-03-27T11:36:08Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "Is it ok to use the already defined `len()` for the psk?\r\n```\r\n- `len(x)`: The length of the byte string `x`, expressed as a\r\n  two-byte unsigned integer in network (big-endian) byte order\r\n```\r\nFor now `len()` is only used to get the length of the nonce:\r\n```\r\ndef Context.Nonce(seq):\r\n  encSeq = encode_big_endian(seq, len(self.nonce))\r\n  return xor(self.nonce, encSeq)\r\n```\r\nBy the way, why compute the length of the nonce here? We know that it has length `Nn`. Also, why does encode_big_endian apparently need the length in \u201cnetwork (big-endian) byte order\u201d and as two-byte integer?",
              "createdAt": "2020-03-27T11:36:08Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTY3NTE2",
          "commit": {
            "abbreviatedOid": "f9c99c9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T15:33:46Z",
          "updatedAt": "2020-03-27T15:33:47Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "Yep, it's fine, and preferred! We pass a length in case the resulting number needs to be padded with zeros.",
              "createdAt": "2020-03-27T15:33:47Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTY5MTU2",
          "commit": {
            "abbreviatedOid": "7e98278"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T15:35:34Z",
          "updatedAt": "2020-03-27T15:35:34Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-03-27T15:35:34Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTcyMzk5",
          "commit": {
            "abbreviatedOid": "7e98278"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T15:39:13Z",
          "updatedAt": "2020-03-27T15:39:14Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nBy design, the calls to Extract and Expand inside DHKEM and the remainder of HPKE \r\nhave different prefix-free encodings for the second parameter. This is achieved by the \r\ndifferent prefix-free label parameters in the calls to LabeledExtract and LabeledExpand. \r\nThis serves to separate all Extract and Expand invocation input domains. It also justifies \r\nmodeling them as independent functions even if instantiated by the same KDF.\r\n```",
              "createdAt": "2020-03-27T15:39:14Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTc0OTg0",
          "commit": {
            "abbreviatedOid": "7e98278"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T15:42:11Z",
          "updatedAt": "2020-03-27T15:42:12Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nin HPKE's Extract or Expand, such as Hash in the case of HKDF. Inputs to these\r\ninvocations MUST apply domain separation such that they cannot collide\r\nwith inputs used inside Extract or Expand.\r\n```",
              "createdAt": "2020-03-27T15:42:11Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTc1MjE0",
          "commit": {
            "abbreviatedOid": "7e98278"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T15:42:27Z",
          "updatedAt": "2020-03-27T15:42:28Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nThe string literal \"RFCXXXX\" used in LabeledExtract and LabeledExpand\r\n```",
              "createdAt": "2020-03-27T15:42:27Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTc1NjYz",
          "commit": {
            "abbreviatedOid": "1cf2e52"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with the pending suggestions -- thanks, @blipp!",
          "createdAt": "2020-03-27T15:42:57Z",
          "updatedAt": "2020-03-27T15:42:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMTA1MDE5",
          "commit": {
            "abbreviatedOid": "5ba9148"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T18:27:50Z",
          "updatedAt": "2020-03-27T18:27:50Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "(I don't know why but it's marked as outdated for me, already before my most recent commit)\r\nI applied the suggestions with the \u201csuch\u201d and \u201cthe\u201d. Domain separation is not the solution here because we cannot change the inputs to the internal invocations.",
              "createdAt": "2020-03-27T18:27:50Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0ODk0NjE4",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is on the right track, but needs some tweaks.\r\n",
          "createdAt": "2020-03-31T16:17:03Z",
          "updatedAt": "2020-03-31T16:39:14Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Nit: I would remove the `_` here.",
              "createdAt": "2020-03-31T16:17:04Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 33,
              "body": "Is there a reason to put the label on the IKM vs. the salt?",
              "createdAt": "2020-03-31T16:17:16Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 31,
              "body": "You use `0` for the salt value several times below.  It would be good to clarify whether that means (a) an all-zero octet string (and if so, what length), or (b) the empty octet string.",
              "createdAt": "2020-03-31T16:23:30Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 108,
              "body": "Nit: Suggest `kemContext`",
              "createdAt": "2020-03-31T16:24:56Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 129,
              "body": "Do we have guidance on what the right answer is?",
              "createdAt": "2020-03-31T16:27:30Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 11,
              "body": "Can we get rid of `Hash()` now?",
              "createdAt": "2020-03-31T16:29:20Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 288,
              "body": "What does \"respectively\" mean here?  If you mean that they are each individually indifferentiable, I would phrase as \"Each function is individually indifferentiable from a random oracle\".",
              "createdAt": "2020-03-31T16:32:57Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 288,
              "body": "I assume this bullet and the next one are supposed to be \"KDF used in DHKEM\" and \"KDF used in the rest of HPKE\"?  If so, let's just say that.  Something like:\r\n\r\n```\r\n- Extract and Expand (in DHKEM): ...\r\n- Extract and Expand (elsewhere): ...\r\n```",
              "createdAt": "2020-03-31T16:34:07Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 310,
              "body": "\"In the PSK and AuthPSK modes, ...\"",
              "createdAt": "2020-03-31T16:34:37Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 323,
              "body": "How does Seal/Open prevent this?  If you behave differently on decryption failure, then it seems like you still create an oracle.  ",
              "createdAt": "2020-03-31T16:35:57Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 329,
              "body": "What do you mean by \"it is enough\"?  Also, I don't understand the dependency on DHKEM here.",
              "createdAt": "2020-03-31T16:38:19Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 166,
              "body": "Why do we need this explicit hashing step?  Shouldn't the internals of `LabeledExtract` handle that for us?",
              "createdAt": "2020-03-31T16:38:59Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTQ5MDc5",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T17:24:53Z",
          "updatedAt": "2020-03-31T17:24:54Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "In the end, the goal of the label is to separate the input domains of all HMAC calls. This concerns both Extract and Expand. The three Expand calls for key, nonce, exporter_secret already have a label as prefix of the second argument, and that's why it's in the second argument for Extract, too (and thus attached to the IKM).",
              "createdAt": "2020-03-31T17:24:53Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTUzODky",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T17:31:06Z",
          "updatedAt": "2020-03-31T17:31:07Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "In this pull request, I suggest one particular KDF for each of DHKEM's DH groups. This recommendation is based on the security level of the DH group. We could include as guidance that choosing the same KDF for the remainder of KDF is the best trade-of: this keeps the security level of DHKEM while not pretending a higher security level by using a KDF with greater output length.\r\n\r\nDoes this go into the direction you meant to go with your question?",
              "createdAt": "2020-03-31T17:31:06Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTU1MTc1",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T17:32:52Z",
          "updatedAt": "2020-03-31T17:32:52Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I also had this thought but didn't follow it yet, thanks for bringing it up. I think we can get rid of Hash. I'll have a look where in the spec this would need adjustment.",
              "createdAt": "2020-03-31T17:32:52Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTU3NTI3",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T17:36:00Z",
          "updatedAt": "2020-03-31T17:36:01Z",
          "comments": [
            {
              "originalPosition": 288,
              "body": "Ups, sorry that one slipped through after removing the `_kem` suffix. Yes, it means \u201cEach function [\u2026]\u201d.",
              "createdAt": "2020-03-31T17:36:00Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTY0MTUz",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T17:44:51Z",
          "updatedAt": "2020-03-31T17:44:52Z",
          "comments": [
            {
              "originalPosition": 323,
              "body": "New proposal:\r\n\r\nThus, HPKE's PSK mechanism is not suitable for use with a low-entropy\r\npassword as the PSK: in scenarios in which the adversary knows the\r\nKEM shared secret zz and has access to an oracle that allows to distinguish\r\nbetween a good and a wrong key, it can perform a dictionary attack on the PSK.\r\nThis oracle can be the decryption operation on a captured HPKE ciphertext or\r\nany other recipient behavior which is observably different when using a wrong key.",
              "createdAt": "2020-03-31T17:44:51Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTcyNzE3",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T17:56:14Z",
          "updatedAt": "2020-03-31T17:56:14Z",
          "comments": [
            {
              "originalPosition": 329,
              "body": "The adversary knows the KEM shared secret zz in certain compromise scenarios. We were hesitant to make a general claim about compromise scenarios with a general KEM. But maybe it's actually possible. Have to think about it.\r\n\r\nThe \u201cenough\u201d because people could think that for DHKEM's AuthPSK it is not enough to know only the recipient's private static key, but that knowing the sender's private static key is also necessary; because of key-compromise impersonation this is not the case. We could do without the \u201cenough\u201d and say \u201cFor DHKEM this is the case if the adversary knows all private keys of one participant\u201d.",
              "createdAt": "2020-03-31T17:56:14Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTc4NjIw",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T18:04:11Z",
          "updatedAt": "2020-03-31T18:04:11Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Are you suggesting that this `if` should be inside LabeledExtract? This is the only place where we give an arbitrary-length bitstring as the first parameter to (Labeled)Extract, so maybe it's wasteful to have the branching every time (even for all the calls with 0 as first parameter)? If you say you prefer this to have a cleaner KeySchedule, I think I could agree.\r\n\r\nJust in case: Have you seen my earlier comment? It might have been buried within this long discussion, so let me cite:\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50#issuecomment-603568796\r\n\r\n> On the PSK length:\r\n> \r\n> HMAC(K, M) feeds K through a call to Hash if K is longer than Hash's blocksize. If we allow arbitrary-size PSKs for user convenience, this would introduce another place where Hash is called on arbitrary-sized input, just like with info and pskID. (As a reminder: Arbitrary-sized input to Hash can lead to collisions with input to Hash calls inside HMAC. This would render the proof inapplicable that proves indifferentiability of HMAC from a random oracle. To avoid collisions, we use Extract calls and separate the input domains by using a prefix).\r\n> \r\n> To avoid this extra Hash call inside HMAC, we can just anticipate it directly in KeySchedule, and thus control the prefix. While this introduces branching inside KeySchedule, this branching would either way be done inside HMAC. Doing the Extract call even if the PSK is shorter then Nb would hurt performance in non-PSK modes, too.\r\n\r\n",
              "createdAt": "2020-03-31T18:04:11Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTgwNDI1",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "(Github said: \u201cYou need to leave a comment indicating the requested changes.\u201d, so I just copied this text here)",
          "createdAt": "2020-03-31T18:06:43Z",
          "updatedAt": "2020-03-31T18:07:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NDkxMjIw",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-02T14:37:19Z",
          "updatedAt": "2020-04-02T14:37:19Z",
          "comments": [
            {
              "originalPosition": 329,
              "body": "For a \u201cgood or bad PSK\u201d oracle, knowing the secrets of _one_ party is enough because: Each one of the two parties involved in HPKE must be able to decrypt a message, and each party only knows its own secrets.\r\n\r\nI will rephrase the paragraph accordingly.",
              "createdAt": "2020-04-02T14:37:19Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MjMzOTQz",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-03T13:02:22Z",
          "updatedAt": "2020-04-03T13:02:22Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "I am reading specs of Keccak and Blake2/3 to see if they do internal hashing in their KDF/XOF modes that could collide with a Hash call inside HPKE. This `len > Nb` step is very specific to HMAC, and people might implement Extract and Expand with something different. So maybe we can come up with a more general statement here instead of hardcoding support for HMAC.",
              "createdAt": "2020-04-03T13:02:22Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NDQ3NDA4",
          "commit": {
            "abbreviatedOid": "8a2d43c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-03T17:28:20Z",
          "updatedAt": "2020-04-03T17:31:31Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Right, I was thinking that in the HKDF case, this duplicated what HMAC was doing internally.  If there's nothing current that is doing something that would collide, I would suggest we remove this, and maybe add a note about the assumption we're making about the KDF (no internal hashing that could collide).",
              "createdAt": "2020-04-03T17:28:21Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 323,
              "body": "Works for me, thanks.",
              "createdAt": "2020-04-03T17:30:06Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 329,
              "body": "I see.  I think I misunderstood the \"Scenaris where the adversary knows zz\" above.  With your new text above, it's clearer.",
              "createdAt": "2020-04-03T17:31:24Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMDgyMDg2",
          "commit": {
            "abbreviatedOid": "8a2d43c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T15:24:59Z",
          "updatedAt": "2020-04-08T15:25:00Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "In commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/e7313ea2845c72a543dcc32f1eb2be99acb2d9d9, I chose to make explicit what HKDF-Extract would do by default, by using `zero(Nh)`.",
              "createdAt": "2020-04-08T15:25:00Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTA2NTU5",
          "commit": {
            "abbreviatedOid": "1c84680"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T15:52:11Z",
          "updatedAt": "2020-04-08T15:52:11Z",
          "comments": [
            {
              "originalPosition": 329,
              "body": "To everyone: I attempted to clarify this in commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/1c84680727de94679dcf1f96c7c401a0cc8178b8, please let me know if you think this works. I decided to attach this to the previous paragraph, because it kind of belongs to it; please let me know if you like that.",
              "createdAt": "2020-04-08T15:52:11Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTM0MTgz",
          "commit": {
            "abbreviatedOid": "1c84680"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T16:24:15Z",
          "updatedAt": "2020-04-08T16:24:16Z",
          "comments": [
            {
              "originalPosition": 329,
              "body": "This reads well to me. Thanks for clarifying, @blipp!",
              "createdAt": "2020-04-08T16:24:16Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTM2NDMz",
          "commit": {
            "abbreviatedOid": "1c84680"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T16:27:07Z",
          "updatedAt": "2020-04-08T16:27:08Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "@bifurcation this isn't quite duplicating what HMAC is doing internally, since it explicitly prefixes the input before hashing.",
              "createdAt": "2020-04-08T16:27:07Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjIwMzkw",
          "commit": {
            "abbreviatedOid": "421828d"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T18:20:46Z",
          "updatedAt": "2020-04-08T18:20:46Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "With commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/421828db601168b9f81acc6d299754e477e4d10a, the PSK is now always fed through LabeledExtract. I included my reasoning in the commit message. Please let me know if that makes sense to you.",
              "createdAt": "2020-04-08T18:20:46Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjIyMzg4",
          "commit": {
            "abbreviatedOid": "421828d"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T18:23:29Z",
          "updatedAt": "2020-04-08T18:23:30Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "An alternative to feeding the PSK always through LabeledExtract is to restrict the PSK to a fixed length, for example to Nh.",
              "createdAt": "2020-04-08T18:23:30Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjIzNjg1",
          "commit": {
            "abbreviatedOid": "421828d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T18:25:15Z",
          "updatedAt": "2020-04-08T18:25:16Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-04-08T18:25:15Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjI1OTUy",
          "commit": {
            "abbreviatedOid": "8772378"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T18:28:21Z",
          "updatedAt": "2020-04-08T18:28:22Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Removed Hash (and Nb) with commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/877237816152d2a58dc866bba1c9e12b3c4a5a93.",
              "createdAt": "2020-04-08T18:28:21Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjMyNTA2",
          "commit": {
            "abbreviatedOid": "fbea8c0"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T18:37:11Z",
          "updatedAt": "2020-04-08T18:37:11Z",
          "comments": [
            {
              "originalPosition": 288,
              "body": "Addressed in commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/fbea8c041a50b6db3a458b7c2cdefa4cdb1014e8.",
              "createdAt": "2020-04-08T18:37:11Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjk2Mzk0",
          "commit": {
            "abbreviatedOid": "09acc77"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T20:12:47Z",
          "updatedAt": "2020-04-08T20:12:48Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "If someone implements Extract and Expand with something else than HKDF, like a modern hash function's KDF and XOF modes, then this PSK hashing step is probably not needed. I attempted a formulation with commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/09acc770c7604185836085499b7284dcfa0568a8.",
              "createdAt": "2020-04-08T20:12:47Z",
              "updatedAt": "2020-04-08T20:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNjUwNzA5",
          "commit": {
            "abbreviatedOid": "09acc77"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-10T20:31:16Z",
          "updatedAt": "2020-04-10T20:31:16Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8d1a29a3dffd46a3cc69d315e5dfe58a74961774",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_dhkem",
      "headRefOid": "09acc770c7604185836085499b7284dcfa0568a8",
      "mergeCommit": {
        "oid": "916823a65f4cbf1f7f0918f96fd6062968f06d68"
      }
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1NjQ0NjEw",
      "title": "Clarify KeySchedule inputs: it's an encoded public key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/51",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-09T15:09:51Z",
      "updatedAt": "2020-03-09T16:11:29Z",
      "closedAt": "2020-03-09T16:08:52Z",
      "mergedAt": "2020-03-09T16:08:52Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, deleted the default for pskID being zero(0) because for info it's also just defined as \"\".",
          "createdAt": "2020-03-09T15:13:15Z",
          "updatedAt": "2020-03-09T15:13:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMjc3MjEw",
          "commit": {
            "abbreviatedOid": "4de3de8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-03-09T15:20:48Z",
          "updatedAt": "2020-03-09T15:20:53Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n* `pskID` - An identifier for the PSK (optional; default value `zero(0)`)\r\n```",
              "createdAt": "2020-03-09T15:20:49Z",
              "updatedAt": "2020-03-09T15:50:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMjc5MjIw",
          "commit": {
            "abbreviatedOid": "4de3de8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T15:23:03Z",
          "updatedAt": "2020-03-09T15:23:03Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "That works as well. I would change it for `info` as well then, to zero(0)?",
              "createdAt": "2020-03-09T15:23:03Z",
              "updatedAt": "2020-03-09T15:50:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMjkxMDQy",
          "commit": {
            "abbreviatedOid": "4de3de8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T15:36:18Z",
          "updatedAt": "2020-03-09T15:36:18Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Well, pskID is an opaque byte string and has a default value in the pseudocode (`zero(0)`), whereas `info` is traditionally considered to be a UTF8-encoded string. Maybe we could clarify that instead?  @bifurcation, penny for your thoughts?",
              "createdAt": "2020-03-09T15:36:18Z",
              "updatedAt": "2020-03-09T15:50:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMjk3ODI0",
          "commit": {
            "abbreviatedOid": "4de3de8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T15:43:48Z",
          "updatedAt": "2020-03-09T15:43:48Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Ah you are right, I forgot about the default for pskID. Given that, I like your suggestion to have zero(0) for pskID and \"\" for info.",
              "createdAt": "2020-03-09T15:43:48Z",
              "updatedAt": "2020-03-09T15:50:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzE4OTk0",
          "commit": {
            "abbreviatedOid": "ecede56"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-09T16:08:18Z",
          "updatedAt": "2020-03-09T16:08:18Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "a025ae8aa80bcdc5065f5a25cf93bb971582bcfc",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_key_schedule_inputs",
      "headRefOid": "ecede56bd01859b652cb8fef9eccb0f195897b25",
      "mergeCommit": {
        "oid": "72f04cd7eb0138de86300d305d516a82d7d638bd"
      }
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg3NTI5NDA2",
      "title": "Add self as author.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/54",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-13T00:09:51Z",
      "updatedAt": "2020-03-13T20:32:50Z",
      "closedAt": "2020-03-13T20:32:50Z",
      "mergedAt": "2020-03-13T20:32:50Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "72f04cd7eb0138de86300d305d516a82d7d638bd",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/author",
      "headRefOid": "77a32fd23c210fb9eb6bf7d8770617f37efde9fc",
      "mergeCommit": {
        "oid": "ea4494566f7d2ef764b27ae36af2837415a46ef6"
      }
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxNDYyMzE1",
      "title": "Reference revision 3 of NIST.SP.800-56A (and insert newlines to make .md more readable on Github)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/55",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There is revision 3 of NIST.SP.800-56A since a while. Is there a specific reason why revision 2 is referenced? If not then this pull request proposes to change the reference to revision 3.\r\n\r\nI did /not/ check if, for example, broadly-deployed implementations are not yet implementing revision 3.",
      "createdAt": "2020-03-20T10:43:06Z",
      "updatedAt": "2020-03-20T14:37:28Z",
      "closedAt": "2020-03-20T14:36:58Z",
      "mergedAt": "2020-03-20T14:36:58Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "None that I'm aware of. We can always change to revision 3 if folks tell us otherwise!",
          "createdAt": "2020-03-20T14:37:28Z",
          "updatedAt": "2020-03-20T14:37:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NTM4MTk4",
          "commit": {
            "abbreviatedOid": "30c4527"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-20T14:36:47Z",
          "updatedAt": "2020-03-20T14:36:47Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "ea4494566f7d2ef764b27ae36af2837415a46ef6",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_56ar3",
      "headRefOid": "30c452723e2804d15312291c95ac416d06df6039",
      "mergeCommit": {
        "oid": "1674f75832d0f633119f1f5f032ad340a47b6ce0"
      }
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxNTE1MDM5",
      "title": "Clarify key validation, as it is different for NIST curves and Curve25519/448",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/56",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Points to discuss:\r\n\r\n- I made this proposal with \u201cMAY check whether the shared secret is the all-zero value\u201d for Curve25519/448 because this how the RFC states it. We can discuss if HPKE should be more opinionated on it\r\n- I shortened the discussion of validation in Section \u201cCreating the Encryption Context\u201d and instead link to {{kem-ids}}. I added the more or less same paragraph to Section \u201cDH-Based KEM\u201d because that is where DHKEM is actually defined. We can discuss if one of the two places is enough to mention validation.",
      "createdAt": "2020-03-20T12:50:14Z",
      "updatedAt": "2020-03-23T15:45:50Z",
      "closedAt": "2020-03-23T15:45:50Z",
      "mergedAt": "2020-03-23T15:45:50Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NTQwMjc1",
          "commit": {
            "abbreviatedOid": "5133b33"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-03-20T14:39:15Z",
          "updatedAt": "2020-03-20T14:40:26Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nFor authenticated modes the same validation MUST be done for the static\r\n```",
              "createdAt": "2020-03-20T14:39:15Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            },
            {
              "originalPosition": 17,
              "body": "We lost this recommendation (check `pkR`) in the new text. Can we bring it back?",
              "createdAt": "2020-03-20T14:39:56Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NjI1MTQ2",
          "commit": {
            "abbreviatedOid": "22787c2"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-20T16:17:18Z",
          "updatedAt": "2020-03-20T16:17:19Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Please let me know if you think this is addressed by my most recent change.",
              "createdAt": "2020-03-20T16:17:19Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4OTM4OTgz",
          "commit": {
            "abbreviatedOid": "22787c2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Couple more nits!",
          "createdAt": "2020-03-21T18:12:24Z",
          "updatedAt": "2020-03-21T18:13:07Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Can we move the text from \"The sender MUST...\" to the end of this paragraph to its own paragraph? By folding this into the paragraph specific to NIST curves, it might read as though it only applies to NIST curves, which is not the intent.",
              "createdAt": "2020-03-21T18:12:24Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nSenders and recipients MUST validate KEM inputs and outputs as described\r\n```",
              "createdAt": "2020-03-21T18:12:49Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nSenders and recipients MUST validate KEM inputs and outputs as described\r\n```",
              "createdAt": "2020-03-21T18:12:59Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NDE5MDY4",
          "commit": {
            "abbreviatedOid": "ce6ad5b"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T13:19:14Z",
          "updatedAt": "2020-03-23T13:19:15Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I am not sure how to deal with this, so I'll lay out what my current view is: In the current version of HPKE, there is only NIST curves and Curve25519/448. Public key validation applies for the NIST curves but not for Curve25519/448. Which means in this context, it applies only to NIST curves.",
              "createdAt": "2020-03-23T13:19:14Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NTEyOTEw",
          "commit": {
            "abbreviatedOid": "ce6ad5b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T14:59:42Z",
          "updatedAt": "2020-03-23T14:59:42Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "This seems to be conflating two things: what curves require validation, and what keys are validated. I think we should separate these two. (I also think we should validate curve25519 and curve448 points, too, as the previous text suggested.)",
              "createdAt": "2020-03-23T14:59:42Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NTU3ODYy",
          "commit": {
            "abbreviatedOid": "8aa9439"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Much better -- thanks!",
          "createdAt": "2020-03-23T15:45:04Z",
          "updatedAt": "2020-03-23T15:45:04Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "ea4494566f7d2ef764b27ae36af2837415a46ef6",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_curves",
      "headRefOid": "8aa9439e4400f78f142ee8f72aeb8a13d532cd6c",
      "mergeCommit": {
        "oid": "b3baa62ce8b603ec60553cb728ba92e30c34924b"
      }
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxNTgwNTM2",
      "title": "Clarified endianness of ciphersuite serialization",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/57",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This was an ambiguity. `concat` is only defined for bytestrings, but the ciphersuite identifiers are all u16. Since everything else is big-endian, it makes sense for this to be big-endian as well.",
      "createdAt": "2020-03-20T15:03:16Z",
      "updatedAt": "2020-03-23T15:46:03Z",
      "closedAt": "2020-03-23T15:46:03Z",
      "mergedAt": "2020-03-23T15:46:03Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NjAwMzY5",
          "commit": {
            "abbreviatedOid": "7996c02"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "cc @bifurcation ",
          "createdAt": "2020-03-20T15:48:12Z",
          "updatedAt": "2020-03-20T15:48:12Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "1674f75832d0f633119f1f5f032ad340a47b6ce0",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "master",
      "headRefOid": "7996c0232eeec6eb6d8803b477d19368721f153b",
      "mergeCommit": {
        "oid": "bf47c4c73e825839fa7d506ce709f32a593e9a48"
      }
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkyNDcwODQ5",
      "title": "Add missing 'not' for Curve25519/448",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/58",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-23T15:52:36Z",
      "updatedAt": "2020-03-23T15:54:03Z",
      "closedAt": "2020-03-23T15:54:03Z",
      "mergedAt": "2020-03-23T15:54:03Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NTY2ODMx",
          "commit": {
            "abbreviatedOid": "f0b91b6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-23T15:53:56Z",
          "updatedAt": "2020-03-23T15:53:56Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "bf47c4c73e825839fa7d506ce709f32a593e9a48",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "f0b91b68c56999574c80e0f2503c3ea296321521",
      "mergeCommit": {
        "oid": "8d1a29a3dffd46a3cc69d315e5dfe58a74961774"
      }
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkyNjE5NDc5",
      "title": "Recommend minimum length for PSKs.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/59",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @blipp ",
      "createdAt": "2020-03-23T20:22:16Z",
      "updatedAt": "2020-03-26T18:19:00Z",
      "closedAt": "2020-03-26T18:17:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp @bifurcation fixed -- please have a look! If you're OK with the text, can we move it to #50?",
          "createdAt": "2020-03-25T00:40:53Z",
          "updatedAt": "2020-03-25T00:45:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #50.",
          "createdAt": "2020-03-26T18:17:06Z",
          "updatedAt": "2020-03-26T18:17:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODM2NjUy",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T21:29:17Z",
          "updatedAt": "2020-03-23T21:29:25Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Is this actually true?  How would such a dictionary attack be mounted without access to either the ephemeral private key or the recipient private key?",
              "createdAt": "2020-03-23T21:29:17Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODM3NTgz",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T21:30:50Z",
          "updatedAt": "2020-03-23T21:30:50Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Say a given client and server have a low entropy PSK k. The adversary can search for it by sending messages to the server, with test PSKs, and seeing which of those are decrypted successfully or not.",
              "createdAt": "2020-03-23T21:30:50Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODQ0NDA3",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T21:42:32Z",
          "updatedAt": "2020-03-23T21:42:33Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Hm, that seems like an oracle provided by a higher-layer protocol, not by HPKE.",
              "createdAt": "2020-03-23T21:42:33Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODUwNTMy",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T21:53:33Z",
          "updatedAt": "2020-03-23T21:53:34Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Is it? (Either way, we should probably say *something* about it, right?) What text would you propose?",
              "createdAt": "2020-03-23T21:53:33Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzUzMDA0",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-24T22:53:27Z",
          "updatedAt": "2020-03-24T22:53:28Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I think a dictionary attack would only be feasible if the adversary already knows the KEM keys, like the ephemeral and the static key(s). Then the adversary can use the decryption of the authenticated encryption as an oracle: it fails if the key is not correct.\r\n\r\nA quantum adversary could for example know all KEM keys of a classic (non-post-quantum) KEM, but not the PSK, and then mount this attack.\r\n\r\nHowever, the statement about low-entropy PSKs depends on the employed KDF algorithm. At this place in the spec, the definitions are still rather general. Only later it becomes obvious that HPKE is specified with HKDF and SHA2. HKDF's RFC clearly states that it is not designed to slow down dictionary attacks [1].\r\n\r\n[1] https://hyp.is/xAKxmG4hEeqyB5fD4eRdUQ/tools.ietf.org/html/rfc5869",
              "createdAt": "2020-03-24T22:53:28Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzY5ODEw",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-24T23:36:26Z",
          "updatedAt": "2020-03-24T23:36:27Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Yes, in the example I gave, the adversary is active and knows the sender ephemeral keys.",
              "createdAt": "2020-03-24T23:36:27Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzc1ODM5",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-24T23:54:00Z",
          "updatedAt": "2020-03-24T23:54:01Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "As discussed with @chris-wood off-channel yesterday, I folded this into pull request #50 and make a proposal for a text there.",
              "createdAt": "2020-03-24T23:54:00Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjc4NTY3",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:07:30Z",
          "updatedAt": "2020-03-26T18:07:31Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I chose a formulation different from \u201cderived from at least Nh bytes of entropy\u201d in #50 because I think deriving from Nh bytes of entropy does not mean that the result of this derivation keeps those Nh bytes of entropy. (e.g. it could be a hash of an appropriate output length for keeping the entropy but then you cut it in half)",
              "createdAt": "2020-03-26T18:07:31Z",
              "updatedAt": "2020-03-26T18:07:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjc5NDk3",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:08:39Z",
          "updatedAt": "2020-03-26T18:08:40Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I tried to find a more general formulation in #50 that considers all cases where the adversary has access to zz.",
              "createdAt": "2020-03-26T18:08:40Z",
              "updatedAt": "2020-03-26T18:08:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjgxMzQx",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:11:00Z",
          "updatedAt": "2020-03-26T18:11:00Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "I prefer not to invoke IND-CCA here because IND-CCA does not state anything about if the ciphertext reveals smth about the key. It just assumes that the key is random and secret.",
              "createdAt": "2020-03-26T18:11:00Z",
              "updatedAt": "2020-03-26T18:11:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjg1NjI2",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:16:23Z",
          "updatedAt": "2020-03-26T18:16:23Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Good point! I'm fine with the variant.",
              "createdAt": "2020-03-26T18:16:23Z",
              "updatedAt": "2020-03-26T18:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjg1OTk2",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:16:51Z",
          "updatedAt": "2020-03-26T18:16:51Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "\ud83d\udc4d  I left a comment over there.",
              "createdAt": "2020-03-26T18:16:51Z",
              "updatedAt": "2020-03-26T18:16:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjg2MDk3",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:16:59Z",
          "updatedAt": "2020-03-26T18:17:00Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "That works!",
              "createdAt": "2020-03-26T18:16:59Z",
              "updatedAt": "2020-03-26T18:17:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjg3NjY2",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:19:00Z",
          "updatedAt": "2020-03-26T18:19:00Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Actually IND-CCA is what makes the dictionary attack possible in case of a low-entropy key, because of the ciphertext integrity part of IND-CCA, which provides the (decryption failure) oracle.",
              "createdAt": "2020-03-26T18:19:00Z",
              "updatedAt": "2020-03-26T18:19:00Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8d1a29a3dffd46a3cc69d315e5dfe58a74961774",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/psk-lengths",
      "headRefOid": "b3ac918c3ccf2cb08278ccd90acbd905eec4085e",
      "mergeCommit": null
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk0Nzc1MTUy",
      "title": "Clarification on validation for NIST curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/60",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Implicitly, it might be assumed that the scalar (private key) is honestly generated and thus ensured to be in the correct interval. This proposed change makes this more explicit.",
      "createdAt": "2020-03-27T14:09:02Z",
      "updatedAt": "2020-03-30T22:54:46Z",
      "closedAt": "2020-03-30T22:54:46Z",
      "mergedAt": "2020-03-30T22:54:46Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0Mjg5NDk5",
          "commit": {
            "abbreviatedOid": "83b124e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-30T22:54:40Z",
          "updatedAt": "2020-03-30T22:54:40Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8d1a29a3dffd46a3cc69d315e5dfe58a74961774",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_validation",
      "headRefOid": "83b124e287c4df6d22392fe1bd7361e1f89e9a1c",
      "mergeCommit": {
        "oid": "8dafe8aee83c8440be7d622722474e45ccf69037"
      }
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk0OTE0OTM3",
      "title": "Simplify definition of the len function",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/61",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- We know that the length of the nonce is `Nn` because it was created with `Expand(\u2026, \u2026, Nn)`, so we don't need a dynamic computation of it.\r\n- For `len` and `zero`, clarify that the length is in bytes\r\n\r\nNow the _only_ use of `len` is when we compare the length of the PSK to `Nb` (if #50 gets merged as is):\r\n```\r\n  if len(psk) > Nb then:\r\n    psk = LabeledExtract(0, \"psk\", psk)\r\n```\r\n\r\nI suggest that in the definition of `len` we remove the part that details that the result is `expressed as two-byte unsigned integer in network (big-endian) byte order`. Arguments pro:\r\n- little-endian is the dominant ordering for processor architectures. This would mean that most implementations must do extra work to have len return big-endian, just to notice then that Nb is little-endian and that they cannot compare a big-endian value to a little-endian one.\r\n- it arbitrarily limits the PSK to 2^16 bytes\r\n- we don't specify how implementations have to store local integer values like `Nn`, `Nh`, etc so it seems overly specific to impose a certain encoding for the result of an internal function",
      "createdAt": "2020-03-27T18:44:06Z",
      "updatedAt": "2020-03-30T22:56:17Z",
      "closedAt": "2020-03-30T22:56:17Z",
      "mergedAt": "2020-03-30T22:56:17Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MjkwMTQy",
          "commit": {
            "abbreviatedOid": "3463416"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-30T22:56:12Z",
          "updatedAt": "2020-03-30T22:56:12Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8d1a29a3dffd46a3cc69d315e5dfe58a74961774",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_len",
      "headRefOid": "3463416951bf30502c71e687476883bad28fb4b6",
      "mergeCommit": {
        "oid": "cf81e410aad729da44387aefa8edd294f6d1ca0e"
      }
    },
    {
      "number": 62,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAyMzU2MjE5",
      "title": "Fix various leftover issues and update test vectors.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/62",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The new test vectors omit fields not needed by certain modes, e.g., `psk` and `pskID` are not included in non-PSK modes.\r\n\r\ncc @blipp",
      "createdAt": "2020-04-12T15:34:18Z",
      "updatedAt": "2020-04-17T14:59:07Z",
      "closedAt": "2020-04-17T14:59:07Z",
      "mergedAt": "2020-04-17T14:59:07Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMjA3Njk3",
          "commit": {
            "abbreviatedOid": "05e9d15"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Good catches with the Setup functions, thanks!",
          "createdAt": "2020-04-13T15:12:08Z",
          "updatedAt": "2020-04-13T15:18:06Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "maybe add bytes as we did in some other places? Like \u201cof fixed length `Nh` bytes\u201d, or \u201cof length `Nh` bytes\u201d",
              "createdAt": "2020-04-13T15:12:08Z",
              "updatedAt": "2020-04-13T15:22:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMjE0NDQz",
          "commit": {
            "abbreviatedOid": "05e9d15"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-13T15:21:59Z",
          "updatedAt": "2020-04-13T15:22:00Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n  - Extract(salt, IKM): Extract a pseudorandom key of fixed length `Nh` bytes\r\n```",
              "createdAt": "2020-04-13T15:21:59Z",
              "updatedAt": "2020-04-13T15:22:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NTMwMDE5",
          "commit": {
            "abbreviatedOid": "017a94d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-17T14:59:02Z",
          "updatedAt": "2020-04-17T14:59:02Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "916823a65f4cbf1f7f0918f96fd6062968f06d68",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/nits",
      "headRefOid": "017a94da26766d7b7d5ae41868230725d337714f",
      "mergeCommit": {
        "oid": "4a1a0ac3350fb837ef9b339a881dc284c07454e3"
      }
    },
    {
      "number": 63,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAyNjg3Njgz",
      "title": "Only hash PSK in the PSK and AuthPSK modes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/63",
      "state": "CLOSED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the Base and Auth modes, the only PSK ever used is the default psk, which is constant and all zero. Instead of transforming the Nh bytes default psk into another constant of length Nh bytes, using LabeledExtract, we can just not transform the default psk at all and use it directly. This removes the performance penalty for non-psk modes.\r\n\r\nAn alternative would be that implementations pre-computed the transformed default psk value. This seems a stretch to me, as transforming the default psk does not buy anything in terms of provable security. If we assume that implementations specialize for one particular HPKE mode anyway, it also does not buy much in terms of reducing probability of implementation mistakes.",
      "createdAt": "2020-04-13T15:07:53Z",
      "updatedAt": "2020-04-23T17:37:41Z",
      "closedAt": "2020-04-23T17:37:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> An alternative would be that implementations pre-computed the transformed default psk value. This seems a stretch to me, as transforming the default psk does not buy anything in terms of provable security. If we assume that implementations specialize for one particular HPKE mode anyway, it also does not buy much in terms of reducing probability of implementation mistakes.\r\n\r\nI prefer this approach. It lets implementations pre-compute that value and simplify their KeySchedule code (no branches). ",
          "createdAt": "2020-04-23T16:41:46Z",
          "updatedAt": "2020-04-23T16:41:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @chris-wood here.  Pre-hashing constant values is a known optimization trick; there's a similar issue with early data / PSKs in TLS.  I would suggest we just add a note somewhere reminding people that this optimization is possible.",
          "createdAt": "2020-04-23T17:09:25Z",
          "updatedAt": "2020-04-23T17:09:25Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's fine with me, I'll close this pull request. The note about the pre-computation can go into a separate PR.",
          "createdAt": "2020-04-23T17:37:41Z",
          "updatedAt": "2020-04-23T17:37:41Z"
        }
      ],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "916823a65f4cbf1f7f0918f96fd6062968f06d68",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_psk",
      "headRefOid": "84ef51656daf93ac3a74e49a3cbfaebd1d09afcf",
      "mergeCommit": null
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAyNjk4MDM3",
      "title": "Remove unused function len",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/64",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "as the PSK hashing step does no longer depend on the PSK's length.",
      "createdAt": "2020-04-13T15:30:54Z",
      "updatedAt": "2020-04-23T16:36:30Z",
      "closedAt": "2020-04-23T16:36:30Z",
      "mergedAt": "2020-04-23T16:36:30Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5Mjc4ODg1",
          "commit": {
            "abbreviatedOid": "7754f3b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-23T16:36:24Z",
          "updatedAt": "2020-04-23T16:36:24Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "916823a65f4cbf1f7f0918f96fd6062968f06d68",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_len",
      "headRefOid": "7754f3b64934f63f5f7d63f4f6b7d886890b5345",
      "mergeCommit": {
        "oid": "fe97496c9ede2f8eaa106e3e607d43d6f4ac0dee"
      }
    },
    {
      "number": 65,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNjM3ODEz",
      "title": "Change labels for pskID and psk to be prefix-free",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/65",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We claim in the document that all our labels are prefix-free, but the labels for pskID (\"pskID\") and psk (\"psk\") were actually not prefix-free. Appending \"_hash\" is just the first thing I came up with, I am open to other suggestions for maybe shorter labels for these two cases.",
      "createdAt": "2020-05-03T17:36:17Z",
      "updatedAt": "2020-05-04T19:59:12Z",
      "closedAt": "2020-05-04T19:59:12Z",
      "mergedAt": "2020-05-04T19:59:12Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MzAyNzU5",
          "commit": {
            "abbreviatedOid": "d4d09d1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-04T19:59:06Z",
          "updatedAt": "2020-05-04T19:59:06Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "fe97496c9ede2f8eaa106e3e607d43d6f4ac0dee",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "patch-2",
      "headRefOid": "d4d09d1591fbad2c2874e4ba631b4ac16deef2be",
      "mergeCommit": {
        "oid": "961a873d95c9631a375d3865feb33cbd88c55de2"
      }
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE0MzkyMDI5",
      "title": "Update vectors and one table nit",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/68",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Per #67 and #66. Thanks, @kjacobs-moz!",
      "createdAt": "2020-05-07T00:01:59Z",
      "updatedAt": "2020-05-08T19:28:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "5bc57ba5753f6e76d6350e532c1ca069ac8b228c",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/vectors-and-nits",
      "headRefOid": "0491164a2717047f129c1f2e6b279f304453822f",
      "closedAt": "2020-05-08T19:28:03Z",
      "mergedAt": "2020-05-08T19:28:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "312b9da6fd832e07cccae9381605d657052de147"
      },
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These test vectors also pass on my impl",
          "createdAt": "2020-05-07T04:21:30Z",
          "updatedAt": "2020-05-07T04:21:30Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please see https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/67#issuecomment-625067374 where I reason about why the 64 bytes is what we wanted.",
          "createdAt": "2020-05-07T06:56:58Z",
          "updatedAt": "2020-05-07T06:57:32Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think 4.1 may still have a contradictory definition of Nzz (being the length of Extract output - maybe it's supposed to be \"and the output length of the KDF's _Expand_ function is Nzz bytes.\"?\r\n\r\nAs I said in https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/67#issuecomment-625067374, this sentence is really confusing and we should improve it, or delete it. The Expand function has variable output, so while the concrete invocation within ExtractAndExpand uses length Nzz, I believe we should not make a statement that sounds too general.",
          "createdAt": "2020-05-07T06:59:56Z",
          "updatedAt": "2020-05-07T06:59:56Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Proposal: \u201cFor the variants of DHKEM defined in this document, Ndh is equal to Npk, and Nzz is equal to the output length of the hash function underlying the KDF.\u201d\r\n\r\nMaybe we chose to talk about HKDF-Extract in the current version because our abstract definition of a KDF does not mention a hash function, but only Extract and Expand. Given that the variants of DHKEM defined in the document all use HKDF, I think it might be ok and less confusing to write what I proposed.",
          "createdAt": "2020-05-07T07:11:01Z",
          "updatedAt": "2020-05-07T07:11:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp I'll take your proposal -- it clears things up for me. Thanks!",
          "createdAt": "2020-05-07T12:17:09Z",
          "updatedAt": "2020-05-07T12:17:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kjacobs-moz, @rozbb, @blipp please have a look (and test) the latest vectors and changes. They make clear that Nzz is the KDF's output size. (I also removed superfluous output from {Auth}Decap.)",
          "createdAt": "2020-05-07T12:22:24Z",
          "updatedAt": "2020-05-07T12:22:24Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "NONE",
          "body": "Thanks @chris-wood, @blipp. These vectors pass with the updated Nzz value, though my implementation is limited to base mode. ",
          "createdAt": "2020-05-07T15:15:12Z",
          "updatedAt": "2020-05-07T15:15:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for confirming!",
          "createdAt": "2020-05-07T15:15:59Z",
          "updatedAt": "2020-05-07T15:15:59Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't have X448 or P-curves implemented yet, but everything using X25519 passes for me.",
          "createdAt": "2020-05-07T15:22:31Z",
          "updatedAt": "2020-05-07T15:22:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @rozbb!",
          "createdAt": "2020-05-07T15:24:07Z",
          "updatedAt": "2020-05-07T15:24:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MDczNzgx",
          "commit": {
            "abbreviatedOid": "c95bfa3"
          },
          "author": "kjacobs-moz",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Thanks! These vectors look right.\r\n\r\nI think 4.1 may still have a contradictory definition of Nzz (being the length of Extract output - maybe it's supposed to be \"and the output length of the KDF's *Expand* function is Nzz bytes.\"?",
          "createdAt": "2020-05-07T00:24:52Z",
          "updatedAt": "2020-05-07T00:24:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE1NDY5NDA0",
      "title": "Removed mention of subgroups in point validation paragraph",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/70",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There is no need to check that a point of a NIST P-curve is in the \"correct prime-order subgroup\" because all P-curves have cofactor 1.\r\n\r\nSource: [NIST FIPS 186-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf) appendix D.1.2",
      "createdAt": "2020-05-08T23:09:09Z",
      "updatedAt": "2020-05-12T12:57:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "312b9da6fd832e07cccae9381605d657052de147",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "master",
      "headRefOid": "60edaf522105e5b2b2f61507f079779d13483640",
      "closedAt": "2020-05-12T12:57:10Z",
      "mergedAt": "2020-05-12T12:57:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e955931cdc4e9708da2fd4d905dd920fc4668c85"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2020-05-12T12:57:15Z",
          "updatedAt": "2020-05-12T12:57:15Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE4MDY4Nzky",
      "title": "Clarify psk overwriting",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/73",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-14T15:22:30Z",
      "updatedAt": "2020-05-14T16:11:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "e955931cdc4e9708da2fd4d905dd920fc4668c85",
      "headRepository": "raphaelrobert/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "90399ce722d70c741c1bd467a548af52c28cc7b1",
      "closedAt": "2020-05-14T16:11:03Z",
      "mergedAt": "2020-05-14T16:11:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a9e89a2fa93faf4618590077b517857c06192ea0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExOTYyMzU4",
          "commit": {
            "abbreviatedOid": "90399ce"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2020-05-14T16:10:59Z",
          "updatedAt": "2020-05-14T16:10:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5ODI2NjI3",
      "title": "Updated test-vectors.json",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/78",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The test vectors come from the latest version of `go-hpke`.\r\n\r\nThis does not update the test vectors in the spec itself. I don't know how those are generated, but I assume there is some script to automate the process.\r\n\r\nSolves #75 ",
      "createdAt": "2020-05-19T01:41:23Z",
      "updatedAt": "2020-05-19T15:36:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "a9e89a2fa93faf4618590077b517857c06192ea0",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "test_vec",
      "headRefOid": "6a49ec56262760f7a9a4d486b5072a419c62a8e2",
      "closedAt": "2020-05-19T15:36:10Z",
      "mergedAt": "2020-05-19T15:36:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "325c94f111732d8fdab54caac26ceee364de8a69"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 79,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5ODUzMzY3",
      "title": "Defined DeriveKeyPair",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/79",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, HPKE exposes no way of deriving a key pair given random bytes. This functionality is necessary in MLS (in order to have multiple participants derive their ancestor nodes' secret keys). I propose the use of `UnmarshalSk` to do precisely this.\r\n\r\n`UnmarshalSk` need not be a total function. In NIST curves, for example, the `Octet-String-to-Field-Element` function (defined in [SECG](https://secg.org/sec1-v2.pdf)) will return \"invalid\" for inputs that represent integers that are greater than or equal to the modulus. I haven't written it anywhere, but I would like to recommend that any end users who want to call `UnmarshalSk` on some deterministically derived bytes use a KDF chain to do rejection sampling.",
      "createdAt": "2020-05-19T03:25:25Z",
      "updatedAt": "2020-06-10T17:58:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d1e58f3d89c3790fef15c756c6279d0811c6f7ab",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "unmarshal_sk",
      "headRefOid": "b3f9bd7644495a578d9cdbca3a2b5f489a7069b3",
      "closedAt": "2020-06-10T17:58:17Z",
      "mergedAt": "2020-06-10T17:58:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "10c447eb233e7ec057905af544c100288ddca7ea"
      },
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There might be a concern that this could just as well be implemented directly at the DHKEM level, and left out of the HPKE spec. The downside of this is that MLS would then have to depend on an HPKE implementation as well a compatible underlying DHKEM implementation.\r\n\r\nI believe that this abstraction is the only thing preventing an HPKE library from abstracting all KEM details away from MLS. This should vastly simplify implementation.",
          "createdAt": "2020-05-19T03:31:49Z",
          "updatedAt": "2020-05-19T03:31:49Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Following @Bren2010 's advice in https://github.com/mlswg/mls-protocol/pull/338, I reverted the `UnmarshalSk` idea. The problem is that `UnmarshalSk` is insufficient to provide a reliable way to generate a keypair. MLS should not have to rejection-sample a private key, as that might not work for some KEMs.\r\n\r\nInstead, I define the `DeriveKeyPair` function, which replaces `GenerateKeyPair`. This function \"knows\" how to reliably generate a private key, so MLS doesn't have to.\r\n\r\nIt works in the obvious way for the CFRG curves, and does rejection sampling for the NIST curves. The bitmask part is necessary because P-521 scalars are only 521 bits long. There's only 1 bit that can be legally set in the MSB. Without clearing the top 7 bits, the candidate key would be rejected with probability 254/256. This bitmask does not impact uniformity.\r\n\r\nFinally, rejection sampling 255 times has overwhelming probability of success. Of the curves above, the one with highest probability of candidate scalar rejection is P-256, with probability 2^(-32). The likelihood that this fails after 255 attempts is 2^(-8160).",
          "createdAt": "2020-05-19T19:27:38Z",
          "updatedAt": "2020-05-19T19:37:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@rozbb, can you please resolve the conflict?",
          "createdAt": "2020-05-19T22:21:00Z",
          "updatedAt": "2020-05-19T22:21:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation, please have a look!",
          "createdAt": "2020-05-19T23:11:05Z",
          "updatedAt": "2020-05-19T23:11:05Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another clarification I just realized while implementing: This addition means that there is some KEX functionality that is dependent on the choice of KDF. I think it's obvious that it's the DHKEM's KDF we use for `DeriveKeyPair`, but it could be clearer. It should be made clearer in general which KDF is being used at any time.",
          "createdAt": "2020-05-22T02:49:02Z",
          "updatedAt": "2020-05-22T02:49:02Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "For DHKEM implementations, you restrict the length of ikm to be Nsk.\r\nThis is needed for X25519/X448, using identity function.\r\n\r\nAt KEM level (the general interface), Nsk is also introduced but the length of ikm is not restricted.\r\nIs this intended?",
          "createdAt": "2020-06-01T19:38:50Z",
          "updatedAt": "2020-06-01T19:38:50Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I didn't really have a reason for this other than a general hesitation to overspecify the protocol. But now that I think about it, I think this would be good for consistency. It also shouldn't hurt security at all, since we're still requiring the appropriate amount of entropy.",
          "createdAt": "2020-06-01T20:36:22Z",
          "updatedAt": "2020-06-01T20:36:22Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Explanation of the last commit: \"partial public key validation\" is the same thing as \"full public key validation\", except for a missing low-order check on the input point. This check is irrelevant for prime-order curves such as the NIST P- curves.",
          "createdAt": "2020-06-02T20:36:15Z",
          "updatedAt": "2020-06-02T20:36:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODc0NTU0",
          "commit": {
            "abbreviatedOid": "15c027f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This seems like a reasonable change to me. Thanks!",
          "createdAt": "2020-05-19T22:44:18Z",
          "updatedAt": "2020-05-19T22:54:10Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "```suggestion\r\ndef DeriveKeyPair(ikm):\r\n  prk = LabeledExtract(zero(0), \"keypair\", ikm)\r\n  sk = \"invalid\"\r\n  counter = 1\r\n  while sk == \"invalid\":\r\n    label = concat(\"candidate \", encode_big_endian(counter, 1))\r\n    bytes = Expand(prk, label, Nsk)\r\n    bytes[Nsk-1] = bytes[Nsk-1] & bitmask\r\n    sk = Octet-String-to-Field-Element(bytes)\r\n    counter += 1\r\n  return (sk, pk(sk))\r\n```",
              "createdAt": "2020-05-19T22:44:18Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 138,
              "body": "```suggestion\r\nwhere bitmask is defined to be 0xFF for P-256 and P-384, and 0x01 for P-521, and\r\n`Octet-String-to-Field-Element` is as defined in {{SECG}}, Section 2.3.6.\r\n```",
              "createdAt": "2020-05-19T22:45:37Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTY4ODky",
          "commit": {
            "abbreviatedOid": "5c0cfa8"
          },
          "author": "Bren2010",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T18:55:10Z",
          "updatedAt": "2020-06-02T18:55:11Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "The Unmarshal function defined by SECG can return the point at infinity. Worth considering if you want to explicitly disallow that.",
              "createdAt": "2020-06-02T18:55:11Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTc5NTA3",
          "commit": {
            "abbreviatedOid": "5c0cfa8"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T19:09:40Z",
          "updatedAt": "2020-06-02T19:09:40Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "This is what the current spec does, I'm just more explicit about it here.\r\n\r\nThat said, I can share some thoughts.\r\n* The Unmarshal procedure should not really be used for deriving keys, but for reconstructing saved keys from a previous session. If Unmarshal produces a bad key, then that means you somehow generated a bad key in a previous session or the key was tampered with.\r\n* The only way to generate a bad keypair is by giving to DeriveKeypair 0 or p (in the case of X25519), or an HKDF preimage of 0 (in the case of P- curves)\r\n* A point at infinity must be caught at the DH stage anyway\r\n\r\nWould it make sense to add an HKDF step to the X25519 DeriveKeyPair? It would be nice to claim that it's computationally infeasible to derive a bad keypair using DeriveKeyPair",
              "createdAt": "2020-06-02T19:09:40Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTkzMTMz",
          "commit": {
            "abbreviatedOid": "5c0cfa8"
          },
          "author": "Bren2010",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T19:28:29Z",
          "updatedAt": "2020-06-02T19:28:30Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "I'm worried about an adversary sending the point at infinity maliciously. MLS previously disallowed infinity, but now it won't",
              "createdAt": "2020-06-02T19:28:29Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDAyMzUz",
          "commit": {
            "abbreviatedOid": "5c0cfa8"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T19:42:20Z",
          "updatedAt": "2020-06-02T19:42:21Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Are you specifically concerned about an adversary giving the point-at-infinity as a DH pubkey? Doesn't the \"Validation of Inputs and Outputs\" section below the \"DeriveKeyPair\" section cover this?",
              "createdAt": "2020-06-02T19:42:20Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDEwODc2",
          "commit": {
            "abbreviatedOid": "0d46e9c"
          },
          "author": "Bren2010",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T19:54:58Z",
          "updatedAt": "2020-06-02T19:54:59Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Yes. Ah, I didn't see that before! Why is it \"one of the following checks\" and not \"both\"?",
              "createdAt": "2020-06-02T19:54:58Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDIwMzI0",
          "commit": {
            "abbreviatedOid": "0d46e9c"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T20:09:09Z",
          "updatedAt": "2020-06-02T20:09:10Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "The \"full public-key validation on all public key inputs\" includes a point-at-infinity check and a valid-point check. If you're guaranteed that the input point is valid and has prime order (this follows from non-identity because the P- curves are all prime order), then the two checks mentioned are equivalent.",
              "createdAt": "2020-06-02T20:09:09Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDI0ODU2",
          "commit": {
            "abbreviatedOid": "0d46e9c"
          },
          "author": "Bren2010",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T20:15:58Z",
          "updatedAt": "2020-06-02T20:15:58Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "That's not clear to me. Probably worth re-iterating that \"full validation\" means \"coordinates are field elements, point is on curve, and point is not infinity\"",
              "createdAt": "2020-06-02T20:15:58Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDgxNzM3",
          "commit": {
            "abbreviatedOid": "ef0139f"
          },
          "author": "Bren2010",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-02T21:48:54Z",
          "updatedAt": "2020-06-02T21:48:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNjg0MjMz",
          "commit": {
            "abbreviatedOid": "2c32a2f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-06-03T15:42:19Z",
          "updatedAt": "2020-06-03T18:02:23Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n  - DeriveKeyPair(ikm): Derive a key pair `(sk, pk)` from the byte string `ikm` of length `Nsk`\r\n```",
              "createdAt": "2020-06-03T15:42:19Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n  - Unmarshal(enc): Parse the byte string `enc` of length `Npk` to recover a\r\n```",
              "createdAt": "2020-06-03T15:42:53Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 110,
              "body": "```suggestion\r\nFor P-256, P-384 and P-521, the Marshal function of the\r\n```",
              "createdAt": "2020-06-03T15:44:04Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 115,
              "body": "```suggestion\r\nFor X25519 and X448, the Marshal and Unmarshal functions\r\n```",
              "createdAt": "2020-06-03T15:44:17Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 124,
              "body": "```suggestion\r\nFor P-256, P-384 and P-521, the DeriveKeyPair function of the\r\n```",
              "createdAt": "2020-06-03T15:46:10Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 145,
              "body": "```suggestion\r\nFor X25519 and X448, the DeriveKeyPair function performs\r\n```",
              "createdAt": "2020-06-03T15:46:19Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 151,
              "body": "Why do we need to extract from `ikm = random(Nsk)`?",
              "createdAt": "2020-06-03T15:48:02Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 151,
              "body": "Also, this is... interesting. It's not clear to me whether we should clamp the output `sk`, per https://cr.yp.to/ecdh.html, or assume that x25519 implementations handle this for us per RFC7748. ",
              "createdAt": "2020-06-03T15:50:27Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzODc3NTQ5",
          "commit": {
            "abbreviatedOid": "2c32a2f"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-03T19:47:40Z",
          "updatedAt": "2020-06-03T19:47:41Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "will clamp",
              "createdAt": "2020-06-03T19:47:41Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzODg1MTc2",
          "commit": {
            "abbreviatedOid": "dd5f4ae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-03T19:59:06Z",
          "updatedAt": "2020-06-03T19:59:06Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Let's leave it as-is for now, and wait to hear what others think? I'm fine to be in the rough here.",
              "createdAt": "2020-06-03T19:59:06Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjM4NTYw",
          "commit": {
            "abbreviatedOid": "dd5f4ae"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T13:31:54Z",
          "updatedAt": "2020-06-08T13:31:55Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "I am comfortable assuming RFC 7748 here, thus not doing clamping.",
              "createdAt": "2020-06-08T13:31:55Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjUxNzQx",
          "commit": {
            "abbreviatedOid": "7c4139c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T13:39:42Z",
          "updatedAt": "2020-06-08T13:49:23Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "Where does this value come from?",
              "createdAt": "2020-06-08T13:39:42Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 151,
              "body": "We need `LabeledExtract` because `ikm` isn't guaranteed to be `random(Nsk)`.  For example, it might be some input from MLS.",
              "createdAt": "2020-06-08T13:41:10Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 160,
              "body": "Why is the `_keypair` necessary?  Suggest just using `desc`.",
              "createdAt": "2020-06-08T13:42:48Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 142,
              "body": "It seems like it would be clearer to use `sk == 0` instead of `sk < 1`, since `sk` is unsigned.",
              "createdAt": "2020-06-08T13:49:18Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjcyMzg3",
          "commit": {
            "abbreviatedOid": "90e8aaa"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T14:00:29Z",
          "updatedAt": "2020-06-08T14:00:29Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "This is because the scalar size for P-521 is 521 bits, or 65 bytes plus 1 bit. In order to get a scalar in this range, we have to generate 66 bytes and clear the top 7 bits. Otherwise the rejection sampling will fail each iteration with probability 254/256.",
              "createdAt": "2020-06-08T14:00:29Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjgyODcx",
          "commit": {
            "abbreviatedOid": "aadb2d6"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T14:11:30Z",
          "updatedAt": "2020-06-08T14:11:30Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "I changed this to fixed strings for each curve family. Thoughts?",
              "createdAt": "2020-06-08T14:11:30Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjgzNzUx",
          "commit": {
            "abbreviatedOid": "90e8aaa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T14:12:23Z",
          "updatedAt": "2020-06-08T14:12:23Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Yeah, I forgot we meant to export this function for MLS. I'm fine with extract as is then.",
              "createdAt": "2020-06-08T14:12:23Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2Mjg2NTYy",
          "commit": {
            "abbreviatedOid": "90e8aaa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T14:15:20Z",
          "updatedAt": "2020-06-08T14:15:20Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Does this mean that `ikm` has at least `Nsk` bytes of entropy? (That would seem to contradict the need for extract, I think.)",
              "createdAt": "2020-06-08T14:15:20Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2Mjg3ODY3",
          "commit": {
            "abbreviatedOid": "90e8aaa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T14:16:38Z",
          "updatedAt": "2020-06-08T14:16:39Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "Can we use the curve name instead of \"nistp\"?",
              "createdAt": "2020-06-08T14:16:39Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2Mjg4MTU4",
          "commit": {
            "abbreviatedOid": "90e8aaa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T14:16:57Z",
          "updatedAt": "2020-06-08T14:16:57Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "Same comment here: can we use the group name?",
              "createdAt": "2020-06-08T14:16:57Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2Mzk5Njky",
          "commit": {
            "abbreviatedOid": "972da1e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T16:14:32Z",
          "updatedAt": "2020-06-08T16:14:32Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "(Chatted offline, to resolve with a slight tweak of text)",
              "createdAt": "2020-06-08T16:14:32Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NDEwODc5",
          "commit": {
            "abbreviatedOid": "b3f9bd7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-08T16:28:10Z",
          "updatedAt": "2020-06-08T16:28:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4Mjk5NzY4",
          "commit": {
            "abbreviatedOid": "b3f9bd7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-10T17:57:31Z",
          "updatedAt": "2020-06-10T17:57:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 80,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMTM4MDAx",
      "title": "Clarify between KEM and DH shared secret",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/80",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Quick draft of a pull request to make the distinction between DH shared secret and KEM shared secret clearer.",
      "createdAt": "2020-05-19T14:00:06Z",
      "updatedAt": "2020-05-19T14:59:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "a9e89a2fa93faf4618590077b517857c06192ea0",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_shared_secrets",
      "headRefOid": "afe715d9627e073a0eddd9bd490d45809fe8f6d0",
      "closedAt": "2020-05-19T14:59:45Z",
      "mergedAt": "2020-05-19T14:59:45Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "46c36e13e85bcb4c8a5233c434778c6bd0bb97f4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NTM3NjQw",
          "commit": {
            "abbreviatedOid": "afe715d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-19T14:59:40Z",
          "updatedAt": "2020-05-19T14:59:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMjA2MzUz",
      "title": "Replace `zero(Nh)` with `zero(0)` in ExtractAndExpand",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/81",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #76 and #77.\r\n\r\nFor future reference, here's the test vector formatting script: https://gist.github.com/chris-wood/26b2ad73ef934cf74f2709cd29555ce1\r\n\r\ncc @rozbb",
      "createdAt": "2020-05-19T15:47:23Z",
      "updatedAt": "2020-05-20T15:08:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "325c94f111732d8fdab54caac26ceee364de8a69",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/zero-salt-extract-and-expand",
      "headRefOid": "25374abc1dc3cf845bfd68d8badd167b70d86a2e",
      "closedAt": "2020-05-20T15:08:03Z",
      "mergedAt": "2020-05-20T15:08:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "bf2725770014b7cd242925635dbf602715fce966"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1Mzk1MzUx",
          "commit": {
            "abbreviatedOid": "04c58d2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-20T14:28:16Z",
          "updatedAt": "2020-05-20T14:28:47Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "\"empty **byte** string\"",
              "createdAt": "2020-05-20T14:28:16Z",
              "updatedAt": "2020-05-20T15:06:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDM1MzA1",
          "commit": {
            "abbreviatedOid": "04c58d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-20T15:06:47Z",
          "updatedAt": "2020-05-20T15:06:47Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\n  0x00000000` and `zero(0)` is the empty byte string.\r\n```",
              "createdAt": "2020-05-20T15:06:47Z",
              "updatedAt": "2020-05-20T15:06:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 82,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMjEyODk5",
      "title": "Simplify the KeySchedule signature by removing pkSm.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/82",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is not used in the context construction. It only signals that `mode`\r\nis one of the authenticated flavors. Removing it allows us to simplify\r\nthe VerifyMode function, too, as it only exists to ensure PSK parameters\r\nare consistent.\r\n\r\nCloses #71.",
      "createdAt": "2020-05-19T15:58:33Z",
      "updatedAt": "2020-05-20T14:29:13Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "325c94f111732d8fdab54caac26ceee364de8a69",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/simplify-keyschedule-signature",
      "headRefOid": "ea32940586c45a3227b83ca18663975b64a6df63",
      "closedAt": "2020-05-20T14:29:13Z",
      "mergedAt": "2020-05-20T14:29:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8af08a0ab00af8a55024263afc99749bed1e7c44"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1Mzk2MTg5",
          "commit": {
            "abbreviatedOid": "ea32940"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-20T14:29:06Z",
          "updatedAt": "2020-05-20T14:29:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwOTM3MDA2",
      "title": "Removed remaining instances of LabeledExtract(zero(Nh), ...)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/99",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "By the same reasoning as https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/81, we shouldn't use `zero(Nh)` as a salt for `LabeledExtract`.",
      "createdAt": "2020-05-20T18:16:22Z",
      "updatedAt": "2020-05-22T01:21:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "bf2725770014b7cd242925635dbf602715fce966",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "zero-Nh",
      "headRefOid": "1e7c22a9c8fdec7dcbea78fc93fc3145e8a260aa",
      "closedAt": "2020-05-22T01:21:12Z",
      "mergedAt": "2020-05-22T01:21:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9a2c364839fa08c8eb8b3f714f5459c249f828ce"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 101,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIyMzQ0NzUw",
      "title": "Address most of the nits from Verisign's review.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/101",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #100, #97, #95, #93, #92, #91, #90, #89, #88, #87, #86, and #55. \r\n\r\nEdit: Updated to include #94 and #72.\r\n\r\nI'll update the test vectors (and their labels) in a separate change that aligns with a change in the cisco/go-hpke codebase. \r\n\r\ncc @blipp, @rozbb, @davidben for visibility",
      "createdAt": "2020-05-24T00:26:58Z",
      "updatedAt": "2020-05-28T17:26:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "9a2c364839fa08c8eb8b3f714f5459c249f828ce",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/verisign-nits",
      "headRefOid": "9d37303df9430d54867637168f0540c6c23a8eea",
      "closedAt": "2020-05-27T21:40:35Z",
      "mergedAt": "2020-05-27T21:40:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "881c5b6e49bf33e287b7f28f5da8b07180346e0f"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@rozbb, @kjacobs-moz, @raphaelrobert: could you please check these test vectors? ",
          "createdAt": "2020-05-26T21:53:08Z",
          "updatedAt": "2020-05-26T21:53:08Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yup, passes for me.\r\n\r\nOne note: there a field in the JSON called `key_schedule_context`, and it's the only snakecase field",
          "createdAt": "2020-05-26T22:25:32Z",
          "updatedAt": "2020-05-26T22:26:18Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "NONE",
          "body": "I've updated my implementation and the Curve25519 vectors pass, but not P-curves (using base mode values from the draft). These fail as early as the computation of `zz`. \r\n\r\nI'm not sure if @rozbb's implementation supports P-curves yet... I assume this is a bug in my code, but will need to pick debugging back up tomorrow. ",
          "createdAt": "2020-05-27T01:38:52Z",
          "updatedAt": "2020-05-27T01:38:52Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can confirm that P-256 an X25519 both worked for me",
          "createdAt": "2020-05-27T01:45:09Z",
          "updatedAt": "2020-05-27T01:45:09Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "NONE",
          "body": "> I can confirm that P-256 an X25519 both worked for me\r\n\r\nThe issue was on my end, due to using the old (pre- 0cbca7cb11f37d433493b9f17905f351084a821e) shared secret representation.\r\n\r\nThe vectors seem to be correct \ud83d\udc4d.\r\n\r\n",
          "createdAt": "2020-05-27T04:23:24Z",
          "updatedAt": "2020-05-27T04:23:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzIwNjk2",
          "commit": {
            "abbreviatedOid": "055226d"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-24T01:42:59Z",
          "updatedAt": "2020-05-24T01:47:55Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "Isn't HPKE supposed to be more general than this? SIKE should be included as a possible KEM, for example.",
              "createdAt": "2020-05-24T01:42:59Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzIwODY5",
          "commit": {
            "abbreviatedOid": "055226d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-24T01:49:15Z",
          "updatedAt": "2020-05-24T01:49:15Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "It is, but this sentence pertains to what\u2019s currently specified (with a code point) in the document. ",
              "createdAt": "2020-05-24T01:49:15Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3Nzk0OTg4",
          "commit": {
            "abbreviatedOid": "055226d"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-25T16:05:19Z",
          "updatedAt": "2020-05-25T16:05:20Z",
          "comments": [
            {
              "originalPosition": 404,
              "body": "```Note that the internal Seal and Open calls inside corresponding to the context's AEAD algorithm.```\r\ncorresponding -> correspond ?",
              "createdAt": "2020-05-25T16:05:20Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3ODI5NzA3",
          "commit": {
            "abbreviatedOid": "055226d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-25T17:57:25Z",
          "updatedAt": "2020-05-25T17:57:25Z",
          "comments": [
            {
              "originalPosition": 403,
              "body": "```suggestion\r\nthe internal Seal and Open calls inside correspond to the context's AEAD\r\n```",
              "createdAt": "2020-05-25T17:57:25Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5Mzk4NTgz",
          "commit": {
            "abbreviatedOid": "9000051"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T16:24:48Z",
          "updatedAt": "2020-05-27T18:45:20Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "\"using ... based on ...\" seems redundant.  Reword to something like \"... primitives, such as ECDH, HKDF, and SHA2.\"  ",
              "createdAt": "2020-05-27T16:24:48Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            },
            {
              "originalPosition": 233,
              "body": "\"contained herein\" -> \"defined here\"",
              "createdAt": "2020-05-27T16:26:49Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            },
            {
              "originalPosition": 233,
              "body": "Also, why drop \"formally verified\"?  Since we did that.",
              "createdAt": "2020-05-27T16:27:14Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            },
            {
              "originalPosition": 264,
              "body": "I really don't care strongly about this, but it seems like in RFC 7748, `X*` is the group, and `Curve*` is the ECDH operation (largely just specifying the base point).  Since we're doing ECDH here, `Curve*` seems like the right answer.",
              "createdAt": "2020-05-27T18:33:29Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            },
            {
              "originalPosition": 446,
              "body": "This doesn't make sense.  The curve is a group. ",
              "createdAt": "2020-05-27T18:42:17Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            },
            {
              "originalPosition": 466,
              "body": "Same comment re group == curve.",
              "createdAt": "2020-05-27T18:43:00Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            },
            {
              "originalPosition": 477,
              "body": "Same comment, `X*` are the groups.",
              "createdAt": "2020-05-27T18:44:53Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NTI5MzUx",
          "commit": {
            "abbreviatedOid": "9000051"
          },
          "author": "davidben",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T19:08:18Z",
          "updatedAt": "2020-05-27T19:08:18Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "I think you've got it backwards, though both specify a base point. X* is a function from bytes to bytes, with group operations and serialization built in. curve* is a curve with base point.\r\n\r\nhttps://tools.ietf.org/html/rfc7748#section-4.1\r\n>   For the ~128-bit security level, the prime 2^255 - 19 is recommended\r\n>   for performance on a wide range of architectures.  Few primes of the\r\n>   form 2^c-s with s small exist between 2^250 and 2^521, and other\r\n>   choices of coefficient are not as competitive in performance.  This\r\n>   prime is congruent to 1 mod 4, and the derivation procedure in\r\n>   Appendix A results in the following Montgomery curve\r\n>   v^2 = u^3 + A*u^2 + u, called \"curve25519\":\r\n\r\nhttps://tools.ietf.org/html/rfc7748#section-5\r\n>   The \"X25519\" and \"X448\" functions perform scalar multiplication on\r\n>   the Montgomery form of the above curves.  (This is used when\r\n>   implementing Diffie-Hellman.)  The functions take a scalar and a\r\n>   u-coordinate as inputs and produce a u-coordinate as output.\r\n>   Although the functions work internally with integers, the inputs and\r\n>   outputs are 32-byte strings (for X25519) or 56-byte strings (for\r\n>   X448) and this specification defines their encoding.",
              "createdAt": "2020-05-27T19:08:18Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NTMwNjI3",
          "commit": {
            "abbreviatedOid": "9000051"
          },
          "author": "davidben",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T19:09:45Z",
          "updatedAt": "2020-05-27T19:09:46Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "Also https://mailarchive.ietf.org/arch/msg/cfrg/-9LEdnzVrE5RORux3Oo_oDDRksU/",
              "createdAt": "2020-05-27T19:09:45Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NTMxMDU1",
          "commit": {
            "abbreviatedOid": "9000051"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T19:10:22Z",
          "updatedAt": "2020-05-27T19:10:22Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "Yeah, I think using x25519 is also more clear since there are small subgroups of curve25519.",
              "createdAt": "2020-05-27T19:10:22Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjA2Mjk5",
          "commit": {
            "abbreviatedOid": "9000051"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:03:04Z",
          "updatedAt": "2020-05-27T21:03:04Z",
          "comments": [
            {
              "originalPosition": 233,
              "body": "The \"formally verified\" bit was redundant with the remainder of the paragraph, which states that we did the analysis.",
              "createdAt": "2020-05-27T21:03:04Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjA2OTA5",
          "commit": {
            "abbreviatedOid": "9000051"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:03:59Z",
          "updatedAt": "2020-05-27T21:03:59Z",
          "comments": [
            {
              "originalPosition": 446,
              "body": "This is just for consistency with the X25519/curve25519 notation. I think this is more clear, and lets us speak in terms of DH groups rather than specific curves.",
              "createdAt": "2020-05-27T21:03:59Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjA3NDA0",
          "commit": {
            "abbreviatedOid": "79fff5f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:04:44Z",
          "updatedAt": "2020-05-27T21:04:44Z",
          "comments": [
            {
              "originalPosition": 466,
              "body": "Same as above!",
              "createdAt": "2020-05-27T21:04:44Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjEwMzQy",
          "commit": {
            "abbreviatedOid": "79fff5f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:09:16Z",
          "updatedAt": "2020-05-27T21:09:16Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "You guys are correct.  I was looking at the subheadings of Section 6 (ECDH), when I should have been looking at Section 4.  Comment resolved.",
              "createdAt": "2020-05-27T21:09:16Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjExNDEz",
          "commit": {
            "abbreviatedOid": "79fff5f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:10:55Z",
          "updatedAt": "2020-05-27T21:10:55Z",
          "comments": [
            {
              "originalPosition": 446,
              "body": "I don't think we need to distinguish between the curve group and the subgroup here.  It's not ambiguous.",
              "createdAt": "2020-05-27T21:10:55Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjE1MDEy",
          "commit": {
            "abbreviatedOid": "9d37303"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:16:54Z",
          "updatedAt": "2020-05-27T21:16:55Z",
          "comments": [
            {
              "originalPosition": 446,
              "body": "Resolved with less text!",
              "createdAt": "2020-05-27T21:16:54Z",
              "updatedAt": "2020-05-27T21:16:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjE1MTM4",
          "commit": {
            "abbreviatedOid": "79fff5f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-27T21:17:06Z",
          "updatedAt": "2020-05-27T21:17:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzM1MjA4",
          "commit": {
            "abbreviatedOid": "9d37303"
          },
          "author": "davidben",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-28T17:26:34Z",
          "updatedAt": "2020-05-28T17:26:35Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "Hah. Those subheadings should probably have been X*. Ah well. :-)",
              "createdAt": "2020-05-28T17:26:34Z",
              "updatedAt": "2020-05-28T17:26:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 112,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NTAxNzU2",
      "title": "Address partial feedback raised during RGLC.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/112",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #111, #110, #109, #108, #107, #106, #105, #104, #103, and #102. \r\n\r\ncc @blipp, @kwantam, @dvorak42, @rozbb",
      "createdAt": "2020-06-16T22:33:01Z",
      "updatedAt": "2020-06-18T20:53:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0aea45455c89692fa569f8a27594d17498f4de40",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/rglc-feedback",
      "headRefOid": "10e21344b8de9303f1fa256b6f6b469d5a6e6bfe",
      "closedAt": "2020-06-18T20:53:36Z",
      "mergedAt": "2020-06-18T20:53:36Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b3cecc3de4419392979ea3217a2137d09694d618"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "NONE",
          "body": ":+1: edits look great!",
          "createdAt": "2020-06-16T22:42:13Z",
          "updatedAt": "2020-06-16T22:42:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think the first point of #113 is not yet addressed. I commented over there https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/103#issuecomment-645650291.\n\nYeah, I\u2019ll deal with the KEM errors in a separate PR.\n\n> From #107, I think the first point \u201creference or citation for unknown key share attacks\u201d is not yet addressed. I don't know which reference would be best to add out of my head. Also, should the terminology \u201cunknown key-share attack\u201d or \u201cidentity mis-binding issue\u201d be used? I like the latter more.\n\nI opted to not include one since I couldn\u2019t find one either :-) I\u2019ll do another scan to see if I can come up with one.\n\n",
          "createdAt": "2020-06-17T22:41:19Z",
          "updatedAt": "2020-06-17T22:41:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation please have a look. (Also, @beurdouche, please have a look at the input limits!)",
          "createdAt": "2020-06-17T23:59:45Z",
          "updatedAt": "2020-06-17T23:59:45Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should the `exporter_context` in Secret Export also be limited to 65535 bytes, as done with `psk`, `pskID`, `info`?\r\n\r\nAlso, should it be noted that `L` in Secret Export is limited to `255*Nh` bytes, for the KDFs specified?",
          "createdAt": "2020-06-18T12:20:55Z",
          "updatedAt": "2020-06-18T12:20:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Should the `exporter_context` in Secret Export also be limited to 65535 bytes, as done with `psk`, `pskID`, `info`?\r\n\r\nThat\u2019s already done :-)\r\n\r\n> Also, should it be noted that `L` in Secret Export is limited to `255*Nh` bytes, for the KDFs specified?\r\n\r\nHmm, probably?\r\n\r\n",
          "createdAt": "2020-06-18T12:24:10Z",
          "updatedAt": "2020-06-18T12:24:10Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That\u2019s already done :-)\r\n\r\nAh, sorry, missed that. Great!\r\n\r\n> > Also, should it be noted that `L` in Secret Export is limited to `255*Nh` bytes, for the KDFs specified?\r\n> \r\n> Hmm, probably?\r\n\r\nLet's! Something like: \u201cThe maximum value for the `L` parameter is `255*Nh` for the KDFs defined in this document.\u201d\r\n\r\nEdited to add: That limit on L is due to the [HKDF standard](https://tools.ietf.org/html/rfc5869).",
          "createdAt": "2020-06-18T12:28:39Z",
          "updatedAt": "2020-06-18T12:32:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzY0Njcw",
          "commit": {
            "abbreviatedOid": "6965539"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think the first point of #113 is not yet addressed. I commented over there https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/103#issuecomment-645650291.\r\n\r\nFrom #107, I think the first point \u201creference or citation for unknown key share attacks\u201d is not yet addressed. I don't know which reference would be best to add out of my head. Also, should the terminology \u201cunknown key-share attack\u201d or \u201cidentity mis-binding issue\u201d be used? I like the latter more.",
          "createdAt": "2020-06-17T20:48:22Z",
          "updatedAt": "2020-06-17T22:24:10Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "`Seal` above says \u201cciphertext and tag `ct`\u201d, should this be used here, too? Just adding \u201cand tag\u201d might make the formulation weird, because the tag is not \u201cdecrypted\u201d.",
              "createdAt": "2020-06-17T20:48:22Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 109,
              "body": "Sometimes variables like Npk are wrapped in back ticks, sometimes not. It could be nice to make this consistent at some point (not necessarily in this PR, just noticed it in this moment).",
              "createdAt": "2020-06-17T20:51:56Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 114,
              "body": "In the general KEM definition above, it is not mentioned that Deserialize can fail. Should that be added there?",
              "createdAt": "2020-06-17T20:54:34Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 189,
              "body": "Replace \u201cGroup Name\u201d by \u201cGROUP\u201d, or \u201cGroup Name (GROUP)\u201d?",
              "createdAt": "2020-06-17T20:57:13Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 218,
              "body": "```suggestion\r\n  and the recipient (optional; default value `zero(0)`) of maximum\r\n```\r\nUh, I did not see this occurrence when I submitted #116. Would you mind adding this change with this PR, for the sake of fewer merge conflicts?",
              "createdAt": "2020-06-17T21:04:27Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 223,
              "body": "```suggestion\r\n```\r\n`pkSm` is no longer an input to KeySchedule.",
              "createdAt": "2020-06-17T21:07:11Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 255,
              "body": "Using `raise` instead of `return` when an error occurs could indeed be a good idea (as Richard mentioned it off-channel). I just realized we actually already have `raise` in `VerifyPSKInputs`!",
              "createdAt": "2020-06-17T21:15:53Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 347,
              "body": "Thanks for mentioning me so prominently :)",
              "createdAt": "2020-06-17T21:19:19Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 254,
              "body": "Suggestion, to make it clearer about which Seal and Open this is, and maybe failing with an error is more explicitly saying that no other value can be returned (like, not an error *and* the ciphertext): \u201cIf `Context.Seal` or `Context.Open` would cause the `seq` field to overflow, then the implementation MUST fail with an error.\u201d",
              "createdAt": "2020-06-17T22:22:41Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODM5MDg0",
          "commit": {
            "abbreviatedOid": "8ec9983"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Good! Only comment is on the `GROUP-` prefix. It's not a huge PITA but if it's not necessary I'd rather omit it.",
          "createdAt": "2020-06-17T23:17:30Z",
          "updatedAt": "2020-06-17T23:33:40Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "How necessary is the `GROUP` prefix? This complicates things a non-trivial but acceptable amount in implementation, since I'm trying to avoid allocation entirely.",
              "createdAt": "2020-06-17T23:17:30Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 221,
              "body": "I actually don't need a length limit on HKDF `info` inputs anymore in order to avoid allocation. Your call if you want to keep it or not.",
              "createdAt": "2020-06-17T23:27:30Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 225,
              "body": "Also don't need this limit anymore.",
              "createdAt": "2020-06-17T23:28:06Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 227,
              "body": "Ditto",
              "createdAt": "2020-06-17T23:28:14Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODQ4MDgw",
          "commit": {
            "abbreviatedOid": "844b3bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:43:30Z",
          "updatedAt": "2020-06-17T23:43:30Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "For consistency, yeah, it should. Good catch!",
              "createdAt": "2020-06-17T23:43:30Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODQ4MTcw",
          "commit": {
            "abbreviatedOid": "844b3bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:43:45Z",
          "updatedAt": "2020-06-17T23:43:46Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Yep, good catch. I'll fix these and do a quick scan for others.",
              "createdAt": "2020-06-17T23:43:46Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODQ4MjIy",
          "commit": {
            "abbreviatedOid": "844b3bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:43:56Z",
          "updatedAt": "2020-06-17T23:43:56Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "Yep -- I'll add it.",
              "createdAt": "2020-06-17T23:43:56Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODQ5MzY0",
          "commit": {
            "abbreviatedOid": "8758596"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:47:16Z",
          "updatedAt": "2020-06-17T23:47:17Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "I inherited this from length restrictions on the TLS Exporter API.",
              "createdAt": "2020-06-17T23:47:17Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODQ5NDUy",
          "commit": {
            "abbreviatedOid": "8758596"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:47:34Z",
          "updatedAt": "2020-06-17T23:47:34Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "This one I pulled out of thin air. I can make it larger to match. :)",
              "createdAt": "2020-06-17T23:47:34Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODUwMDkx",
          "commit": {
            "abbreviatedOid": "8758596"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:49:43Z",
          "updatedAt": "2020-06-17T23:49:44Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Calling @kwantam! My take is that this is just good hygiene. Without the prefix, it's harder to reason about separation of these different ROs. ",
              "createdAt": "2020-06-17T23:49:43Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODUwMTY0",
          "commit": {
            "abbreviatedOid": "8758596"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:49:56Z",
          "updatedAt": "2020-06-17T23:49:57Z",
          "comments": [
            {
              "originalPosition": 254,
              "body": "That works for me -- I'll add it. Thanks!",
              "createdAt": "2020-06-17T23:49:56Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODUwOTIy",
          "commit": {
            "abbreviatedOid": "8758596"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:52:18Z",
          "updatedAt": "2020-06-17T23:52:19Z",
          "comments": [
            {
              "originalPosition": 255,
              "body": "Agreed. It's also a nice way to keep the return types clean. Namely, in the Seal/Open calls, we return two possible types: errors or plaintext/ciphertext. If we use `raise`, then we only return one possible type (plaintext or ciphertext). ",
              "createdAt": "2020-06-17T23:52:19Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODUwOTg4",
          "commit": {
            "abbreviatedOid": "8758596"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:52:29Z",
          "updatedAt": "2020-06-17T23:52:29Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "I went with the former -- thanks!",
              "createdAt": "2020-06-17T23:52:29Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODU1Njkw",
          "commit": {
            "abbreviatedOid": "5319e53"
          },
          "author": "kwantam",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T00:06:39Z",
          "updatedAt": "2020-06-18T00:06:40Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "As @chris-wood says, it makes it easier to reasonable about random oracle separation. It may be overkill (I think in my original comment I said something like \"this is probably paranoia, but...\").\r\n\r\nThe kind of thing one might worry about without `GROUP` is a case where it's possible to confuse serialized elements of two different groups. In this case it *could* be possible to construct two exchanges with identical `kemContext` inputs. (Not clear that's enough to construct an attack, but we can completely rule out attacks of this kind by including `GROUP`.)",
              "createdAt": "2020-06-18T00:06:39Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMTU4ODI4",
          "commit": {
            "abbreviatedOid": "81904d4"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T10:41:36Z",
          "updatedAt": "2020-06-18T10:41:37Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I agree with @chris-wood and @kwantam that binding `zz` explicitly to the underlying DH is important.\r\n\r\nWould it be easier for you to implement it avoiding allocation, @rozbb, if it was in the style of the context in KeySchedule? There, we include `kem_id`, `kdf_id`, `aead_id`, all as 2-byte fixed-sized values. Instead of doing \"GROUP-dh\", we could do:\r\n\r\n```\r\n  prk = LabeledExtract(zero(0), concat(I2OSP(kem_id, 2), \"dh\"), dh)\r\n  return LabeledExpand(prk, concat(I2OSP(kem_id, 2), \"prk\"), kemContext, Nzz)\r\n```\r\n\r\nThe `kem_id` already is unique per DHKEM, and also, it would avoid needing a separate table for the values of GROUP, because the table in the \u201cAlgorithm Identifiers\u201d Section already has the `kem_id`s.",
              "createdAt": "2020-06-18T10:41:36Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMTY0NTkw",
          "commit": {
            "abbreviatedOid": "81904d4"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T10:50:11Z",
          "updatedAt": "2020-06-18T10:50:12Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Ok, actually, I suggest the following for Encap and Decap:\r\n\r\n```\r\n  kemContext = concat(I2OSP(kem_id, 2), enc, pkRm)\r\n```\r\n\r\nand this for AuthEncap and AuthDecap:\r\n\r\n```\r\n  kemContext = concat(I2OSP(kem_id, 2), enc, pkRm, pkSm)\r\n```\r\n\r\nThen it is exactly in the same style as in KeySchedule. The added label `kem_id` always has two bytes. I think the LabeledExtract call in ExtractAndExpand does not need to have `kem_id` as a label, because the intermediary value `dh` is never exposed. The important thing is that `zz` is explicitly bound to the scheme's name, and for that it is enough to have it in `kemContext`. (I think we had a similar reasoning when we decided what to include where in KeySchedule's context)",
              "createdAt": "2020-06-18T10:50:12Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMTg5OTAw",
          "commit": {
            "abbreviatedOid": "81904d4"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T11:28:45Z",
          "updatedAt": "2020-06-18T11:28:46Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "On the other hand, binding to the GROUP plays a similar role as the RFCXXX label which we do include in *both* LabeledExtract *and* LabeledExpand, even if the LabeledExtract results are never exposed. And this is about, as @kwantam said in #108, that the calls are orthogonal, which makes it easier to reason with separate random oracles for separate ciphersuites (and DHKEM is kind of a sub-standard inside this RFC, so it makes sense to have RFCXXXX *and* the DHKEM group as a label).\r\n\r\nSo I have a tendency for including `kem_id` in both, as I suggested in my first reply in this thread.\r\n\r\nWhat do you think?",
              "createdAt": "2020-06-18T11:28:45Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMjI5ODc1",
          "commit": {
            "abbreviatedOid": "81904d4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T12:26:49Z",
          "updatedAt": "2020-06-18T12:26:50Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I like it! This has the same effect and is less text. Stand by for that change.",
              "createdAt": "2020-06-18T12:26:50Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMjQyMzIy",
          "commit": {
            "abbreviatedOid": "bc03f5a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T12:42:26Z",
          "updatedAt": "2020-06-18T12:42:26Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "@blipp fixed -- please have a look.",
              "createdAt": "2020-06-18T12:42:26Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMjg3MjEx",
          "commit": {
            "abbreviatedOid": "27e0cbc"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-06-18T13:33:35Z",
          "updatedAt": "2020-06-18T13:35:14Z",
          "comments": [
            {
              "originalPosition": 284,
              "body": "```suggestion\r\n(In the pseudocode below, `Context.IncrementSeq` fails with an error when `seq` overflows,\r\n```",
              "createdAt": "2020-06-18T13:33:35Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 317,
              "body": "```suggestion\r\nfunction. For the KDFs defined in this specification, `L` has a maximum value of\r\n`255*Nh`. Future specifications which define new KDFs MUST specify a bound for `L`.\r\n```",
              "createdAt": "2020-06-18T13:34:33Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMzkzMjQ1",
          "commit": {
            "abbreviatedOid": "6b89d8a"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T15:21:21Z",
          "updatedAt": "2020-06-18T15:21:22Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Yes, this is much cleaner! In fact, DeriveKeyPair should be using `kem_id` as well, instead of the `desc` string. I'll make the PR after this lands.",
              "createdAt": "2020-06-18T15:21:21Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjEzMTU2",
          "commit": {
            "abbreviatedOid": "b2186d2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Couple of editorial things, otherwise lgtm",
          "createdAt": "2020-06-18T20:12:37Z",
          "updatedAt": "2020-06-18T20:19:36Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "I would drop this first clause, \"As is standard with AEAD interfaces\"",
              "createdAt": "2020-06-18T20:12:38Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 264,
              "body": "Disagree with collapsing all of these bullets.  If you want to group them, you could have top-level \"AEAD parameters\" and \"Export parameters\"",
              "createdAt": "2020-06-18T20:14:23Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 387,
              "body": "I would rephrase as: \"For X25519 and X448, public keys and DH outputs MUST be validated as described in {{RFC7748}}.  In particular, recipients MUST check whether the DH shared secret is the all-zero value and abort if so.\"",
              "createdAt": "2020-06-18T20:19:00Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjMyNTI5",
          "commit": {
            "abbreviatedOid": "b2186d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T20:43:19Z",
          "updatedAt": "2020-06-18T20:43:19Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "\ud83d\udc4d \r\n",
              "createdAt": "2020-06-18T20:43:19Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjMzMjY0",
          "commit": {
            "abbreviatedOid": "b2186d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T20:44:31Z",
          "updatedAt": "2020-06-18T20:44:31Z",
          "comments": [
            {
              "originalPosition": 387,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-06-18T20:44:31Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjM5MDA3",
          "commit": {
            "abbreviatedOid": "10e2134"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T20:53:28Z",
          "updatedAt": "2020-06-18T20:53:28Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "It felt cleaner, but I don't feel strongly about this. I made a slight variation that's closer to what we had.",
              "createdAt": "2020-06-18T20:53:28Z",
              "updatedAt": "2020-06-18T20:53:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2MDc3MDgy",
      "title": "Change default_psk to be the empty byte string, Remove unused default_pkSm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/116",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changes the default_psk to be the empty string, i.e. zero(0), instead of zero(Nh).\r\n\r\nThis makes implementations easier, because then, in PSK and AuthPSK mode, to check that the psk provided is not equal to the default_psk, it will be enough to check that the psk is strictly longer than 0 bytes, instead of comparing Nh bytes.\r\n\r\nTODO: change VerifyPSKInputs to check the length, instead of using `!=`?",
      "createdAt": "2020-06-17T20:25:52Z",
      "updatedAt": "2020-06-17T20:28:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "10c447eb233e7ec057905af544c100288ddca7ea",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_default_psk",
      "headRefOid": "8432568363f1f2ca83b8c921748758e1295d6a16",
      "closedAt": "2020-06-17T20:28:34Z",
      "mergedAt": "2020-06-17T20:28:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0aea45455c89692fa569f8a27594d17498f4de40"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzQ5NTU4",
          "commit": {
            "abbreviatedOid": "8432568"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-17T20:28:30Z",
          "updatedAt": "2020-06-17T20:28:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 117,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2NzI4OTY5",
      "title": "Add section on input limits for psk, pskID, info, exporter_context",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/117",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This adds concrete upper inclusive bounds for psk, pskID, info, and exporter_context that depend on the hash functions maximum input sizes and the constant labels we use in HPKE.\r\n\r\nComputations are documented in https://gist.github.com/blipp/9c748499b6216e9cdca75d24c5297657.\r\n\r\nThe F* spec confirms that these bounds go along with the limits of the KDFs and underlying hash functions, see [here](https://github.com/project-everest/hacl-star/blob/e645526214a9bb4133f6f46521271e8fda5c2d99/specs/Spec.Agile.HPKE.fsti#L264) and [here](https://github.com/project-everest/hacl-star/blob/e645526214a9bb4133f6f46521271e8fda5c2d99/specs/Spec.Agile.HPKE.fsti#L300).",
      "createdAt": "2020-06-18T19:49:18Z",
      "updatedAt": "2020-06-19T14:50:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0aea45455c89692fa569f8a27594d17498f4de40",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "input_limits",
      "headRefOid": "18178f1913c5e09689fdf2db13d722a7c2513457",
      "closedAt": "2020-06-19T14:50:01Z",
      "mergedAt": "2020-06-19T14:50:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "98087a20c9e1338078fc6c4970f88daf1f5b9062"
      },
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do you think future specifications which specify new KDFs `MUST` or `SHOULD` indicate their bounds for variable-length inputs?",
          "createdAt": "2020-06-19T10:06:28Z",
          "updatedAt": "2020-06-19T10:06:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Do you think future specifications which specify new KDFs MUST or SHOULD indicate their bounds for variable-length inputs?\r\n\r\nI think `MUST`. :-)",
          "createdAt": "2020-06-19T14:48:24Z",
          "updatedAt": "2020-06-19T14:48:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjA1ODcy",
          "commit": {
            "abbreviatedOid": "9b9edf1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with some edits -- thanks!",
          "createdAt": "2020-06-18T20:01:15Z",
          "updatedAt": "2020-06-18T20:21:59Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nprecise limits on these lengths.\r\n```",
              "createdAt": "2020-06-18T20:01:15Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nused together with them. See {{kdf-input-length}} for exact limits on this length.\r\n```",
              "createdAt": "2020-06-18T20:01:34Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nis available for the inputs `psk`, `pskID`, `info`, `exporter_context`,\r\nthe variable-length parameters provided by HPKE applications.\r\nThe following table lists the maximum allowed lengths of these fields\r\n```",
              "createdAt": "2020-06-18T20:02:39Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            },
            {
              "originalPosition": 45,
              "body": "```suggestion\r\n`LabeledExtract` were computed with the following expression:\r\n```",
              "createdAt": "2020-06-18T20:03:35Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            },
            {
              "originalPosition": 52,
              "body": "```suggestion\r\n~~~\r\nmax_size_hash_input - Nb - size_label_rfcXXXX - size_input_label\r\n~~~\r\n\r\nThe value for `exporter_context` which is an input to `LabeledExpand`\r\nwas computed with the following expression:\r\n```",
              "createdAt": "2020-06-18T20:20:56Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nmax_size_hash_input - Nb - Nh - size_label_rfcXXXX - size_input_label - 2 - 1\r\n```",
              "createdAt": "2020-06-18T20:21:11Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nof \"RFCXXXX \" in bytes and equals 8, and `size_input_label` is the size of\r\n```",
              "createdAt": "2020-06-18T20:21:41Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjU3NDE4",
          "commit": {
            "abbreviatedOid": "9b9edf1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T21:23:34Z",
          "updatedAt": "2020-06-18T21:27:30Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "While I guess it's worth knowing that these limits exist, they seem ... unlikely to ever be hit in reality.",
              "createdAt": "2020-06-18T21:23:35Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTU2NDQ5",
          "commit": {
            "abbreviatedOid": "18178f1"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-19T10:05:43Z",
          "updatedAt": "2020-06-19T10:05:44Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "That's right. I added a couple of words to put it into perspective.",
              "createdAt": "2020-06-19T10:05:43Z",
              "updatedAt": "2020-06-19T10:05:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTM3NjE0",
          "commit": {
            "abbreviatedOid": "18178f1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-19T14:49:56Z",
          "updatedAt": "2020-06-19T14:49:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 118,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2NzYxMzYy",
      "title": "Replace \"desc\" with I2OSP(kem_id, 2).",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/118",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @rozbb ",
      "createdAt": "2020-06-18T21:02:38Z",
      "updatedAt": "2020-06-18T21:30:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "b3cecc3de4419392979ea3217a2137d09694d618",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/derive-key-pair-desc",
      "headRefOid": "72e4e912bbc79ab34a6ee619649d57a8ef753380",
      "closedAt": "2020-06-18T21:30:47Z",
      "mergedAt": "2020-06-18T21:30:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "cbb83fdedad444990351e9f6654f389ce83a1501"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjU1NjYz",
          "commit": {
            "abbreviatedOid": "72e4e91"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Excellent, I was about to propose this.  Glad someone else got to it first :)",
          "createdAt": "2020-06-18T21:20:35Z",
          "updatedAt": "2020-06-18T21:20:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjU2MDE3",
          "commit": {
            "abbreviatedOid": "72e4e91"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-18T21:21:12Z",
          "updatedAt": "2020-06-18T21:21:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 119,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM3MDYwNjUx",
      "title": "Clarify desired security properties",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/119",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is work in progress to address #98, added as a pull request already to have early feedback.",
      "createdAt": "2020-06-19T11:57:28Z",
      "updatedAt": "2020-06-26T21:39:46Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "fb0d45e38435664b602c69953967c9c4485840ca",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_security_properties",
      "headRefOid": "4244901ca7c164126783049d412f934c8874b5a3",
      "closedAt": "2020-06-26T21:39:46Z",
      "mergedAt": "2020-06-26T21:39:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "012709f788ffbafdd99a6e777369f6101296c957"
      },
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "New suggestions, please review. We need to figure out how to formulate that the proofs are not yet analyzing encrypt-to-self and not yet all the curves.\r\n\r\nOh, and I am sorry for the force-pushs; I was experimenting with rebase, apparently unsuccessful.",
          "createdAt": "2020-06-23T13:18:53Z",
          "updatedAt": "2020-06-23T13:23:37Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation @chris-wood I added a reference to NaCl's box. Please see if this is how you want to phrase it.\r\n\r\nIntuitively it sounds like it, but I am not sure if for 0-RTT protocols/primitives, being vulnerable to KCI is equivalent to having reputability. In any way it is interesting how Box phrases it:\r\n\r\n\u201cThe crypto_box function is not meant to provide non-repudiation. On the contrary: the crypto_box function guarantees repudiability. A receiver can freely modify a boxed message, and therefore cannot convince third parties that this particular message came from the sender. The sender and receiver are nevertheless protected against forgeries by other parties. In the terminology of https://groups.google.com/group/sci.crypt/msg/ec5c18b23b11d82c, crypto_box uses \"public-key authenticators\" rather than \"public-key signatures.\"\r\n\r\nUsers who want public verifiability (or receiver-assisted public verifiability) should instead use signatures (or signcryption). Signature support is a high priority for NaCl; a signature API will be described in subsequent NaCl documentation.\u201d",
          "createdAt": "2020-06-25T18:52:21Z",
          "updatedAt": "2020-06-25T18:52:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Intuitively it sounds like it, but I am not sure if for 0-RTT protocols/primitives, being vulnerable to KCI is equivalent to having reputability. \r\n\r\nThat's a good observation -- thanks for adding it! Given that, I'm fine with this PR as is.",
          "createdAt": "2020-06-25T19:04:48Z",
          "updatedAt": "2020-06-25T19:04:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTY5ODAx",
          "commit": {
            "abbreviatedOid": "1d70001"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Good start! Is more text coming?",
          "createdAt": "2020-06-19T15:34:19Z",
          "updatedAt": "2020-06-19T15:36:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nassured that the sender held the corresponding PSK. See {{sec-properties}} for more details.\r\n```\r\n\r\n(We can leave discussion about confidentiality guarantees and properties to the security considerations section.)",
              "createdAt": "2020-06-19T15:34:19Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nassured that the sender held the pre-shared key (PSK). The PSK is also improving the\r\n```\r\n\r\n(If this is the first time \"PSK\" occurs)",
              "createdAt": "2020-06-19T15:34:54Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 52,
              "body": "```suggestion\r\nauthenticate that the sender possessed a given PSK.\r\n```",
              "createdAt": "2020-06-19T15:35:01Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\nThe PSK also improves confidentiality guarantees in certain adversary models, \r\nas described in more detail in {{sec-properties}}. We assume that both parties have\r\nbeen provisioned with both the PSK value `psk` and another byte string\r\n`pskID` that is used to identify which PSK should be used.\r\n```",
              "createdAt": "2020-06-19T15:35:57Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 71,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-06-19T15:36:13Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NjcyMDE4",
          "commit": {
            "abbreviatedOid": "f2422cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks great! Can we pull in some content from #123 here? Once done, I'm good with this to go.",
          "createdAt": "2020-06-25T16:40:56Z",
          "updatedAt": "2020-06-25T16:49:12Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "This isn't quite true (per the KCI problems noted in our offline thread) -- can we adjust this?",
              "createdAt": "2020-06-25T16:40:56Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 179,
              "body": "```suggestion\r\nrecipient keys are the same.\r\n```",
              "createdAt": "2020-06-25T16:43:24Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 201,
              "body": "```suggestion\r\nGiven these properties, pre-shared keys strengthen both the authentication and the \r\nsecrecy properties in certain adversary models. One particular example in which\r\n```",
              "createdAt": "2020-06-25T16:44:09Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 203,
              "body": "```suggestion\r\nnon-quantum-resistant KEM used with HPKE is broken by a\r\n```",
              "createdAt": "2020-06-25T16:44:34Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 202,
              "body": "```suggestion\r\nthis can be useful is a hybrid quantum setting: if a\r\n```",
              "createdAt": "2020-06-25T16:44:41Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 206,
              "body": "```suggestion\r\ncompromised, as described in {{WireGuard}}.\r\n```",
              "createdAt": "2020-06-25T16:44:52Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 216,
              "body": "```suggestion\r\nthe KEM and the AEAD. Analyzing the HPKE instantiation in this\r\ndocument therefore required verifying that the additional KDF calls \r\ndo not cause the IND-CCA2 property to fail, as well as verifying the \r\ntwo additional properties noted above (export key secrecy and \r\nsender authentication).\r\n```",
              "createdAt": "2020-06-25T16:46:00Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 222,
              "body": "```suggestion\r\nfollowing conditions {{HPKEAnalysis}}:\r\n```",
              "createdAt": "2020-06-25T16:47:18Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3Nzc4ODE3",
          "commit": {
            "abbreviatedOid": "4244901"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-25T19:04:07Z",
          "updatedAt": "2020-06-25T19:04:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3OTA4ODMw",
          "commit": {
            "abbreviatedOid": "4244901"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-25T22:45:02Z",
          "updatedAt": "2020-06-25T22:46:45Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "Since there's only one difference, we could just have this as a paragraph: \"The primary difference from the base case is that the calls to ...\"",
              "createdAt": "2020-06-25T22:45:02Z",
              "updatedAt": "2020-06-25T22:46:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3OTA5OTA5",
          "commit": {
            "abbreviatedOid": "4244901"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T22:47:49Z",
          "updatedAt": "2020-06-25T22:47:50Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-06-25T22:47:49Z",
              "updatedAt": "2020-06-25T22:47:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjEwNzE2",
          "commit": {
            "abbreviatedOid": "4244901"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-26T21:39:31Z",
          "updatedAt": "2020-06-26T21:39:31Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "I'll make this change after merging!",
              "createdAt": "2020-06-26T21:39:31Z",
              "updatedAt": "2020-06-26T21:39:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 120,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM3MzAyNjAy",
      "title": "Clarify that DeriveKeyPair is a KEM function.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/120",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @rozbb ",
      "createdAt": "2020-06-19T21:28:45Z",
      "updatedAt": "2020-06-20T18:29:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "98087a20c9e1338078fc6c4970f88daf1f5b9062",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/dkp-to-kem",
      "headRefOid": "93415d303b34101873d7fde68f70b360b540a089",
      "closedAt": "2020-06-20T18:29:11Z",
      "mergedAt": "2020-06-20T18:29:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3e3224b52673898c6975ac3f523bb6e51a3bc8ad"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NDQ1Nzky",
          "commit": {
            "abbreviatedOid": "93415d3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-20T18:29:05Z",
          "updatedAt": "2020-06-20T18:29:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 121,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM4MTkyMTgy",
      "title": "Clarify that not all KEMs can implement the full interface.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/121",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-22T21:41:33Z",
      "updatedAt": "2020-06-22T21:51:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "3e3224b52673898c6975ac3f523bb6e51a3bc8ad",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/authencap",
      "headRefOid": "a0c9bb806990b2bf8b133df064bbf990d22ec48b",
      "closedAt": "2020-06-22T21:51:55Z",
      "mergedAt": "2020-06-22T21:51:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fb0d45e38435664b602c69953967c9c4485840ca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1Mjk1OTY2",
          "commit": {
            "abbreviatedOid": "6518bd6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-22T21:45:07Z",
          "updatedAt": "2020-06-22T21:45:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Nit: \"may\" is not the right verb.  Maybe \"are\".",
              "createdAt": "2020-06-22T21:45:07Z",
              "updatedAt": "2020-06-22T21:51:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1Mjk5Mzg5",
          "commit": {
            "abbreviatedOid": "a0c9bb8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-22T21:51:41Z",
          "updatedAt": "2020-06-22T21:51:42Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That's better -- thanks.",
              "createdAt": "2020-06-22T21:51:41Z",
              "updatedAt": "2020-06-22T21:51:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 122,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM4NTk0OTMy",
      "title": "Use LabeledExpand inside DeriveKeyPair",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/122",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For consistency it would be nice to use LabeledExpand everywhere.\r\n\r\ncc @rozbb ",
      "createdAt": "2020-06-23T14:05:36Z",
      "updatedAt": "2020-06-25T16:43:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "fb0d45e38435664b602c69953967c9c4485840ca",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_derivekeypair_expand",
      "headRefOid": "9104206afcc3691faf5ac4e9eab1978c7bf41207",
      "closedAt": "2020-06-25T16:43:52Z",
      "mergedAt": "2020-06-25T16:43:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "783861e76ba88180b2c638083d3f459d04484a1e"
      },
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In my first commit I forgot about X25519 and X448.\r\n\r\nI changed labels inside DHKEM's ExtractAndExpand to be more consistent with what we did elsewhere so far: have the label be basically the target variable name. Like label \u201cpsk_hash\u201d if we are computing `psk_hash`.\r\n\r\nI added labels for LabeledExtract inside DeriveKeyPair because these calls shall not collide with calls inside ExtractAndExpand. I am not really happy with \u201cdkp_prk\u201d (**D**erive**K**ey**P**air prk) but wanted it to be different from \u201cprk\u201d because that is already used inside ExtractAndExpand. Ideas? **Edited to add**: maybe the colon instead of an underscore will do to more intuitively separate the namespace for the label. Do you realize, we now have namespaces for labels!! :D",
          "createdAt": "2020-06-23T14:28:04Z",
          "updatedAt": "2020-06-23T14:44:24Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh also you can make the counter initial value equal to 0 if you'd like. I had no reason other than \"counter #0\" sounded weird to me",
          "createdAt": "2020-06-25T16:32:29Z",
          "updatedAt": "2020-06-25T16:32:29Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Excellent, thanks, I just pushed your suggestions.",
          "createdAt": "2020-06-25T16:34:05Z",
          "updatedAt": "2020-06-25T16:34:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1ODc0NzEz",
          "commit": {
            "abbreviatedOid": "5a3ce40"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-06-23T15:01:22Z",
          "updatedAt": "2020-06-23T15:02:32Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n  dkp_prk = LabeledExtract(zero(0), concat(I2OSP(kem_id, 2), \"dkp_prk\"), ikm)\r\n```",
              "createdAt": "2020-06-23T15:01:22Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n    bytes = LabeledExpand(dkp_prk, \"candidate\", I2OSP(counter, 1), Nsk)\r\n```",
              "createdAt": "2020-06-23T15:01:35Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            },
            {
              "originalPosition": 19,
              "body": "Can this loop more than 255 times? If so, the encoding of counter might wrap below.",
              "createdAt": "2020-06-23T15:02:01Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n  dkp_prk = LabeledExtract(zero(0), concat(I2OSP(kem_id, 2), \"dkp_prk\"), ikm)\r\n  sk = LabeledExpand(dkp_prk, \"sk\", zero(0), Nsk)\r\n```",
              "createdAt": "2020-06-23T15:02:26Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1ODg2NzYz",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-23T15:13:57Z",
          "updatedAt": "2020-06-23T15:13:57Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Very good question! Maybe @rozbb knows? I'll try to check later, too.",
              "createdAt": "2020-06-23T15:13:57Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1OTQ5NjY5",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-23T16:23:43Z",
          "updatedAt": "2020-06-23T16:23:43Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I'm pretty sure the probability of this looping more than 255 times is negligible. Nevertheless, maybe we can have a short-circuit in that case? That is, inside the loop:\r\n\r\n~~~\r\nif counter > 255:\r\n   raise DeriveKeyPairFailedException()\r\n~~~",
              "createdAt": "2020-06-23T16:23:43Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MzI3OTgz",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-24T05:11:03Z",
          "updatedAt": "2020-06-24T05:15:33Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Indeed, the likelihood of this failing after 255 loops is 1/2^8160. I suppose if we're doing the range check on sk (which is within range with all-but-negligible probability), then it makes sense to do a counter check.\r\n\r\nThe `raise` should either raise a generic Exception with parens, or a specific exception (such as DeriveKeyPairFailed) without parens. I prefer `raise DeriveKeyPairError`, in keeping with other error names",
              "createdAt": "2020-06-24T05:11:03Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            },
            {
              "originalPosition": 16,
              "body": "Is there a downside of putting the kem_id in the salt parameter and omitting the concat operation? It'd be cleaner",
              "createdAt": "2020-06-24T05:14:37Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            },
            {
              "originalPosition": 32,
              "body": "Ditto here for putting kem_id in the salt.",
              "createdAt": "2020-06-24T05:14:59Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MzMwNDM4",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-24T05:18:49Z",
          "updatedAt": "2020-06-24T05:18:49Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Maybe for the sake of consistency you namespace these as well. `eae_prk` and `eae_zz`",
              "createdAt": "2020-06-24T05:18:49Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NjA4ODMx",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-24T12:44:01Z",
          "updatedAt": "2020-06-24T12:44:02Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Yeah, I wondered that myself when implementing the change. ",
              "createdAt": "2020-06-24T12:44:01Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NjA5NTk2",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-24T12:45:06Z",
          "updatedAt": "2020-06-24T12:45:06Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I used `raise` since it matches the notation used elsewhere. I'd treat this sort of failure the same as a `Context.Seal` failure.",
              "createdAt": "2020-06-24T12:45:06Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTMyNzU2",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T14:10:10Z",
          "updatedAt": "2020-06-25T14:10:11Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "[The `salt` parameter is supposed to be random](https://tools.ietf.org/html/rfc5869#section-2.2) and [independent of `ikm`](https://tools.ietf.org/html/rfc5869#section-3.4), so I believe we should not use it to put the constant `kem_id` there.",
              "createdAt": "2020-06-25T14:10:10Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTQ4ODY4",
          "commit": {
            "abbreviatedOid": "eabe01a"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T14:26:22Z",
          "updatedAt": "2020-06-25T14:26:23Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Added the check with the most recent commit. Are you fine with having the check directly at the beginning?\r\n\r\nDo you like adding the probability of failure? How was it calculated by the way?\r\n\r\nOh, and why does the counter start with 1? If it started with 0, we would win one trial before failing. Very improbable that this one more trial makes a difference, sure ;)",
              "createdAt": "2020-06-25T14:26:23Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTQ5Nzgx",
          "commit": {
            "abbreviatedOid": "eabe01a"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T14:27:20Z",
          "updatedAt": "2020-06-25T14:27:21Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I changed to `eae_prk`, but left zz untouched, because zz is unique, and we also did not namespace sk (because it is unique as well).",
              "createdAt": "2020-06-25T14:27:21Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTYyMjk2",
          "commit": {
            "abbreviatedOid": "eabe01a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T14:39:21Z",
          "updatedAt": "2020-06-25T14:39:21Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Yeah, it would be \"misuse\", but I don't think it makes any difference internally. Anyway, fine to leave this as is!",
              "createdAt": "2020-06-25T14:39:21Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTYzMDI2",
          "commit": {
            "abbreviatedOid": "eabe01a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-25T14:40:05Z",
          "updatedAt": "2020-06-25T14:40:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTczMTQz",
          "commit": {
            "abbreviatedOid": "eabe01a"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T14:50:24Z",
          "updatedAt": "2020-06-25T14:50:24Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I would just say \"negligible\", since the value varies from group to group.\r\n\r\nIf you're curious how I came to this number for P-256: the probability of one iteration failing is (2^256 - order)/2^256 = 2^-32. Then 255 iterations gives you that number.",
              "createdAt": "2020-06-25T14:50:24Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTgxNzgy",
          "commit": {
            "abbreviatedOid": "8e6ff2c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T14:58:59Z",
          "updatedAt": "2020-06-25T14:58:59Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Oh right, thanks for this remark, I changed to \u201cnegligible\u201d.\r\n\r\nThanks for the clarification on how you computed the probability.",
              "createdAt": "2020-06-25T14:58:59Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NjYzMDY5",
          "commit": {
            "abbreviatedOid": "8e6ff2c"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good! I would only tweak the wording slightly to say \"The precise likelihood of DeriveKeyPair failing with DeriveKeyPairError depends on the group being used, but it is negligibly small in all cases.\"",
          "createdAt": "2020-06-25T16:29:22Z",
          "updatedAt": "2020-06-25T16:30:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3Njc0MTg3",
          "commit": {
            "abbreviatedOid": "9104206"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-25T16:43:44Z",
          "updatedAt": "2020-06-25T16:43:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQwMTM0MzQy",
      "title": "Note KCI problems with Auth and AuthPSK.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/123",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The NaCL/libsodium [Box API](https://libsodium.gitbook.io/doc/public-key_cryptography/authenticated_encryption)) has the same problem, so perhaps HPKE should acknowledge this and move on. Alternatively, we might consider either augmenting AuthEncap/AuthDecap to address this issue, or dropping the Auth and AuthPSK modes entirely. \r\n\r\ncc @jedisct1",
      "createdAt": "2020-06-25T16:35:01Z",
      "updatedAt": "2020-06-25T19:05:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "fb0d45e38435664b602c69953967c9c4485840ca",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/kci-note",
      "headRefOid": "4021d811cf05c8c7d4c7b6134b3602554d7608e6",
      "closedAt": "2020-06-25T19:05:18Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In #119 I also made an attempt to mention KCI, see https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/119/files#diff-0ad9f9135e8a024768ba9765798d4738R1002. So we might merge, or take \u201cSecurity Properties\u201d as proposed in #119 and add a link to this new \u201cKey-Compromise Impersonation\u201d section (I like your suggestion to say that signatures could be used by the application to mitigate this).",
          "createdAt": "2020-06-25T16:42:04Z",
          "updatedAt": "2020-06-25T16:42:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I'm reviewing that now and just noticed it! Can we cite the paper I mention here for KCI, and then also mention the signature workaround?",
          "createdAt": "2020-06-25T16:48:12Z",
          "updatedAt": "2020-06-25T16:48:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was moved to #119. Closing.",
          "createdAt": "2020-06-25T19:05:18Z",
          "updatedAt": "2020-06-25T19:05:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3Njc3Nzg5",
          "commit": {
            "abbreviatedOid": "4021d81"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-25T16:48:07Z",
          "updatedAt": "2020-06-25T16:48:12Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Do you want to note that predecessors such as libnacl Box also have this issue?",
              "createdAt": "2020-06-25T16:48:08Z",
              "updatedAt": "2020-06-25T16:48:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3Njc4OTky",
          "commit": {
            "abbreviatedOid": "4021d81"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T16:49:41Z",
          "updatedAt": "2020-06-25T16:49:42Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Yeah, let's do it. @blipp, can you do this in your PR?",
              "createdAt": "2020-06-25T16:49:42Z",
              "updatedAt": "2020-06-25T16:49:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 124,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQwMzkxNTk2",
      "title": "Remove unnecessary KEM binding",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/124",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The KEM binding in LabeledExpand inside ExtractAndExpand is superfluous, since the KEM is already included in the LabeledExtract call. Further, KEM ID isn't included in a LabeledExpand call anywhere else in the spec.\r\n\r\nBesides that, I noticed the new lines were rendering long so I picked a multiline formatting style that looked good to me and applied it consistently.",
      "createdAt": "2020-06-26T05:38:34Z",
      "updatedAt": "2020-07-03T23:52:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "783861e76ba88180b2c638083d3f459d04484a1e",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "labeling-fixes",
      "headRefOid": "552a32e7ab2d95b78ff82679a1481e24fb90dd2a",
      "closedAt": "2020-07-03T23:52:00Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This raises an important point. I touched this topic briefly in https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/112#discussion_r442157565:\r\n\r\n \u201c[\u2026] binding to the [kem_id] plays a similar role as the RFCXXXX label which we do include in *both* LabeledExtract and LabeledExpand, even if the LabeledExtract results are never exposed. [\u2026] this is about [\u2026] that the calls are orthogonal, which makes it easier to reason with separate random oracles for separate ciphersuites (and DHKEM is kind of a sub-standard inside this RFC, so it makes sense to have RFCXXXX and the DHKEM group as a label).\u201d\r\n\r\nI thought about this again for a while today. I start thinking that we should just put the entire ciphersuite identifier as a label, along with \"RFCXXXX \". For a DHKEM, the \u201centire ciphersuite\u201d is only the `kem_id`, but for the remainder of HPKE, it is `kem_id`, `kdf_id`, `aead_id`.\r\n\r\n```\r\nciphersuite (KEM) = I2OSP(kem_id, 2)\r\n\r\nciphersuite (remainder) = concat(\r\n  I2OSP(kem_id, 2),\r\n  I2OSP(kdf_id, 2),\r\n  I2OSP(aead_id, 2))\r\n\r\ndef LabeledExtract(salt, label, IKM):\r\n  labeledIKM = concat(\"RFCXXXX \", ciphersuite, label, IKM)\r\n  return Extract(salt, labeledIKM)\r\n\r\ndef LabeledExpand(PRK, label, info, L):\r\n  labeledInfo = concat(I2OSP(L, 2), \"RFCXXXX \", ciphersuite, label, info)\r\n  return Expand(PRK, labeledInfo, L)\r\n```\r\n\r\nPackaging this into the KDF removes it as clutter from ExtractAndExpand and DeriveKeyPair, and would also simplify KeySchedule. So maybe this can unite advantages for both worlds: cleaner implementation, and good for proofs.\r\n\r\nI arrived here when thinking about why it is that we do not bind the following line to the ciphersuite:\r\n\r\n```\r\nsecret = LabeledExtract(psk_hash, \"secret\", zz)\r\n```\r\n\r\nwhile the 3 LabeledExpands in KeySchedule do have the ciphersuite within `key_schedule_context`, but then again the LabeledExpand in Context.Export does not have the ciphersuite explicitly. So again, just having the ciphersuite within LabeledExtract and LabeledExpand might make this all cleaner.",
          "createdAt": "2020-06-26T17:24:52Z",
          "updatedAt": "2020-06-26T17:24:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@rozbb this should be addressed by #127, so I'm closing as such. Please re-open if you disagree!",
          "createdAt": "2020-07-03T23:52:00Z",
          "updatedAt": "2020-07-03T23:52:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 125,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQwNjg2NzQy",
      "title": "Add Ben as an author.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/125",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's about time I did this!",
      "createdAt": "2020-06-26T16:50:47Z",
      "updatedAt": "2020-06-26T18:23:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "783861e76ba88180b2c638083d3f459d04484a1e",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/add-ben",
      "headRefOid": "3baea1bdd5255daa1e8915f9f955f71767c3dd5e",
      "closedAt": "2020-06-26T18:23:53Z",
      "mergedAt": "2020-06-26T18:23:53Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2968b963d3bbb692da2b3be174ba3ae509360c27"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NDcxNjU5",
          "commit": {
            "abbreviatedOid": "cdbcf87"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you, really happy and honored to be on this team :)",
          "createdAt": "2020-06-26T17:27:34Z",
          "updatedAt": "2020-06-26T17:30:43Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n    org: Inria\r\n```\r\n\r\nLet's do `Inria`, because I only recently learned that this is the new preferred writing of the institute. And Karthik does not have `Paris`, so I'd drop that too for consistency.",
              "createdAt": "2020-06-26T17:27:35Z",
              "updatedAt": "2020-06-26T18:23:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 126,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQwODA3Njc0",
      "title": "Unify domain separation by including algorithm identifiers in each Extract and Expand call.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/126",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For DHKEM, the identifier is the KEM ID. For everything else, the identifier is\r\nthe combination of one-byte mode identifier and HPKE ciphersuite tuple.\r\n\r\nThis does more binding, in contrast to what's in #124.\r\n\r\ncc @blipp",
      "createdAt": "2020-06-26T22:13:25Z",
      "updatedAt": "2020-06-29T15:03:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0a5f53924207f33d7d10f20647dfc7b2263a7bfa",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/unify-separation",
      "headRefOid": "a74f88962ca46cb04d84e1073831644970f9f345",
      "closedAt": "2020-06-29T15:03:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I submitted an alternative approach with #127. It has the advantage that `Context.Export` also gets to use the `identifier`, which would need an API change if `identifier` is explicit.",
          "createdAt": "2020-06-29T14:59:55Z",
          "updatedAt": "2020-06-29T15:00:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The proposal in #127 is cleaner -- closing!",
          "createdAt": "2020-06-29T15:03:33Z",
          "updatedAt": "2020-06-29T15:03:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MjMwMzgz",
          "commit": {
            "abbreviatedOid": "a74f889"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T14:58:12Z",
          "updatedAt": "2020-06-29T14:58:13Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "```suggestion\r\n  sk = LabeledExpand(dkp_prk, concat(I2OSP(kem_id, 2), \"sk\"), zero(0), Nsk)\r\n```",
              "createdAt": "2020-06-29T14:58:13Z",
              "updatedAt": "2020-06-29T14:58:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQxNDcxMzQy",
      "title": "Unify separation by implicitly including algorithm identifiers",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/127",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I would like to make an alternative proposition to #126, based on it.\r\n\r\nIn this proposition, `identifier` is used as implicit parameter to `LabeledExtract` and `LabeledExpand`. This can be justified because the document already assumes that `kem_id`, `kdf_id`, `aead_id` are implicitly encoded into the implementation. The advantage of having `identifier` implicit is that this removes clutter from the other function definitions; this might make implementation work easier because the calls to LabeledExtract and LabeledExpand then have fewer nested parameters.\r\n\r\nOn the question if `mode` should be in the identifier: if `mode` should be in the identifier, it is hard to let `identifier` be an implicit parameter, because the `mode` parameter is an explicit parameter (which is needed for `VerifyPSKInputs`). I thought about if we can find a reason why *not* including `mode` in the identifier is justified from a provable security point-of-view. I came to the conclusion this works out, because:\r\n\r\nThe first calls in `KeySchedule` are, from a variable dependencies point of view:\r\n```\r\n  psk_hash = LabeledExtract(zero(0), \"psk_hash\", psk)\r\n  secret = LabeledExtract(psk_hash, \"secret\", zz)\r\n```\r\n\r\nAll the following KDF calls include `mode` because it is in the `key_schedule_context`, so those are safe. Values of `secret` cannot collide between different modes, because:\r\n- `zz` is the same for the Base and PSK modes, but `psk_hash` is different for these modes (default_psk vs non-defaut)\r\n- `zz` is the same for the Auth and AuthPSK modes, but `psk_hash` is different for these modes (default_psk vs non-defaut)\r\n\r\nThis means we do not need to domain-separate by the mode in each call, because the two LabeledExtracts above already have a clear-enough dependency on the mode; which allows us to have `identifier` be implicit and have cleaner function definitions.",
      "createdAt": "2020-06-29T14:56:46Z",
      "updatedAt": "2020-07-03T23:51:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d7d2e75d773828134061c1a0c0704427cdad13bb",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_unify_separation",
      "headRefOid": "ee025a6039cbbd3aad7bcaf1a6bd41a5741bba5b",
      "closedAt": "2020-07-03T23:51:27Z",
      "mergedAt": "2020-07-03T23:51:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ba9dd084c17f661b9c50a115c1dba2e336374d42"
      },
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- I resolved the possible collision between the KEM KDF calls and the remainder of HPKE by adding `KEM` and `DEM` after `RFCXXXX `. I feel like this was overdue anyway.\r\n- I changed `identifier` to `suite_id`.\r\n- Regarding @bifurcation's comment\r\n> This seems likely to be confused. Would it be clearer to add the identifier as a parameter to these methods, and explicitly pass in the right one?\r\n\r\nHm, I am torn on this one. These two possibly *different* KDFs that are both referenced with the *same names* `LabeledExtract` and `LabeledExpand` have been in the document since we added a KDF in the KEM. Adding `suite_id` just makes this possible confusion problem more apparent I guess. The test vectors will catch it at the end, but if we can make the confusion less likely, it would be nice for the developers.\r\n\r\nI am fond of the idea to leave `suite_id` implicit, because making it explicit will clutter the calls to `LabeledExtract` and `LabeledExpand`. What else could we do? Separate names like `LabeledExtractKEM` and `LabeledExtractDEM`?",
          "createdAt": "2020-07-01T12:05:44Z",
          "updatedAt": "2020-07-01T12:05:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am fond of the idea to leave suite_id implicit, because making it explicit will clutter the calls to LabeledExtract and LabeledExpand. What else could we do? Separate names like LabeledExtractKEM and LabeledExtractDEM?\r\n\r\nI'm not sure I see much difference between a separate name for the DHKEM LabeledExtract/Expand functions, and passing the suite_id in as a parameter to the existing LabeledExtract/Expand functions. On balance, I think I also prefer what's currently written (implicit parameters). ",
          "createdAt": "2020-07-01T16:50:53Z",
          "updatedAt": "2020-07-02T18:17:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MjM2MjI1",
          "commit": {
            "abbreviatedOid": "8750089"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice! @bifurcation, please have a look.",
          "createdAt": "2020-06-29T15:04:16Z",
          "updatedAt": "2020-06-29T15:05:27Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-06-29T15:04:16Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MzYyODE0",
          "commit": {
            "abbreviatedOid": "723333c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T17:38:59Z",
          "updatedAt": "2020-06-29T17:43:38Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "This seems likely to be confused.  Would it be clearer to add the identifier as a parameter to these methods, and explicitly pass in the right one?",
              "createdAt": "2020-06-29T17:38:59Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            },
            {
              "originalPosition": 27,
              "body": "Note that the suite ID is a different length than the individual KEM ID.  Do we need to worry about collision with the label?",
              "createdAt": "2020-06-29T17:40:04Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            },
            {
              "originalPosition": 80,
              "body": "`suite_id`  for consistency?",
              "createdAt": "2020-06-29T17:41:47Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5Mzc3MDkw",
          "commit": {
            "abbreviatedOid": "723333c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T17:59:13Z",
          "updatedAt": "2020-06-29T17:59:13Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "> Note that the suite ID is a different length than the individual KEM ID. Do we need to worry about collision with the label?\r\n\r\nUh, good one. Yes, theoretically `aead_id` could collide with the labels `eae_prk` and `zz`. Not for the AEADs in the current document though: `hex(ord(\"z\"))` is `0x7a` and `hex(ord(\"e\"))` is `0x65`, and all current AEADs have 0s in the first byte.\r\n\r\nWe could have the `suite_id` for the KEMs be `concat(I2OSP(kem_id, 2), zero(4))` to avoid that forever.",
              "createdAt": "2020-06-29T17:59:13Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMDA2NTkz",
          "commit": {
            "abbreviatedOid": "5ffb00c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "One nit, otherwise LGTM.",
          "createdAt": "2020-07-02T20:42:39Z",
          "updatedAt": "2020-07-02T20:49:08Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Nit: I would use \"HPKE\" for the non-KEM thing.",
              "createdAt": "2020-07-02T20:42:39Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzE5NTA4",
          "commit": {
            "abbreviatedOid": "01834ff"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-03T10:33:28Z",
          "updatedAt": "2020-07-03T10:33:29Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Good point \u2013 I just made this change.",
              "createdAt": "2020-07-03T10:33:28Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 129,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQxNTQzOTQy",
      "title": "Add GenerateKeyPair for use in Encap and AuthEncap.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/129",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #128.",
      "createdAt": "2020-06-29T17:12:07Z",
      "updatedAt": "2020-06-29T17:58:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0a5f53924207f33d7d10f20647dfc7b2263a7bfa",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/add-gkp",
      "headRefOid": "a4cded73cd66c52297b558cd2eb292351f65158f",
      "closedAt": "2020-06-29T17:58:27Z",
      "mergedAt": "2020-06-29T17:58:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d7d2e75d773828134061c1a0c0704427cdad13bb"
      },
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That changes makes a lot of sense. Maybe we could add some comment somewhere in the document saying why we need `DeriveKeyPair` (it is for static keys)?",
          "createdAt": "2020-06-29T17:20:54Z",
          "updatedAt": "2020-06-29T17:20:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Maybe we could add some comment somewhere in the document saying why we need DeriveKeyPair (it is for static keys)\r\n\r\nI'm inclined to leave that off for now, if only because the output of DKP and GKP is indistinguishable, so applications may use either as they see fit.",
          "createdAt": "2020-06-29T17:24:45Z",
          "updatedAt": "2020-06-29T17:56:36Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should remember to add test vectors for DeriveKeyPair \u2013 as it is not used in (Auth)Encap anymore, it is not covered by the current test vectors.",
          "createdAt": "2020-06-29T17:44:16Z",
          "updatedAt": "2020-06-29T17:44:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp -- I resolved this by just noting that folks can implemented GKP using DKP. ",
          "createdAt": "2020-06-29T17:55:15Z",
          "updatedAt": "2020-06-29T17:55:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MzUxMTQz",
          "commit": {
            "abbreviatedOid": "34fe14e"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T17:22:53Z",
          "updatedAt": "2020-06-29T17:22:54Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n  - GenerateKeyPair(): Generate a key pair (skX, pkX)\r\n```",
              "createdAt": "2020-06-29T17:22:53Z",
              "updatedAt": "2020-06-29T17:56:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MzUxNTI1",
          "commit": {
            "abbreviatedOid": "34fe14e"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T17:23:24Z",
          "updatedAt": "2020-06-29T17:23:25Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n- GenerateKeyPair(): Generate an ephemeral key pair `(skX, pkX)`\r\n```",
              "createdAt": "2020-06-29T17:23:24Z",
              "updatedAt": "2020-06-29T17:56:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5Mzc2NDA1",
          "commit": {
            "abbreviatedOid": "a4cded7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-29T17:58:16Z",
          "updatedAt": "2020-06-29T17:58:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 130,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ1NDgzNzgy",
      "title": "Clarify input types for pkR, pkS, enc",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/130",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It is implicitly clear from the body of (Auth)Encap and (Auth)Decap, that `pkR` and `pkS` are supposed to be deserialized public keys and `enc` a serialized public key. This suggested change makes it explicit.",
      "createdAt": "2020-07-07T15:20:23Z",
      "updatedAt": "2020-07-08T12:47:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "ba9dd084c17f661b9c50a115c1dba2e336374d42",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_input_types",
      "headRefOid": "5058b4a3d56c0d653135e92de3af7a8ac6493d52",
      "closedAt": "2020-07-08T12:47:05Z",
      "mergedAt": "2020-07-08T12:47:05Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1c7c34dbbb4be02331d2cf77ecef4e06361c7ccd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzI4MTc0",
          "commit": {
            "abbreviatedOid": "5058b4a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-08T12:47:00Z",
          "updatedAt": "2020-07-08T12:47:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 131,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ1NjIxMjA2",
      "title": "Prepare for future KEMs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/131",
      "state": "OPEN",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is work in progress and addresses #84 \u201cGuidance for future KEMs\u201d.\r\n\r\nNotes on public key length:\r\n- It seems that in SIKE, the uncompressed public key length is fixed, and [the compressed size is also fixed](https://hyp.is/-Ks_uMB1EeqREaPjYYE8nQ/eprint.iacr.org/2020/431.pdf), but smaller. I did not check all the NIST candidates so see if others do something similar. Especially I did not look if someone does variable size public keys, like, an entire range of sizes. Do you think we need to accommodate for this more explicitly? I made a small note down in `IANA Considerations/KEM Identifiers`.\r\n- In SIKE, Encaps and Decaps always take uncompressed public keys as inputs, so the caller is supposed to do the decompression, if necessary.\r\n- We do already say explicitly that for P256, P384, P521, HPKE uses **un**compressed public key encoding. I guess that is due to the current of implementations? It seems for post-quantum KEMs it is interesting to leave both possibilities open, uncompressed and compressed, because some devices might not have the computation power to do (de)compression.\r\n\r\nNotes on security requirements:\r\n- I removed the explicit requirement that `enc`, `pkR`, `pkS` must be included into the context of the KEM's key derivation. What we need is IND-CCA2 security, and if a KEM has that without these in the context, that is completely fine.\r\n\r\nDONE:\r\n- see if RSA fits into this already, as mentioned in #84.\r\n- I did not yet look at the \u201crelationship between the private key and the public key\u201d as mentioned in #84.\r\n\r\nTODO\r\n- See if any NIST candidates have different encodings for KEM ciphertexts\r\n- Do the proofs for the new security notions and update the text accordingly.\r\n- use these new notions in the main Security Considerations text?\r\n\r\nFeedback welcome especially on:\r\n- is it good to make `OPTIONAL` all-caps for GenerateKeyPair, DeriveKeyPair, AuthEncap, AuthDecap?\r\n- different public key sizes: do you think the formulations work?\r\n- It occurred to me that KEM ciphertexts might as well also have different encodings. I did not check yet if any of the NIST candidates do (this is a lot of reading work)",
      "createdAt": "2020-07-07T19:36:28Z",
      "updatedAt": "2020-07-16T14:15:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "372b02c3dd8fbc46c01d66ac661b6eba0d4e4311",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_kem_guidance",
      "headRefOid": "d39bacbe21387ddb4f1391c2257766a845bd136d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> is it good to make OPTIONAL all-caps for GenerateKeyPair, DeriveKeyPair, AuthEncap, AuthDecap?\r\n\r\nI'm fine with all-caps, though I'm not sure GenerateKeyPair is optional. That seems to be pretty essential.\r\n\r\n> different public key sizes: do you think the formulations work?\r\n\r\nI'm not sure. I'd suggest Npk/Nenc representing maximum values, and the serialize/deserialize functions being able to parse inputs up to that size.\r\n\r\n> It occurred to me that KEM ciphertexts might as well also have different encodings. I did not check yet if any of the NIST candidates do (this is a lot of reading work)\r\n\r\nCertainly if public keys have different sizes then their encodings would too, right?",
          "createdAt": "2020-07-08T12:46:27Z",
          "updatedAt": "2020-07-08T12:46:27Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The plan is to define adapted security notions for the authenticated KEM interface inside the Section \u201cSecurity Requirements on a KEM used within HPKE\u201d. With a bit of luck this can be ready for Monday, but in the meantime, this version cites the already available definitions. The adapted security notions will be more optimal for HPKE.",
          "createdAt": "2020-07-10T19:43:00Z",
          "updatedAt": "2020-07-10T19:43:00Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "New draft which formulates a bit more careful the security requirements on a KEM: if there is a proof of the full HPKE with the new KEM, then that is fine, and we do not require any particular proofs on the KEM; we only indicate that if the KEM satisfies some security notion, then the existing compositions results provide some indication that this is fine for the entire HPKE, then.\r\n\r\nI do not think that the new security notions and composition proofs adapted to HPKE will be ready enough by tomorrow such that we could, with confidence, already define them in the document. I think citing this signcryption book from 2010 is the best we can do for now, and I'll discuss with the others if they know any other more fitting reference.",
          "createdAt": "2020-07-12T17:05:17Z",
          "updatedAt": "2020-07-12T17:05:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> New draft which formulates a bit more careful the security requirements on a KEM: if there is a proof of the full HPKE with the new KEM, then that is fine, and we do not require any particular proofs on the KEM; we only indicate that if the KEM satisfies some security notion, then the existing compositions results provide some indication that this is fine for the entire HPKE, then.\r\n\r\nThanks! I think this is a fine way to capture the requirements. ",
          "createdAt": "2020-07-13T15:00:16Z",
          "updatedAt": "2020-07-13T15:00:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzE1Njk0",
          "commit": {
            "abbreviatedOid": "db9b2c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "First pass complete. Good first start!",
          "createdAt": "2020-07-08T12:30:52Z",
          "updatedAt": "2020-07-08T12:44:45Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This seems like an implementation detail, so I'd remove it.",
              "createdAt": "2020-07-08T12:30:52Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 28,
              "body": "Hmm, this seems mandatory since it's used in Encap, no? Is the idea that future Encaps might not have a key generation function? If not, how would keys, well, be generated?",
              "createdAt": "2020-07-08T12:31:49Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 181,
              "body": "I'm not sure Insider-CCA-secure and insider-Auth-secure are common terms. We should probably define them.",
              "createdAt": "2020-07-08T12:41:22Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 205,
              "body": "Maybe this should be the maximum length of an encapsulated key? The text below (suggesting that there are different lengths that need to be specified) seems odd. Really this value is in place to help with allocations and whatnot, right?",
              "createdAt": "2020-07-08T12:42:58Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 209,
              "body": "Same suggestion here for maximum length.",
              "createdAt": "2020-07-08T12:43:09Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 124,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-07-08T12:43:26Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 35,
              "body": "Using a single constant to refer to multiple values seems error prone. Can we avoid this?",
              "createdAt": "2020-07-08T12:44:35Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzMxNDg2",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T12:51:14Z",
          "updatedAt": "2020-07-08T12:51:15Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "```suggestion\r\nSince an encapsulated key is a Diffie-Hellman public key in this KEM algorithm,\r\n`SerializePublicKey` and `SerializeCiphertext` are equivalent (`Npk` = `Nenc`).\r\nThus, we implement both using a single function called `Serialize`. `Deserialize`\r\nis implemented similarly.\r\n```",
              "createdAt": "2020-07-08T12:51:14Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzMxNTMx",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T12:51:17Z",
          "updatedAt": "2020-07-08T12:51:18Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I added this because #84 mentioned that for example RSA does not have this clear of a relation between public key and secret key; at least computing the public key from the secret key involves a lot of computation in RSA. We could mention it elsewhere in the document? Maybe just move the new text to the Future KEMs section?",
              "createdAt": "2020-07-08T12:51:17Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzMxOTE2",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T12:51:46Z",
          "updatedAt": "2020-07-08T12:51:46Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Should we this `SerializeEncapsulatedKey`, rather than ciphertext? (That would align better with the KEM vocabulary, I think.)",
              "createdAt": "2020-07-08T12:51:46Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzM1MzE0",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T12:55:54Z",
          "updatedAt": "2020-07-08T12:55:55Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "For DHKEM it is mandatory because it is used in Encap/Decap as you say. Other KEMs, and RSA for example, do not use it in Encap. For these KEMs, the HPKE implementation can receive the keys from outside (the higher-level application). The keys would then also be assumed to be generated by the application. The RFCs mentioning RSA KEMs https://tools.ietf.org/html/rfc5990 and https://tools.ietf.org/html/rfc8017 for example do not mention key generation at all.",
              "createdAt": "2020-07-08T12:55:54Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzM2Nzk4",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T12:57:38Z",
          "updatedAt": "2020-07-08T12:57:39Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "Yes, we should define them somehow. Similar notions have been around in Signcryption literature for a while, but it is true that they are not so commen, and also the notions I am working on with the others are a bit different. Should we define them in an appendix?",
              "createdAt": "2020-07-08T12:57:39Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzQwMTAz",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T13:01:33Z",
          "updatedAt": "2020-07-08T13:01:33Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Having said that, I agree that saying `OPTIONAL` if the DHKEMs defined in the document definitely require it, is odd. We could write optional in lowercase, or don't mention it in the Cryptographic Dependencies section at all and only leave the explanation in the Future KEMs section. Do you have a preference?",
              "createdAt": "2020-07-08T13:01:33Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzQxNDg3",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T13:03:15Z",
          "updatedAt": "2020-07-08T13:03:15Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": ":+1: ",
              "createdAt": "2020-07-08T13:03:15Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzQ0Mjcy",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T13:06:27Z",
          "updatedAt": "2020-07-08T13:06:27Z",
          "comments": [
            {
              "originalPosition": 205,
              "body": "I like your idea of the maximum length. For the NIST P-curves, the deserialize algorithm is actually specified this way: it takes up to the maximum length, and a condition inside decides if decompression is done, depending on the actually received size.",
              "createdAt": "2020-07-08T13:06:27Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzQ0OTI4",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T13:07:15Z",
          "updatedAt": "2020-07-08T13:07:15Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": ":+1: ",
              "createdAt": "2020-07-08T13:07:15Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0ODcxMTky",
          "commit": {
            "abbreviatedOid": "c79a5da"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T15:16:55Z",
          "updatedAt": "2020-07-08T15:16:55Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Moved to Future KEMs for now.",
              "createdAt": "2020-07-08T15:16:55Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0ODc2MzI5",
          "commit": {
            "abbreviatedOid": "c79a5da"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T15:22:30Z",
          "updatedAt": "2020-07-08T15:22:30Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I reverted all my changes related to making these functions optional, because:\r\n- For GenerateKeyPair, any KEM (and RSA too) can just write something like \u201cGenerateKeyPair is defined as in [reference]\u201d and fullfil the requirement easily like this.\r\n- DeriveKeyPair(ikm): here, I see two possibilities:\r\n  * any KEM (and also RSA) could just pass a complete keypair `sk, pk` to the function and let the function be the identity function\r\n  * any KEM (and also RSA) could pass whatever encoding of a complete keypair to the function and let the function be the deserialization of this encoding.\r\n\r\nDo we need to mention this in the document?",
              "createdAt": "2020-07-08T15:22:30Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTA0NjYx",
          "commit": {
            "abbreviatedOid": "c79a5da"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T15:53:54Z",
          "updatedAt": "2020-07-08T15:53:54Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "Eh... maybe? Or inline here?",
              "createdAt": "2020-07-08T15:53:54Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTA0ODkz",
          "commit": {
            "abbreviatedOid": "c79a5da"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T15:54:08Z",
          "updatedAt": "2020-07-08T15:54:08Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-07-08T15:54:08Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTA1NTM0",
          "commit": {
            "abbreviatedOid": "c79a5da"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T15:54:48Z",
          "updatedAt": "2020-07-08T15:54:49Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I don't think it's necessary. Thanks!",
              "createdAt": "2020-07-08T15:54:48Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2Nzk5NDc5",
          "commit": {
            "abbreviatedOid": "2ccc436"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-11T12:26:19Z",
          "updatedAt": "2020-07-11T12:31:56Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "This feels out of place in this section. Perhaps this should go underneath the KEM interface description? (That is, right below the list of functions.)",
              "createdAt": "2020-07-11T12:26:19Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 229,
              "body": "To clarify: does DHKEM achieve this notion?",
              "createdAt": "2020-07-11T12:27:40Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 230,
              "body": "I might remove this. I can't see a case where KCI resistance would not be desirable.",
              "createdAt": "2020-07-11T12:28:23Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 99,
              "body": "Some of these list items have a terminating period, and others don't. Can we add periods to all list items (here and above)?",
              "createdAt": "2020-07-11T12:29:46Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 19,
              "body": "I'm dubious about referencing signcryption... as I understand it, this is far more nascent than the other foundational work we cite.",
              "createdAt": "2020-07-11T12:31:56Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2Nzk5ODE2",
          "commit": {
            "abbreviatedOid": "2ccc436"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM modulo some nits!",
          "createdAt": "2020-07-11T12:32:05Z",
          "updatedAt": "2020-07-11T12:32:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODA5MDE5",
          "commit": {
            "abbreviatedOid": "2ccc436"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-11T15:15:41Z",
          "updatedAt": "2020-07-11T15:15:41Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "DHKEM is not \u201cmulti-user insider strongly unforgeable (sUF-CMA-secure)\u201d because of KCI.",
              "createdAt": "2020-07-11T15:15:41Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODA5MDIy",
          "commit": {
            "abbreviatedOid": "2ccc436"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-11T15:15:45Z",
          "updatedAt": "2020-07-11T15:15:45Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "True, but at the same time, DHKEM is not resistant against KCI and thus falls into this category (that's why I added this sentence).",
              "createdAt": "2020-07-11T15:15:45Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODA5MDI3",
          "commit": {
            "abbreviatedOid": "2ccc436"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-11T15:15:48Z",
          "updatedAt": "2020-07-11T15:15:48Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "It is right that it there is a lot of movement in the field of signcryption. That is part of the reason why notions adapted to HPKE are in the works. I'll inline the notions, then we see if this looks alright.",
              "createdAt": "2020-07-11T15:15:48Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MzMwOTk0",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-13T14:57:39Z",
          "updatedAt": "2020-07-13T14:57:39Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "Doh, right, yes. Thanks!",
              "createdAt": "2020-07-13T14:57:39Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MTk2NzIz",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-15T17:53:08Z",
          "updatedAt": "2020-07-15T18:02:57Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "It seems like we can take a simpler approach here.  The only things **required by this document** are: `SerializePublicKey`, `Encap`, and `Decap`.  `Encap` is already supposed to produce a fixed-length encapsulated value, and `Decap` to consume it, so there is no need for separate serialization.  `DeserializePublickey` should just be deleted, since it's not used in this document.",
              "createdAt": "2020-07-15T17:53:09Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 88,
              "body": "Disagree with this change.  Making these values \"maximum\" implies that the fields they describe are variable-length, but `SerializePublicKey` and `Encap` both produce fixed-size values.  \r\n\r\nIf we do in fact need to have variable-length values, that will complicate encoding, so it would be preferable to keep things fixed.",
              "createdAt": "2020-07-15T17:55:17Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 124,
              "body": "This might depend on implementation details as well.",
              "createdAt": "2020-07-15T17:56:19Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 150,
              "body": "If you are going to name the errors above, name them here as well.  I would prefer to name them neither place, to be honest.",
              "createdAt": "2020-07-15T17:57:24Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 238,
              "body": "Having multiple different equivalent encodings seems like a bad idea.   Why are we accommodating this?",
              "createdAt": "2020-07-15T18:00:50Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            },
            {
              "originalPosition": 261,
              "body": "\"There are indications\" is quite vague.  What indications?\r\n\r\nOr do you mean \"the following criteria are sufficient to meet HPKE's security needs\"?",
              "createdAt": "2020-07-15T18:02:39Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjA3MTA1",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-15T18:05:39Z",
          "updatedAt": "2020-07-15T18:05:39Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "This change takes the complexity hit so that future documents don't need to. If we don't want this complexity, then I concur with the simplification above. (I don't think it's much complexity, so I'm OK adding it here.)",
              "createdAt": "2020-07-15T18:05:39Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjA3NTY2",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-15T18:06:15Z",
          "updatedAt": "2020-07-15T18:06:16Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "> Disagree with this change. Making these values \"maximum\" implies that the fields they describe are variable-length, but SerializePublicKey and Encap both produce fixed-size values.\r\n\r\nThat's correct -- they *may* be variable length for future KEMs. ",
              "createdAt": "2020-07-15T18:06:15Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjA3NjQy",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-15T18:06:21Z",
          "updatedAt": "2020-07-15T18:06:21Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-07-15T18:06:21Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjIxODkw",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-15T18:26:28Z",
          "updatedAt": "2020-07-15T18:26:28Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "I think this is just a presentation issue. It may be the case that future KEMs output encapsulated keys with non-fixed-length. So we can either (a) require that those KEMs normalize on a fixed length, or (b) acknowledge that they may be variable length here, right?",
              "createdAt": "2020-07-15T18:26:28Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjUwNjcz",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-15T19:06:40Z",
          "updatedAt": "2020-07-15T19:06:40Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "Yes, it basically means \"the following criteria are sufficient to meet HPKE's security needs\". However, there is no proof yet that these criteria are actually sufficient for HPKE. Hence \u201cindications\u201d.\r\n\r\nIn Section \u201cSecurity Considerations\u201d we already have the formulation \u201cThe results from {{CS01}} provide some indication that any IND-CCA2-secure KEM will suffice here, but are not conclusive given the differences in the schemes.\u201d; that is from where I borrowed \u201cthere are indications\u201d.\r\n\r\nThese indications come from `CS01` and `SigncryptionDZ10`, as listed in the list elements.\r\n\r\nWould it be better already if we said \u201c{{CS01}} and {{SigncryptionDZ10}} provide some indications that the following criteria are sufficient to meet HPKE's security needs\u201d?",
              "createdAt": "2020-07-15T19:06:40Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5ODU5MjYy",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-16T13:42:19Z",
          "updatedAt": "2020-07-16T13:42:20Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I like the simpler approach. I was not happy about the clutter I introduced with the other (De)Serialize functions.",
              "createdAt": "2020-07-16T13:42:20Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5ODY2NDY4",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-16T13:49:56Z",
          "updatedAt": "2020-07-16T13:49:57Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Also, while it has been pointed out to us that there is a post-quantum KEM that provides different encodings for public keys, nobody told us about a KEM with different encodings for encapsulated keys, so this was just an idea that theoretically this could be the case. I did not have time yet to look at all the post-quantum KEM proposals.\r\n\r\nAnyway, all this to say that I am fine with dropping this explicit definitions.",
              "createdAt": "2020-07-16T13:49:56Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5ODgwNzQ3",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-16T14:04:25Z",
          "updatedAt": "2020-07-16T14:04:26Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "The above error names vanished now except the errors from Seal and Open. Do you want to remove those names as well? We are using them in the pseudo code, so I guess not?",
              "createdAt": "2020-07-16T14:04:25Z",
              "updatedAt": "2020-07-16T14:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5ODg5Nzcz",
          "commit": {
            "abbreviatedOid": "d39bacb"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-16T14:13:34Z",
          "updatedAt": "2020-07-16T14:13:35Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "We are accommodating this because of this review comment we got (https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/84):\r\n\r\n```\r\nAssumptions about the length of the public key. It may not always be a\r\nfixed value, \"Npk\", for a KEM with a given set of parameters. The other\r\n(and unrelated) \"hybrid\" draft, draft-ietf-tls-hybrid-design, Section 3.2,\r\nmakes accommodation for public keys associated with a given set of\r\nparameters to vary in size.\r\n```\r\n\r\nHere is a quote from Section 3.2 from https://tools.ietf.org/html/draft-ietf-tls-hybrid-design-00\r\n```\r\nfor example, the SIKE key encapsulation mechanism permits\r\ncompressed or uncompressed public keys at each security level, and\r\nthe compressed and uncompressed formats are interoperable.\r\n```",
              "createdAt": "2020-07-16T14:13:34Z",
              "updatedAt": "2020-07-16T14:13:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5ODkyMTIz",
          "commit": {
            "abbreviatedOid": "d39bacb"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-16T14:15:55Z",
          "updatedAt": "2020-07-16T14:15:56Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "I have no strong opinion on if we should require that those KEMs normalize on a fixed length or if we should just acknowledge the variable lengths. It might be beneficial to leave more freedom to future KEMs. I agree though that the current \u201cmaximum length\u201d formulations seem a bit messy.",
              "createdAt": "2020-07-16T14:15:55Z",
              "updatedAt": "2020-07-16T14:15:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 132,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NTU0MDkw",
      "title": "Update test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/132",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @blipp, @rozbb, @dmcardle",
      "createdAt": "2020-07-10T17:20:10Z",
      "updatedAt": "2020-07-10T17:23:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "1c7c34dbbb4be02331d2cf77ecef4e06361c7ccd",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/update-vectors",
      "headRefOid": "567c64ea3a0a37950dbec88fdfbae894556de2be",
      "closedAt": "2020-07-10T17:23:00Z",
      "mergedAt": "2020-07-10T17:23:00Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "bd80662476942d7d3c906a45a35d1e9700f5403b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 133,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NjA3Njg3",
      "title": "Removed zero function; all empty strings are \"\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/133",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "With the most recent changes, the only time the `zero` function appears is as `zero(0)`. I replace this with the empty string `\"\"` without explanation. Not sure if there should be explanation, or if so, where.",
      "createdAt": "2020-07-10T19:27:07Z",
      "updatedAt": "2020-07-10T19:28:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "bd80662476942d7d3c906a45a35d1e9700f5403b",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "remove-zeros",
      "headRefOid": "2f17edc8d8e6407cbdb4e88efe592cfb3e323096",
      "closedAt": "2020-07-10T19:28:18Z",
      "mergedAt": "2020-07-10T19:28:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "372b02c3dd8fbc46c01d66ac661b6eba0d4e4311"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NjUxNjgy",
          "commit": {
            "abbreviatedOid": "2f17edc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-10T19:28:13Z",
          "updatedAt": "2020-07-10T19:28:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 134,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3OTI3NDI2",
      "title": "Use email address that is available long-term",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/134",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "My Inria email address will become unavailable in roughly 2 years, so I thought I'd include one that is supposed to live longer.",
      "createdAt": "2020-07-12T17:06:47Z",
      "updatedAt": "2020-07-13T14:57:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "372b02c3dd8fbc46c01d66ac661b6eba0d4e4311",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_mail",
      "headRefOid": "8fea37b2bb859c954ad7a0ae5e27d427d4898cb1",
      "closedAt": "2020-07-13T14:57:02Z",
      "mergedAt": "2020-07-13T14:57:02Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "611686e3fb0b16c7348bce41c46151cf31a10dab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MzMwMzM1",
          "commit": {
            "abbreviatedOid": "8fea37b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T14:56:57Z",
          "updatedAt": "2020-07-13T14:56:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 135,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUwNDYzNTQ1",
      "title": "Editorial changes, clarifications, small fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/135",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Did a full pass. Lots of changes for consistency's sake.\r\n\r\nI think the definition of \"ciphersuite\" was kinda awkward. It was never defined, though, so _something_ is needed.\r\n\r\nI think the \"at most two entities\" bit here is a bit awkward, but I think it was technically wrong as it stood (we're not guaranteed that every KEM admits KCI).",
      "createdAt": "2020-07-16T19:49:12Z",
      "updatedAt": "2020-07-23T19:04:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "36b737c9bbfeec2e90f3113684beb33e968c863c",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "lc-editorial",
      "headRefOid": "08c7b021e33996f4ed7591d0b8cdaafa8b53266a",
      "closedAt": "2020-07-23T19:04:35Z",
      "mergedAt": "2020-07-23T19:04:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fc0f59bf2f8c19b1a4275e06d49cc206b2d0d583"
      },
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Important note: this breaks test vectors. In unifying the naming convention, I changed the context string \"pskID_hash\" to \"psk_id_hash\"",
          "createdAt": "2020-07-17T18:26:08Z",
          "updatedAt": "2020-07-17T18:26:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! I'll review this ASAP.",
          "createdAt": "2020-07-17T21:58:27Z",
          "updatedAt": "2020-07-17T21:58:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 138,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU1OTY2Njc5",
      "title": "Replace \"RFCXXXX\" with version-specific label.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/138",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #137.",
      "createdAt": "2020-07-23T21:41:44Z",
      "updatedAt": "2020-07-27T13:27:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d101f3bd3507c5d0fa20239d3ec855d2752c75d9",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/version-label",
      "headRefOid": "f083491fb3f605caad4883299a767a4508048203",
      "closedAt": "2020-07-27T13:27:11Z",
      "mergedAt": "2020-07-27T13:27:11Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "12388b7204c3c87f6c4e33a82085aba7196aeab7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 140,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU5MTQ2NTY4",
      "title": "Update test vectors to use the -05 label version.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/140",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "And replace \"zz\" with \"shared_secret\" to address #139.\r\n\r\ncc @davidben",
      "createdAt": "2020-07-30T12:51:57Z",
      "updatedAt": "2020-07-30T16:56:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "12388b7204c3c87f6c4e33a82085aba7196aeab7",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/update-vectors-2",
      "headRefOid": "68eefc8308c1d975739aee846a587a6181d6461f",
      "closedAt": "2020-07-30T16:56:10Z",
      "mergedAt": "2020-07-30T16:56:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "47ab7da225f421bc32301f3eaa5ec842ab880047"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxMTcyNDgy",
      "title": "Clarify that the output of all DH operations is the x-coordinate for NIST curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/148",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-20T18:41:08Z",
      "updatedAt": "2020-08-20T18:44:13Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "47ab7da225f421bc32301f3eaa5ec842ab880047",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/dh-ss",
      "headRefOid": "cf94e30034ca7746ba75b7d23ebd79c0fb1465b4",
      "closedAt": "2020-08-20T18:44:13Z",
      "mergedAt": "2020-08-20T18:44:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "66684a8842fefd7cee2a8b52624693828934f1b8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxODg3NjQx",
          "commit": {
            "abbreviatedOid": "cf94e30"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-20T18:44:06Z",
          "updatedAt": "2020-08-20T18:44:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 149,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxMjExMjg4",
      "title": "Apply new test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/149",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From https://github.com/cisco/go-hpke/pull/36",
      "createdAt": "2020-08-20T20:00:18Z",
      "updatedAt": "2020-08-20T20:13:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "66684a8842fefd7cee2a8b52624693828934f1b8",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/new-dh-vectors",
      "headRefOid": "bdcaa1de6bceca33025d844db2a31ae3afe4d542",
      "closedAt": "2020-08-20T20:13:28Z",
      "mergedAt": "2020-08-20T20:13:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "403bf8ce2385549f6e29a6fcac7bd2c5a1b0a1bf"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 150,
      "id": "MDExOlB1bGxSZXF1ZXN0NDczMTQ4NjUz",
      "title": "Editorial changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/150",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Partly based on JP's review from June.",
      "createdAt": "2020-08-25T11:49:04Z",
      "updatedAt": "2020-09-23T14:46:58Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "403bf8ce2385549f6e29a6fcac7bd2c5a1b0a1bf",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_editorial",
      "headRefOid": "5cd2a7b39daf9da2e273daf1cb8e9eb7116c5ab8",
      "closedAt": "2020-09-23T14:46:58Z",
      "mergedAt": "2020-09-23T14:46:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9d55cc6b41cad7f5ec30812b032c9ed2954e3507"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NzQxNzcy",
          "commit": {
            "abbreviatedOid": "5cd2a7b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-23T14:46:53Z",
          "updatedAt": "2020-09-23T14:46:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 151,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgwOTU4NTc5",
      "title": "Fix circular dependency in DeriveKeyPair",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/151",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "DeriveKeyPair is a method defined on KEMs, but it's implementation uses internal HPKE methods. This isn't necessary and can create a circular dependency between KEM implementations and HPKE",
      "createdAt": "2020-09-07T01:05:56Z",
      "updatedAt": "2020-09-07T14:11:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "403bf8ce2385549f6e29a6fcac7bd2c5a1b0a1bf",
      "headRepository": "Bren2010/draft-irtf-cfrg-hpke",
      "headRefName": "brendan/2020.9.0",
      "headRefOid": "dfae1d9d2415a4b65d057f84e068437612ba0990",
      "closedAt": "2020-09-07T14:11:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNTgwMTQ1",
          "commit": {
            "abbreviatedOid": "dfae1d9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "The editorial changes are fine, but please revert the Expand/Extract changes in both places. We specifically chose to use the Labeled variants for domain separation, as is required by the proofs. @blipp can provide more details if needed.",
          "createdAt": "2020-09-07T14:02:47Z",
          "updatedAt": "2020-09-07T14:02:47Z",
          "comments": []
        }
      ]
    }
  ]
}